
#include "@grm;_lexer.h"

@("char", "uchar", "short", "ushort", "int", "uint", "char*") 
@//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    @grm_name;_lexer.cpp																	         

/*    Generated by: @program; @version;
      Grammar:      @grm_file;
      Skeleton:     @skl_file;
      Output:       @out_file;
*/               
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    DFASTAR Lexer Tables.

		Token   @grm_name;_lexer::token;				// Token.
		int     @grm_name;_lexer::linenumb;		   // Line number of token.
		int     @grm_name;_lexer::colnumb;			// Column number of token.
		int     @grm_name;_lexer::tab;				// Tab setting for the input file.

@def_cons?;...
		char*   token_name[] =
		{
			@def_cons.1|"%s"||,\n         |;
		};

@@
@optn_small?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    Boolean Matrix and Vectors.

   // Boolean matrix. 
		@bmat_numb.t; @grm_name;_lexer::Bm [@bmat_numb.d;] = 
      {
      @bmat_numb.40|%2d|,|,\n      |;
      };

   // B_matrix row. 
      @bmat_row.t; @grm_name;_lexer::Br [@bmat_row.d;] = 
      {
      @bmat_row.20|%5d|,|,\n      |;
      };

   // B_matrix column. 
      @bmat_col.t; @grm_name;_lexer::Bc [@bmat_col.d;] = 
      {
      @bmat_col.20|%5d|,|,\n      |;
      };

@@
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    Terminal Transition Matrix and Vectors.                            

   // Transition matrix. 
      @tmat_numb.t; @grm_name;_lexer::Tm [@tmat_numb.d;] = 
      {
      @tmat_numb.20|%5d|,|,\n      |;
      };

   // T_matrix row. 
      @tmat_row.t; @grm_name;_lexer::Tr [@tmat_row.d;] = 
      {
      @tmat_row.20|%5d|,|,\n      |;
      };

   // T_matrix column. 
      @tmat_col.t; @grm_name;_lexer::Tc [@tmat_col.d;] = 
      {
      @tmat_col.20|%5d|,|,\n      |;
      };

   // Token numbers for each state. 
      @term_numb.t; @grm_name;_lexer::terminal [@term_numb.d;] = 
      {
      @term_numb.20|%5d|,|,\n      |;
      };

@strings?;...
   // String return values. 
      @strings.t; @grm_name;_lexer::string [@strings.d;] = 
      {
			@strings.1|%s|,|,\n         |;
      };

@@

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    DFASTAR Lexer.       																							  

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 

void  @grm;_lexer::lexer_init (char* input_start) 
{
		tab = 4;
      colnumb = 0;
		linenumb = 1;
		token.end = input_start;
}

@optn_medium?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 

int   @grm;_lexer::get_token ()			// Medium lexer.		
{
      int x, y;								// State, next state.
		do 
		{
    		x = 0;
			token.start = token.end;
			token.linenumb = linenumb;
      	while ((y = Tm [Tr [x] + Tc [(uchar)*token.end]]) > 0)   
			{
				x = y;
				if (*token.end == '\n') linenumb++;
			   token.end++;
			}
		}
  	  	while (terminal[x] < 0);			// Ignore whitespace.		
		return terminal[x];					// Return terminal number.	
}

@@ 
@optn_small?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 

int   @grm;_lexer::get_token ()			// Small lexer.
{
      int x;		   						// State.
		do
		{
			x = 0;
			token.start = token.end;
			token.linenumb = linenumb;
			while (Bm [Br [x] + Bc [(uchar)*token.end]])
			{
				x = Tm [Tr [x] + Tc [(uchar)*token.end]];
			  	if (*token.end == '\n') linenumb++;
			  	token.end++;
			}
		}
  	  	while (terminal[x] < 0);			// Ignore whitespace.		
		return terminal[x];					// Return terminal number.	
}

@@
//                                                                                                 // 
/////////////////////////////////////////////////////////////////////////////////////////////////////

