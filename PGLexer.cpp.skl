
#ifdef LRSTAR

@("char", "uchar", "short", "ushort", "int", "uint", "char*") 
@//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    @grm_name;Lexer.																	         

/*    Generated by: @program; @version;
      Grammar:      @grm_file;
      Skeleton:     @skl_file;
      Output:       @out_file;
*/               
      #include "ComGlobal.h"
      #include "PGLexer.h"

		Token   @grm_name;Lexer::token;					// Token.
  		int     @grm_name;Lexer::tab;				   // Tab setting for the input file.
		int     @grm_name;Lexer::line_numb;		   // Line number of token.
  		int     @grm_name;Lexer::col_numb;				// Column number of token.
		int	  @grm_name;Lexer::line_pos;
		char*   @grm_name;Lexer::line_start;		   // Line start pointer.
		int     @grm_name;Lexer::line_start_numb;	// Line number associated with line_start.

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 

void  @grm_name;Lexer::init_lexer (char* input_start) 
{
		tab = optn[PG_TAB]; 
		line_pos    = 0;
		line_numb   = 1;
		token.end   = input_start;
		line_start  = input_start;
	  	line_ptr[1] = input_start;
		line_start_numb = 1;
}

@optn_small?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    Terminal Transition Matrix and Vectors.

   // Bit matrix. 
		@bmat_numb.t; @grm_name;Lexer::Bm [@bmat_numb.d;] = 
      {
      @bmat_numb.40|%2d|,|,\n      |;
      };

   // B_matrix row. 
      @bmat_row.t; @grm_name;Lexer::Br [@bmat_row.d;] = 
      {
      @bmat_row.20|%5d|,|,\n      |;
      };

   // B_matrix column. 
      @bmat_col.t; @grm_name;Lexer::Bc [@bmat_col.d;] = 
      {
      @bmat_col.20|%5d|,|,\n      |;
      };

   // Terminal transition matrix. 
      @tmat_numb.t; @grm_name;Lexer::Tm [@tmat_numb.d;] = 
      {
      @tmat_numb.20|%5d|,|,\n      |;
      };

   // T_matrix row. 
      @tmat_row.t; @grm_name;Lexer::Tr [@tmat_row.d;] = 
      {
      @tmat_row.20|%5d|,|,\n      |;
      };

   // T_matrix column. 
      @tmat_col.t; @grm_name;Lexer::Tc [@tmat_col.d;] = 
      {
      @tmat_col.20|%5d|,|,\n      |;
      };

   // Token numbers for each state. 
      ushort @grm_name;Lexer::terminal [@term_numb.d;] = 
      {
      @term_numb.20|%5d|,|,\n      |;
      };

@/*
@def_cons?;...
   // Defined constants, one for each state. 
      static @term_numb.t; terminal [@term_numb.d;] = 
      {
         @term_numb.1|%s||,\n         |;
      };

@@
@*/
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		get_token	

int   @grm_name;Lexer::get_token ()				 // Small @grm_name;Lexer.
{
      int x;		   						 // State, next state.
		do
		{
			x = 0;
			token.start = token.end;
			token.linenumb = line_numb;
			while (Bm [Br [x] + Bc [(uchar)*token.end]])
			{
				x = Tm [Tr [x] + Tc [(uchar)*token.end]];
@optn_line?;...
			  	if (*token.end == '\n') 
				{
					line_numb++;
@optn_debug?;...
					line_start = token.end+1;
					line_start_numb++;
@@
				}
@@
			  	token.end++;
			}
		}
  	  	while (terminal[x] < 0);	// Ignore whitespace.		
		return terminal[x];			// Return terminal number.	
}

@@
@optn_medium?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    Terminal Transition Matrix and Vectors.                            

   // Terminal transition matrix. 
      @tmat_numb.t; @grm_name;Lexer::Tm [@tmat_numb.d;] = 
      {
      @tmat_numb.20|%5d|,|,\n      |;
      };

   // T_matrix row. 
      @tmat_row.t; @grm_name;Lexer::Tr [@tmat_row.d;] = 
      {
      @tmat_row.20|%5d|,|,\n      |;
      };

   // T_matrix column. 
      @tmat_col.t; @grm_name;Lexer::Tc [@tmat_col.d;] = 
      {
      @tmat_col.20|%5d|,|,\n      |;
      };

   // Token numbers for each state. 
      @term_numb.t; @grm_name;Lexer::terminal [@term_numb.d;] = 
      {
      @term_numb.20|%5d|,|,\n      |;
      };

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		get_token	

int   @grm_name;Lexer::get_token ()			
{
      int state, next;	// State, next state.
		do 
		{
			state = 0;
			token.start  = token.end;				// Set start of Token.
			token.column = col_numb + 1;			// Set column number.
			token.line   = line_numb;			   // Set line number of Token.
       	while (next = Tm [Tr [state] + Tc [*token.end]])
			{
			  	if (*token.end == '\n') 
				{
					col_numb = 0;
					line_pos = 0;
					line_start = token.end + 1;	// Set beginning of next line.
				  	line_ptr [++line_numb] = line_start;
					line_start_numb++;
				}
			   else if (*token.end == '\t')				// If tab character.
				{
					col_numb += tab - (col_numb % tab);	
				}	  
				else 
				{
					col_numb++;							// Increment column.
				}
				token.end++;							// Increment Token pointer.
				state = next;							// Set next state number.
			}
		}
      while (terminal[state] < 0);
		line_pos++;
      return terminal[state];
}

@@
@optn_debug?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		prt_line	

void  @grm_name;Lexer::prt_line ()
{
      char line[256];
	  	if (line_start != NULL)
      {
			int len = 0;
         char* p = line_start;
         char* q = line;
		   while (*p != '\n') 
         {
            if (*p == '\t') *q++ = ' ';
            else            *q++ = *p;
            p++;
				if (++len == 255) break;
         }
		   *q = 0;
		   prt_log ("%05d %s\n\n", line_start_numb, line);
		   line_start = NULL; // Disable printing line until PGLexer sees a '\n'
      }
}

@@
///////////////////////////////////////////////////////////////////////////////
//                                                                           //

int	@grm_name;Lexer::get_lookahead (int& linenumber)
{
      char* TS   = token.start;
      char* TE   = token.end;
      int   TSTI = token.sti;
		int   TL   = token.line;
      int   TC   = token.column;
      int   LN   = line_numb;
      int   LC   = col_numb;
      int   LP   = line_pos;

      int   la   = get_token();  // Get lookahead token number.
		linenumber = token.line;	// Set line number of lookahead.

      token.start  = TS;         // Reset token start.
      token.end    = TE;         // Reset token end.
		token.sti    = TSTI;
      token.line   = TL;         // Reset token column.
      token.column = TC;         // Reset token column.
      line_numb    = LN;         // Reset line number.
      col_numb     = LC;         // Reset line column.
      line_pos     = LP;         // Reset line position.
		return (la);
}

//                                                                                                 // 
/////////////////////////////////////////////////////////////////////////////////////////////////////

#endif
