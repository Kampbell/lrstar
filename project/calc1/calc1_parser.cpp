
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//    LRSTAR Parser Tables.

/*    Generated by: LRSTAR 6.3.006
      Grammar:      calc1.grm																									    
      Skeleton:     ..\..\skl\parser.cpp.skl
      Output:       calc1_parser.cpp
*/               
		#include "string.h"
  		#include "calc1_parser.h"
  		#include "calc1_actions.h"   

		#define ACCEPT_STATE	    36 // Final state.

/*--- Constants. -------------------------------------------------------------*/
                                                                                          
      int calc1_parser::n_terms      =    21; // No. of terminals.                               
      int calc1_parser::n_heads      =    17; // No. of non-terminals.     
      int calc1_parser::n_prods      =    29; // No. of productions.       
      int calc1_parser::n_states     =    37; // No. of states.
      int calc1_parser::eol_symb     =     0; // EOL symbol number            
      int calc1_parser::eof_symb     =     3; // EOF symbol number            
      int calc1_parser::err_used     =     0; // <error> used in grammar      
      int calc1_parser::n_nodenames  =    16; // No. of node names.   
      int calc1_parser::n_nodeactns  =     1; // No. of node actions.   

/*--- Terminal and Nonterminal Symbols of the Grammar. -----------------------*/

   // Terminal symbols of the grammar. 
      char* calc1_parser::term_symb[21] = 
      {
         "<error>",
         "<identifier>",
         "<integer>",
         "<eof>",
         "\'==\'",
         "\'!=\'",
         "\'+\'",
         "\'-\'",
         "\'*\'",
         "\'/\'",
         "\'program\'",
         "\'{\'",
         "\'}\'",
         "\'=\'",
         "\';\'",
         "\'if\'",
         "\'endif\'",
         "\'(\'",
         "\')\'",
         "\'then\'",
         "\'else\'"
      };                                                 

   // Head symbols of the grammar. 
      char* calc1_parser::head_symb[17] = 
      {
         "Goal",
         "Program",
         "Stmt",
         "Assignment",
         "IfThen",
         "IfElse",
         "IfThenElse",
         "Target",
         "RelExp",
         "Exp",
         "Primary",
         "Then",
         "Else",
         "Then2",
         "Else2",
         "Program...",
         "Stmt..."
      };
  
   // Head symbol for a production 
      uchar calc1_parser::head_numb[29] = 
      {
          0,    1,    2,    2,    2,    2,    3,    4,    5,    6,    7,    8,    8,    9,    9,    9,    9,    9,   10,   10,
         10,   11,   12,   13,   14,   15,   15,   16,   16
      };

   // Index to first tail symbol for a production 
      uchar calc1_parser::f_tail[30] = 
      {
          0,    2,    7,    8,    9,   10,   11,   15,   19,   23,   28,   29,   32,   35,   36,   39,   42,   45,   48,   49,
         50,   53,   55,   57,   59,   61,   62,   64,   65,   67
      };

   // Tail symbol numbers (T: >= 0, NT: < 0)
      char calc1_parser::tail[67] = 
      {
        -15,    3,   10,    1,   11,  -16,   12,   -3,   -4,   -5,   -6,   -7,   13,   -9,   14,   15,   -8,  -11,   16,   15,
         -8,  -12,   16,   15,   -8,  -13,  -14,   16,    1,   -9,    4,   -9,   -9,    5,   -9,  -10,   -9,    6,   -9,   -9,
          7,   -9,   -9,    8,   -9,   -9,    9,   -9,    2,    1,   17,   -9,   18,   19,  -16,   20,  -16,   19,  -16,   20,
        -16,   -1,  -15,   -1,   -2,  -16,   -2
      };

/*--- Bit Matrix and Access Vectors. -----------------------------------------*/

   // B_matrix.  
      uchar calc1_parser::Bm [33] = 
      {
          0,    0,  128,    0,  136,    0,    2,    0,    0,    1,    2,   16,    0,    4,    2,   18,    6,    0,  128,    1,
        112,    0,   96,    8,    0,   32,   96,   64,   96,    0,   64,    0,    0
      };

   // B_matrix row. 
      uchar calc1_parser::Br [37] = 
      {
          2,    4,    6,    8,   10,   12,   14,   16,   16,   17,   20,   16,   22,   24,   24,    7,   10,   10,   16,   16,
         16,   16,   16,   16,   26,   24,   10,   10,   10,   28,   28,   30,   30,    0,    0,   10,    0
      };

   // B_matrix column.
      uchar calc1_parser::Bc [21] = 
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,    1,    1,    1,    1,    1,    0,    1,    1,
          2
      };
  
	// B_matrix column.
      uchar calc1_parser::Bmask [21] = 
      {
          1,    2,    4,    8,   16,   16,   32,   32,   64,   64,  128,    1,    2,    4,    8,   16,   32,    4,   64,  128,
          1
      };
  
/*--- Terminal Transition Matrix and Access Vectors. -------------------------*/

   // T_matrix. 
      char calc1_parser::Tm [35] = 
      {
        -19,    0,    0,  -10,    0,    0,    0,  -18,    0,    0,   -1,   -9,   11,    7,   -8,    0,    0,    0,   26,    3,
         20,   21,   22,   23,    2,    4,   36,    8,   -6,   18,   -7,   19,  -20,   16,   17
      };

   // T_matrix row. 
      uchar calc1_parser::Tr [37] = 
      {
         19,   19,   19,   19,    3,   19,    3,    0,    0,   19,   19,    0,   19,   19,    3,    3,    3,    3,    0,    0,
          0,    0,    0,    0,   19,    0,    3,    3,    3,   19,   19,   19,   19,   19,   19,    3,   19
      };

   // T_matrix column. 
      uchar calc1_parser::Tc [21] = 
      {
          0,    0,    7,    7,   10,   12,    1,    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
         15
      };

/*--- Nonterminal Transition Matrix and Access Vectors. ----------------------*/

   // N_matrix. 
      char calc1_parser::Nm [87] = 
      {
          0,    0,    0,    0,    0,    0,    0,    0,   31,  -13,   32,  -13,   33,  -13,   34,  -13,  -26,  -28,   -2,   -3,
         -4,   -5,    5,    0,   12,  -13,  -27,   -2,   -3,   -4,   -5,    5,    0,   24,  -13,    0,    0,    0,    0,    0,
         27,  -27,   -2,   -3,   -4,   -5,    5,    0,   29,  -13,    0,    0,    0,    0,    0,   28,  -27,   -2,   -3,   -4,
         -5,    5,    0,   30,  -13,    0,    0,    0,    0,    0,   35,  -25,  -27,   -2,   -3,   -4,   -5,    5,    9,   10,
        -13,   13,   14,   15,   25,    1,    6
      };

   // N_matrix row. 
      uchar calc1_parser::Nr [37] = 
      {
         71,   16,   71,   71,   71,   71,   16,   71,   16,   71,   71,   25,   71,   71,   71,   71,   25,   40,   40,   55,
          0,    2,    4,    6,   71,   71,   55,   16,   16,   71,   71,   71,   71,   71,   71,   16,   71
      };

   // N_matrix column. 
      uchar calc1_parser::Nc [29] = 
      {
          0,    0,    1,    1,    1,    1,    2,    3,    4,    5,    6,    7,    7,    8,    8,    8,    8,    8,    9,    9,
          9,   10,   11,   12,   13,   14,   14,   15,   15
      };

/*--- Reduction Matrix and Access Vectors. -----------------------------------*/

   // R_matrix. 
      uchar calc1_parser::Rm [5] = 
      {
          0,    0,    0,   21,   23
      };

   // R_matrix row. 
      char calc1_parser::Rr [37] = 
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,   -2,   22,   11,   12,   14,   15,   16,   17,   24,    0
      };

   // R_matrix column. 
      uchar calc1_parser::Rc [21] = 
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,    0,    0,    0,
          2
      };

/*--- Nondeterministic Parsing Arrays. ---------------------------------------*/

   // Nondeterministic Start. 
      uchar calc1_parser::nd_start [38] = 
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0
      };

   // Nondeterministic Terminal Symbol. 
      uchar calc1_parser::nd_term [1] = 
      {
         0
      };

   // Nondeterministic Action.
      uchar calc1_parser::nd_action [1] = 
      {
         0
      };

/*--- Production Variables. --------------------------------------------------*/

   // Production length - 1 
      char calc1_parser::PL[29] = 
      {
          1,    4,    0,    0,    0,    0,    3,    3,    3,    4,    0,    2,    2,    0,    2,    2,    2,    2,    0,    0,
          2,    1,    1,    1,    1,    0,    1,    0,    1
      };

   // Reverse the order of nodes (for a production/rule).
      uchar calc1_parser::reverse[29] = 
      {
          0,    0,    0,    0,    0,    0,    1,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0
      };

/*--- Token Action Variables -------------------------------------------------*/

	// Token Action number. 
      char calc1_parser::tact_numb[21] = 
      {
          0,    1,    1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1
      };

   // Token Action Function Pointers.	
      int (*calc1_parser::tact_func[2]) (int&) = 
      {
			calc1_token_action::error,
         calc1_token_action::lookup
      };

	// First argument index for token actions.
      char calc1_parser::tact_arg[21] = 
      {
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1
      };

/*--- Parser Action Variables ------------------------------------------------*/

   // Parser Action Number
      char calc1_parser::pact_numb[29] = 
      {
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

   // Parser Action Function Pointers	
      int (*calc1_parser::pact_func[1]) (int) = 
      {
			0
      };

	// Parser Action Argument Index and first argument for make_node.
      char calc1_parser::pact_arg[29] = 
      {
         -1,    3,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   19,   23,   27,   -1,   31,   35,   39,   43,   47,   51,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

/*--- Make-Node Variables ----------------------------------------------------*/

   // Make-Node Numbers (for a production).
      char calc1_parser::node_numb[29] = 
      {
          0,    1,   -1,   -1,   -1,   -1,    2,    3,    3,    3,    4,    5,    6,   -1,    7,    8,    9,   10,   11,    4,
         -1,   12,   13,   14,   15,   -1,   -1,   -1,   -1
      };

   // Node Names.
      char* calc1_parser::node_name[16] = 
      {
      "goal_",
      "program_",
      "assign_",
      "if_",
      "ident_",
      "eq_",
      "ne_",
      "add_",
      "sub_",
      "mul_",
      "div_",
      "intr_",
      "then_",
      "else_",
      "then2_",
      "else2_"
      };

/*--- Node-Action Variables --------------------------------------------------*/

   // Node-Action Numbers. 
      char calc1_parser::nact_numb[29] = 
      {
          0,    0,   -1,   -1,   -1,   -1,    0,    0,    0,    0,    0,    0,    0,   -1,    0,    0,    0,    0,    0,    0,
         -1,    0,    0,    0,    0,   -1,   -1,   -1,   -1
      };

	// Node-Action Function Pointers.
      int (*calc1_parser::nact_func[1]) (int n) = 
      {
			calc1_node_action::emit
      };   

   // Node Action Argument Index
      char calc1_parser::nact_arg[29] = 
      {
          0,    4,   -1,   -1,   -1,   -1,    7,   10,   13,   16,   20,   24,   28,   -1,   32,   36,   40,   44,   48,   52,
         -1,   55,   58,   61,   64,   -1,   -1,   -1,   -1
      };

/*--- Argument Numbers. ------------------------------------------------------*/

   // Parse action argument numbers 
      char calc1_parser::arg_numb[67] = 
      {
          0,   -1,    1,    2,    2,   -1,    3,   -1,   -1,    4,    5,   -1,    6,    5,   -1,    6,    5,   -1,    6,    1,
         -1,   -1,    7,    2,   -1,   -1,    8,    2,   -1,   -1,    9,    2,   -1,   -1,   10,    2,   -1,   -1,   11,    2,
         -1,   -1,   12,    2,   -1,   -1,   13,    1,   -1,   -1,   14,    1,   -1,   -1,   14,   15,   -1,   -1,   16,   -1,
         -1,   17,   -1,   -1,   18,   -1,   -1
      };

   // Text for string arguments. 
      char* calc1_parser::arg_text[19] = 
      {
         "\t\tSTART\n",
         "\t\tEOF\n",
         "\t\tPROGRAM %s\n",
         "\t\tEND PROGRAM %s\n",
         "\t\tSTORE\n",
         "if&0:\n",
         "endif&0:\n",
         "\t\tLADR %s\n",
         "\t\tEQ\n",
         "\t\tNE\n",
         "\t\tADD\n",
         "\t\tSUB\n",
         "\t\tMUL\n",
         "\t\tDIV\n",
         "\t\tLOAD %s\n",
         "\t\tBR NZ endif&1\nthen&1:\n",
         "\t\tBR Z endif&1\nelse&1:\n",
         "\t\tBR NZ else&1\nthen&1:\n",
         "\t\tBR endif&1\nelse&1:\n"
      };


/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    LRSTAR Parser.

		#include "string.h"

		#define STKSIZE    1000 // Parser stack size.    
		#ifndef LOOKAHEADS
		#define LOOKAHEADS 3		// Number of lookaheads for LR(*) parsing.
		#endif

		#ifndef UINT_MAX
	  	#define UINT_MAX 0xffffffff 					// for 32-bit CPUs.			
	// #define UINT_MAX 0xffffffffffffffff 		// for 64-bit CPUs.			
		#endif

	// Parser stuff ...
		PStack*  calc1_parser::PS;                  
		PStack*  calc1_parser::PS_end;                  
      PStack   calc1_parser::P_stack[STKSIZE];   
		int      calc1_parser::n_errors;
		int      calc1_parser::max_errs;
		int      calc1_parser::status;
		char*		calc1_parser::inputname;
		FILE*		calc1_parser::outputdesc;

	// Restore stack stuff ...
      RStack*	calc1_parser::RS; 
      RStack	calc1_parser::R_stack[STKSIZE]; 
  		PStack*  calc1_parser::PStop;
  		int      calc1_parser::topstate;

	// Symbol table stuff ...
      Symbol*  Symtab::symbol;
		int      Symtab::cell;
		int      Symtab::sti;
		int      Symtab::length;
		int      Symtab::n_symbols;
		int      Symtab::n_keywords;
		uint     Symtab::hashdiv;
		int*		Symtab::hashvec;
		int		Symtab::max_cells;
		int		Symtab::max_symbols;

		// AST stuff ...
		Node*    AST::node;
		int      AST::root;
  		int      AST::n_nodes;
  		int      AST::max_nodes;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    calc1_parser -  initialization																  

int   calc1_parser::init (char* Inputname, FILE* Outputdesc, int max_symb, int max_node)
{
		inputname  = Inputname;										// Move name into parser object.
		outputdesc = Outputdesc;									// Move desc into parser object.

		if (!init_symtab (max_symb)) return (0);           // Initialize the symbol table.
		if (!init_ast (max_node)) return (0);              // Initialize the AST. 
		token.start = "";                                  // Make a blank symbol.
		token.end   = token.start + 1;
		add_symbol (0, token.start, token.end);				// Add it to the symbol table.

      n_errors = 0;							                  // Set number of errors.    
      max_errs = 10;							                  // Set max number of errors.
		return (1); // Return OK.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    calc1_parser -  termination

void  calc1_parser::term ()
{
		print_symtab (term_symb);			                  // Print the symbol table contents.
		print_ast ();							                  // Print the AST, if ast option indicates.
		traverse	 ();							                  // Traverse the AST, calling the AST actions.
		term_ast  ();
		term_symtab ();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		Minimal LR Parser

int   calc1_parser::parse (char* input_start)                
{
      int p;                                          	// Production (rule) number.  
      int t;                                          	// Terminal symbol number. 
      int x = 0;                                      	// State number.  

		lexer_init (input_start);									// Initialize lexer.
      PS_end = P_stack + STKSIZE;			            	// Set parse-stack end pointer.   
      PS     = P_stack;							            	// Set parse-stack pointer.   

Read:	t = get_token ();												// Get incoming token.
		prt_line ();
		token.sti = -t;												// Symbol-table index = -t.
      if (tact_numb[t] >= 0)					            	// If token action ...         
      {
         token.sti = (*tact_func [tact_numb[t]])(t);  	// Call token-action function.
      }
Shft: if (Bm [Br[x] + Bc[t]] & Bmask[t])	            	// Check B-matrix for shift action. 
      {
			if (++PS >= PS_end) goto Over;						// Check for stack overflow.
         PS->state = x;                               	// Put current state on stack.  
         PS->sti   = token.sti;                       	// Put token symbol table index on stack.
         PS->line  = token.linenumb;                  	// Put its line number on stack.
         PS->node  = 0;						               	// Set node on stack to zero.   
         x = Tm [Tr[x] + Tc[t]];                      	// Get next state from terminal transition matrix.
         while (x <= 0)                               	// While shift-reduce actions. 
         {
				p = -x;													// Reduce stack by production p.	
            PS -= PL[p];											// Reduce stack ptr by production length. 
			  	if (!reduce(p)) return -linenumb;				// Call reduce action with rule number.
            x = Nm [Nr[PS->state] + Nc[p]];					// Get next state from nonterminal transition.
         }
         goto Read;								               // Go to read next token.
      }
		if ((p = Rr[x]) > 0 || (p = Rm [Rc[t] - p]) > 0)   // Get reduction?
      {
			PS -= PL[p];												// Reduce parse stack ptr by rule length - 1. 
         if (PL[p] < 0)							               // Null production?
         {	
				if (PS >= PS_end) goto Over;						// Check for overflow.
            PS->node  = 0;						               // Clear node pointer.
            PS->state = x;						               // Stack current state, replacing old state.
         }
         while (1) 
         {
      		if (!reduce(p)) return -linenumb;				// Call reduce action with rule number.
            x = Nm [Nr[PS->state] + Nc[p]];	            // Get next state from nonterminal transition.
            if (x > 0) goto Shft;                        // Continue parsing.
            p = -x;								               // Set production number.
            PS -= PL[p];                                 // Reduce parse stack ptr by rule length - 1. 
         }
		}
      if (x == ACCEPT_STATE)					               // If Goal production.  
      {
         PS -= PL[0];                                    // Reduce parse stack ptr by rule length - 1. 
     	  	if (!reduce(0)) return -linenumb;					// Call reduce action with rule number.
         if (linenumb > 0) linenumb = --linenumb;			// Reduce line number by one.
			root = PS[0].node;                              // Define root node.
			return linenumb;						               // Return number of lines parsed.
      }

		prt_error (term_symb[t]);				               // Print syntax error message. 
		return -linenumb;							               // Return negative number of lines for failure. 

Over: printf  ("\nParser stack overflow.\n\n");
		return -linenumb;							               // Return negative number of lines for failure. 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		reduce

int   calc1_parser::reduce (int p)
{
		int psi;	 														// Parse Stack Index.
		if (node_numb[p] >= 0)   					            // MAKE NODE ?
		{
			if (n_nodes >= max_nodes)						      // If too many nodes?  
			{
				printf  (            "Number of AST nodes exceeds limit of %d.\n", max_nodes);
				fprintf (outputdesc, "Number of AST nodes exceeds limit of %d.\n", max_nodes);
				return (0);										
			}
			node[n_nodes].id     = node_numb[p];			   // Set node id. 
			node[n_nodes].prod   = p;							   // Put production (rule) number in node.
			node[n_nodes].prev   = 0;							   // Set prev to nonexistent.
			node[n_nodes].next   = 0;							   // Set next to nonexistent.
			node[n_nodes].child  = 0;							   // Set child to nonexistent.
			node[n_nodes].parent = 0;							   // Set parent to nonexistent.
			if (pact_arg[p] >= 0)				   		      // If first parse-action argument specified in grammar.
			{
				psi = arg_numb[pact_arg[p]]-1;	   	      // Get parse-stack index.
				node[n_nodes].sti  = PS[psi].sti;		      // Move sti from parse stack to node.
				node[n_nodes].line = PS[psi].line;	         // Move line from parse stack to node.
			} 
			else
			{
				node[n_nodes].sti  = 0;    					   // Set symbol-table index to zero.
				node[n_nodes].line = 0;    					   // Set line number to zero.
			}
			psi = linkup(p);									      // Linkup the nodes in this rule. 
			if (psi >= 0)										      // Any nodes found in this rule?
			{
				node[n_nodes].child = PS[psi].node;		      // Define child. 
				node[PS[psi].node].parent = n_nodes;         // Define parent.
				node[n_nodes].line = 0;								// Reset line number. 
			}
			PS[0].node = n_nodes;									// Define node in the parse stack.
			PS[0].last = n_nodes++;									// Define node in the parse stack.
		}  
		else	                                             // Check for nodes not linked?
		{
			psi = linkup (p);                               // Get parse-stack index.  
			if (psi > 0)                                    // If we have a node here ...
			{
				PS[0].node = PS[psi].node;		               // Move node value to 1st position.
				PS[0].last = PS[psi].last;		               // Move last value also.
			}
		}  
		return 1; // OK. 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		linkup

int   calc1_parser::linkup (int p)      
{
      int next = -1;
      int i;
      if (reverse[p] == 0)                               // IF NOT TO REVERSE THE ORDER. 
      {
         for (i = PL[p]; i >= 0; i--)				         // For each tail pointer. 
         {
            if (PS[i].node > 0)                          // If tail points to node.	  
            {
               if (next >= 0)                            // If one waiting.        
               {
                  node[PS[i].last].next = PS[next].node; // Define next node.
                  node[PS[next].node].prev = PS[i].last; // Define previous node.
                  PS[i].last = PS[next].last;            // Change last to next last.
               }
               next = i;									      // Next = Curr.  
				}
			}  
		}
      else                                               // REVERSE THE ORDER.
      {
         for (i = 0; i <= PL[p]; i++)				         // For each tail pointer. 
         {
            if (PS[i].node > 0)                          // If tail points to node.
            {
               if (next >= 0)                            // If one waiting.        
               {
                  node[PS[i].last].next = PS[next].node; // Define next node.
                  node[PS[next].node].prev = PS[i].last; // Define previous node.
                  PS[i].last = PS[next].last;            // Change last to next last.
               }
               next = i;									      // Next = Curr.  
				}  
			}  
		}
   // if (next >= 0) print_ast(PS[next].node);				// For debugging.
      return (next); 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    prt_error	

void  calc1_parser::prt_error (char *symb)
{       
      int  i, col, ln1, ln2;
      char string[256], *ls1, *ls2, *le1, *le2, *p, c;

	// Get first line number ...
      ln1 = linenumb;
		for (p = token.end-1; p > token.start; p--)
		{
			if (*p == '\n' || *p == 0) ln1--;
		}

	// Get first line start ...
		for (ls1 = token.start; *ls1 != '\n' && *ls1 != 0; ls1--); 
		ls1++;

	// Get first line end ...
		for (le1 = token.start; *le1 != '\n' && *le1 != 0; le1++);

	// Get last line number ...
      ln2 = linenumb;

	// Get last line start ...
		for (ls2 = token.end-1; *ls2 != '\n' && *ls2 != 0; ls2--); 
		ls2++;

	// Get last line end ...
		for (le2 = token.end; *le2 != '\n' && *le2 != 0; le2++);
		*le1 = 0;
		*le2 = 0;

		if (*token.start == '\n' || *token.start == 0) ln1--;

		printf  (            "\n%s(%d) : Error  %s\n", inputname, ln1, ls1);
		fprintf (outputdesc, "\n%s(%d) : Error  %s\n", inputname, ln1, ls1);
      *le1 = '\n'; // In case token is this <eol>

      col = 1;
      for (p = ls1; p < token.start; p++)   
      {
         if (*p == '\t') *p = ' ';
         col++;
      }
      for (i = 0; i < col; i++) string[i] = '-';
      string [col] = 0;
		printf  (            "%s(%d) : Error %s^ ", inputname, ln1, string);
		fprintf (outputdesc, "%s(%d) : Error %s^ ", inputname, ln1, string);

      if (*token.start <= 32) 
      {
         int x = *token.start;
         if (x < 0) x += 256;
         printf  (            "at \\%d %s\n\n", x, symb);
         fprintf (outputdesc, "at \\%d %s\n\n", x, symb);
      }
      else
      {
         if (token.end == token.start) token.end++;
         if (token.end > le1) 
         {
				if (*token.start == '\n') *token.start = 0;
            if (*token.end   == EOF_CHAR) linenumb--;
            c = *le1; 
            *le1 = 0;
            printf  (            "starts here\n");
            fprintf (outputdesc, "starts here\n");
				printf  (            "\n%s(%d) : Error  %s\n", inputname, ln2, ls2);
				fprintf (outputdesc, "\n%s(%d) : Error  %s\n", inputname, ln2, ls2);
				col = 1;
				for (p = ls2; p < token.end; p++)   
				{
					if (*p == '\t') *p = ' ';
					col++;
				}
				for (i = 0; i < col; i++) string[i] = '-';
				string [col] = 0;
				printf  (            "%s(%d) : Error %s^ ", inputname, ln2, string);
				fprintf (outputdesc, "%s(%d) : Error %s^ ", inputname, ln2, string);
				printf  (            "ends here.\n\n");
				fprintf (outputdesc, "ends here.\n\n");
            *le1 = c;
         }
         else
         {
            c = *token.end; 
            *token.end = 0;
				if (*token.start == '\n') *token.start = 0;
            printf  (            "at %s %s\n\n", token.start, symb);
            fprintf (outputdesc, "at %s %s\n\n", token.start, symb);
            *token.end = c;
         }
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		expecting // Print expecting list. 

void  calc1_parser::expecting (int state)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		collect: Collect terminals that cause a transition or reduction.			                     

void	calc1_parser::collect (int x) 
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    prt_prod                                                                                     

void	calc1_parser::prt_prod (int p)
{
		printf  (            "         reduce    %6d %s <- ", p, head_symb [head_numb[p]]);
		fprintf (outputdesc, "         reduce    %6d %s <- ", p, head_symb [head_numb[p]]);
		int i;
		int first = f_tail[p];
		int next_first = f_tail[p+1];
		for (i = first; i < next_first; i++)
		{
			char* symb;
			int   s = tail[i];
			if (s >= 0) symb = term_symb[ s];
			else        symb = head_symb[-s];
			printf  (            "%s ", symb);
			fprintf (outputdesc, "%s ", symb);
		}
		printf  (            "\n");
		fprintf (outputdesc, "\n");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    init_symtab

int   calc1_parser::init_symtab (int max_symb) 
{
      int i; 
		if (max_symb <= 0) 
		{	
			printf  (            "Maximum number of symbols cannot be zero or negative.\n");
			fprintf (outputdesc, "Maximum number of symbols cannot be zero or negative.\n");
			return (0);
		}
		max_symbols   = max_symb;
		max_cells     = 2*max_symbols;
		symbol        = new Symbol[max_symbols];
      hashvec       = new int[max_cells];
      hashdiv       = UINT_MAX / max_cells + 1;
      n_symbols	  = 0;
      n_keywords	  = 0;
      if (symbol == NULL || hashvec == NULL)
      {
			printf  (            "Not enough memory available for Symbol Table.\n");
			fprintf (outputdesc, "Not enough memory available for Symbol Table.\n");
         return (0); // Return error.
      }
      for (i = 0; i < max_cells; i++) 
		{
			hashvec[i] = -1;
		}
		return (1); // Return OK.
}
													        
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    term_symtab

void  calc1_parser::term_symtab () 
{
      delete [] symbol;
      delete [] hashvec;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    add_symb - add symbol to table.     											                        

int	calc1_parser::add_symbol (int t, char* token_start, char* token_end) 
{
		sti = get_symbol (token_start, token_end);
		if (sti < 0) 
		{
			sti = n_symbols;
			if (n_symbols >= max_symbols)				// Reached maximum number? 
			{
				printf  (            "Number of symbols exceeds %d.\n", max_symbols);
				fprintf (outputdesc, "Number of symbols exceeds %d.\n", max_symbols);
				return (0); // Return error.
			}
			hashvec[cell] = n_symbols;					// Put symbol number into hash vector.     
			symbol[n_symbols].name = token_start;	// Define pointer to symbol name.
			symbol[n_symbols].length = length;		//	Define symbol name length.
			symbol[n_symbols].term = t;				// Define terminal number (<identifier>, <string>, <number>, ...)
			symbol[n_symbols].type = 0;				// Define type as undefined (zero).
			symbol[n_symbols].cell = cell;			// Define hash vector cell number for this symbol.
			n_symbols++;									// Increment number of symbols.
		}
      return (sti);										// Return symbol-table index.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    get_symbol - get symbol number from table.									                        

int   calc1_parser::get_symbol (char* token_start, char* token_end) 
{
      char* p = token_start;					 		// Point at start.
      length  = token_end - token_start;  		// Set length. 
      uint hash = length;         	   			// Set hash to length. 
      int i = 0;						   				// Set shift value to 0.
      do									      			// Assume length != 0
      {
         hash += *p << i;
         i += 4;		                  			
         i %= 32;
      }
      while (++p < token_end);
      cell = hash % max_cells; 						// Get first cell.
		i = hashvec [cell];				   			// Get symbol index.
      if (i >= 0) 
		{
			p = token_start;						   	// Point at token start.
			do
			{
				if (symbol[i].length == length)		// If lengths are equal ...
				{
					char* q = symbol[i].name;			// Point at symbol name.
					int j = 0; 
					do 
					{
						if (p[j] != q[j]) goto Cont;	// If characters not equal ...		
					}
					while (++j < length);				// while end not reached. 
					return (i);								// Found it.
				}
	Cont:    cell = (hash *= 65549)/hashdiv;		// Get new cell number.
				i = hashvec [cell];						// Get symbol index.
			}
			while (i >= 0);      						// While not empty slot.
		}
      return (i);											// Return symbol number.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    print - print symbol table contents.     										                        

void  calc1_parser::print_symtab (char* term_symb[])
{
		if (n_symbols > 1)
		{
			fprintf (outputdesc, "Symbol Table ...\n\n");
			fprintf (outputdesc, "  sti  leng  type  term  \n");

			for (int i = 1; i < n_symbols; i++)
			{
				fprintf (outputdesc, "%5d %5d %5d %5d   %-30s  %s\n",
					i,
					symbol[i].length,
					symbol[i].type,
					symbol[i].term, 
					term_symb[symbol[i].term],
					symbol_name(i)); 
			}   
			fprintf (outputdesc, "\n");
		}
		else
		{
			fprintf (outputdesc, "Symbol Table is empty!\n\n");
		}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    symname - get symbol name. 

char* calc1_parser::symbol_name (int i)
{
      char* p;
      int L;
      static char name[100];
		if (i == 0) 
		{
			name[0] = 0;
		}
		else
		{
			p = symbol[i].name;
			L = symbol[i].length;
			if (L >= 100) 
			{
				L = 95;
				for (i = 0; i < L; i++) name[i] = p[i];
				name[i++] = ' ';
				name[i++] = '.';
				name[i++] = '.';
				name[i++] = '.';
				name[i] = 0;
			}
			else
			{
				for (i = 0; i < L; i++) name[i] = p[i];
				name[i] = 0;
			}
		}
      return name;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//																										                     // 
//    ABSTRACT-SYNTAX-TREE FUNCTIONS														                     

      static uchar numeric[256] = /* numeric[x] gives 1..10 for digits 0..9 */
      {
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      1,  2,  3,  4,  5,  6,  7,  8,  9, 10,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 
      };

      Stack* AST::stack;
      int    AST::stacki;

		char draw_plus [] = "+ ";                     
		char draw_vbar [] = "| ";
		char draw_last [] = "+ ";
		char draw_space[] = "  ";

      int*  AST::counter;
      char  AST::indent[256];

      static int space_before = 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    init_ast                                                                                     

int   calc1_parser::init_ast (int Max_nodes)
{
		max_nodes = Max_nodes;
		if (max_nodes <= 0) 
		{	
			printf  (            "Maximum number of AST nodes cannot be %d.\n", max_nodes);
			fprintf (outputdesc, "Maximum number of AST nodes cannot be %d.\n", max_nodes);
         return (0); // Return error.
		}
		node = new Node[max_nodes]; 
      if (node == NULL)
      {
			printf  (            "Not enough memory available for %d AST nodes.\n", max_nodes);
			fprintf (outputdesc, "Not enough memory available for %d AST nodes.\n", max_nodes);
         return (0); // Return error.
      }
		root           =  0;	// In case of internal error.
      node[0].id     = -1; // Undefined.
      node[0].prod   =  0;          
      node[0].sti    =  0;          
      node[0].line   =  0;								
      node[0].next   =  0;          
      node[0].prev   =  0;							   
      node[0].child  =  0;          
      node[0].parent =  0;							   
      n_nodes        =  1;  
		return (1); // Return OK.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    term_ast                                                                                     

void  calc1_parser::term_ast ()
{
		delete [] node;
      delete [] stack;
      delete [] counter;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    print_ast ()                                                                                 

void  calc1_parser::print_ast ()
{
		if (n_nodes > 1)
			print_ast (root);
		else
			fprintf (outputdesc, "AST is empty.\n\n");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    print_ast (n)                                                                                

void  calc1_parser::print_ast (int n) // Print subtree.
{
		if (n < n_nodes && n > 0)
		{
	      char indent [512];
			strcpy (indent, draw_space);
			fprintf (outputdesc, "Abstract Syntax Tree ...\n\n");
			fprintf (outputdesc, "  node  prev  next parent child  line   sti \n");

			traverse (indent, n); // Start AST traversal.    
			fprintf (outputdesc, "\n");
		}
		else 
      {
         fprintf (outputdesc, "Internal error, node %d is not in AST.\n\n", n);
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse                                                                                     

void  calc1_parser::traverse (char *indent, int n)
{
      while (node[n].next > 0)                
      {
         strcat (indent, draw_plus); 
         print_node (indent, n);                
         indent [strlen(indent)-2] = 0;
         if (node[n].child > 0)                
         {
            strcat (indent, draw_vbar);
            traverse (indent, node[n].child);  
            indent [strlen(indent)-2] = 0;
         }
         n = node[n].next;                    
      }

      strcat (indent, draw_last); 
      print_node (indent, n);                   
      indent [strlen(indent)-2] = 0;
      if (node[n].child > 0)                   
      {
         strcat (indent, draw_space); 
         traverse (indent, node[n].child);     
         indent [strlen(indent)-2] = 0;
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    print_node                                                                                   

void  calc1_parser::print_node (char *indent, int n)  /* Print this node function. */
{
      int i;
      int sti;
      sti = node[n].sti;
		fprintf (outputdesc, " %5d %5d %5d %6d %5d %5d %5d %s%s",
			n, 
  			node[n].prev, 
  			node[n].next, 
  			node[n].parent, 
  			node[n].child, 
		  	node[n].line, 
			sti, 
			indent, 
			node_name[node[n].id]);

		if (sti != 0) // zero means no symbol.
		{
			char* q;
			int L;
			char string[100]; 
			if (sti > 0) // a symbol found in the input file?
			{
				q = symbol[sti].name;
				L = symbol[sti].length;
			}
			else // a terminal symbol of the grammar!
			{	
				q = term_symb[-sti];
				L = strlen(q);
			}
			if (L > 99) L = 99;
			for (i = 0; i < L; i++, q++) // Replace '\n' with \1
			{
				if (*q == '\n') string[i] =  1; // one = happy face.
				else            string[i] = *q;
			}
			string[i] = 0;
		//	fprintf (outputdesc, " (%s,%s,%d)", string, term_symb [symbol[sti].term], symbol[sti].type);
			fprintf (outputdesc, " (%s)", string);
		}
		fprintf (outputdesc, "\n");
}

static char spaces[100];

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    traverse                                                                                     

void  calc1_parser::traverse ()
{
	  	if (n_nodes > 1) // Any nodes in the tree? 
		{
		  	if (n_nodeactns > 0) // Any AST actions?
			{
				int i;
				stacki  = -1;
				stack   = new Stack [STKSIZE];	 
				counter = new int [n_nodenames];
				for (i = 0; i < n_nodenames; i++) 
				{
					counter[i] = 0;
				}
				fprintf (outputdesc, "Output ...\n\n");
  				traverse (root);	// Start AST traversal.
				printf  (            "\n");
				fprintf (outputdesc, "\n");
			}
		}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse (n)                                                                                 

void  calc1_parser::traverse (int n)
{
		int   c, i, p, na;
		i = node[n].id;
		p = node[n].prod;
      counter[i]++;
      stacki++;
      stack[stacki].id = i;
      stack[stacki].counter = counter[i]; 
		na = nact_numb[p];
		if (na >= 0) 
		{
			status = TOP_DOWN;
			(*nact_func[na]) (n);	
		}
    	c = node[n].child;                
      while (c > 0)
		{
    	   traverse (c); 
			if (c = node[c].next)          
			{
				if (na >= 0) 
				{
					status = PASS_OVER;
					(*nact_func[na]) (n);	
				}
         }  
		}  
		if (na >= 0) 
		{
			status = BOTTOM_UP;
			(*nact_func[na]) (n);	
		}
      stacki--;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    emitstr
  
int   calc1_parser::emitstr (int n, char* str) 
{
      int   sti;
      int   i, x;
      char  string[1000];
      char  *symb, *s, *p;

   // Get symbol from node.
      sti  = node[n].sti;
		if (sti < 0) 
			symb = term_symb[-sti];
      else         
			symb = symbol_name(sti); 

   // Scan string for &-codes ... 
      p = str; 
      s = string;
      while (1) 
      {
         *s = *p;
         if (*s == 0) 
         {
				fprintf (outputdesc, string, symb);
            return (0);
         }
         if (*s == '&') // &-code ?
         {
            if (numeric[*++p]) // number ?
            {
               x = *p - '0';
               while (numeric[*++p]) x = 10*x + *p - '0';
               i = stacki - x;
               if (i < 0) *s++ = '?'; // Error. 
               else
               {
                  switch (*p)
                  {
                     case 'c': 
							s += sprintf (s, "%d", stack[i].counter); // Get counter.
                     p++;
                     break;

                  // case 'n': 
						//	s += sprintf (s, "%s", node_name[stack[i].id]); // Get node name.
                  // p++;
                  // break;

                     default:  
							s += sprintf (s, "%d", stack[i].counter); // Get counter.
                     break;
                  }
               }
            }
            else s++;
         }
         else { s++; p++; }
      }
		return (0);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 

void	calc1_parser::prt_line () // Print current line being parsed.
{
      char* ls = token.start;
      char* le = token.end;
      while (*ls != '\n' && *ls != 0) ls--;
      if (*ls == 0) // Already printed this one?
		{
         return;
		}
      *ls = 0;
      ls++;
      while (*le != '\n') le++;
      *le = 0;
		if (*ls != 26) // EOF?
		{
			printf  (            "%6d  %s\n", linenumb, ls);
			fprintf (outputdesc, "%6d  %s\n", linenumb, ls);
		}
		else
		{
	      printf  (            "\n");
		   fprintf (outputdesc, "\n");
		}
      *le = '\n';
}

//                                                                                                 // 
/////////////////////////////////////////////////////////////////////////////////////////////////////

