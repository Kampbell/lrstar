
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//    LRSTAR Parser Tables.

/*    Generated by: LRSTAR 6.3.006
      Grammar:      ielr.grm																									    
      Skeleton:     ..\..\skl\parser.cpp.skl
      Output:       ielr_parser.cpp
*/               
		#include "string.h"
  		#include "ielr_parser.h"
  		#include "ielr_actions.h"   

		#define ACCEPT_STATE	     9 // Final state.

/*--- Constants. -------------------------------------------------------------*/
                                                                                          
      int ielr_parser::n_terms      =     5; // No. of terminals.                               
      int ielr_parser::n_heads      =     4; // No. of non-terminals.     
      int ielr_parser::n_prods      =     7; // No. of productions.       
      int ielr_parser::n_states     =    10; // No. of states.
      int ielr_parser::eol_symb     =     0; // EOL symbol number            
      int ielr_parser::eof_symb     =     2; // EOF symbol number            
      int ielr_parser::err_used     =     0; // <error> used in grammar      
      int ielr_parser::n_nodenames  =     0; // No. of node names.   
      int ielr_parser::n_nodeactns  =     0; // No. of node actions.   

/*--- Terminal and Nonterminal Symbols of the Grammar. -----------------------*/

   // Terminal symbols of the grammar. 
      char* ielr_parser::term_symb[5] = 
      {
         "<error>",
         "\'a\'",
         "<eof>",
         "\';\'",
         "\'b\'"
      };                                                 

   // Head symbols of the grammar. 
      char* ielr_parser::head_symb[4] = 
      {
         "G",
         "S",
         "A",
         "S..."
      };
  
   // Head symbol for a production 
      uchar ielr_parser::head_numb[7] = 
      {
          0,    1,    1,    2,    2,    3,    3
      };

   // Index to first tail symbol for a production 
      uchar ielr_parser::f_tail[8] = 
      {
          0,    2,    6,   10,   11,   13,   14,   16
      };

   // Tail symbol numbers (T: >= 0, NT: < 0)
      char ielr_parser::tail[16] = 
      {
         -3,    2,    1,   -2,    1,    3,    4,   -2,    4,    3,    1,    1,    1,   -1,   -3,   -1
      };

/*--- Bit Matrix and Access Vectors. -----------------------------------------*/

   // B_matrix.  
      uchar ielr_parser::Bm [6] = 
      {
          0,   18,   22,    2,   16,    8
      };

   // B_matrix row. 
      uchar ielr_parser::Br [10] = 
      {
          1,    2,    3,    3,    3,    0,    4,    5,    5,    0
      };

   // B_matrix column.
      uchar ielr_parser::Bc [5] = 
      {
          0,    0,    0,    0,    0
      };
  
	// B_matrix column.
      uchar ielr_parser::Bmask [5] = 
      {
          1,    2,    4,    8,   16
      };
  
/*--- Terminal Transition Matrix and Access Vectors. -------------------------*/

   // T_matrix. 
      char ielr_parser::Tm [9] = 
      {
          7,    5,    0,   -2,    8,    2,    9,   -1,    3
      };

   // T_matrix row. 
      uchar ielr_parser::Tr [10] = 
      {
          5,    5,    1,    1,    0,    5,    1,    5,    1,    5
      };

   // T_matrix column. 
      uchar ielr_parser::Tc [5] = 
      {
          0,    0,    1,    2,    3
      };

/*--- Nonterminal Transition Matrix and Access Vectors. ----------------------*/

   // N_matrix. 
      char ielr_parser::Nm [5] = 
      {
         -6,    6,   -5,    4,    1
      };

   // N_matrix row. 
      uchar ielr_parser::Nr [10] = 
      {
          2,    0,    2,    0,    2,    2,    2,    2,    2,    2
      };

   // N_matrix column. 
      uchar ielr_parser::Nc [7] = 
      {
          0,    0,    0,    1,    1,    2,    2
      };

/*--- Reduction Matrix and Access Vectors. -----------------------------------*/

   // R_matrix. 
      uchar ielr_parser::Rm [3] = 
      {
          0,    0,    3
      };

   // R_matrix row. 
      char ielr_parser::Rr [10] = 
      {
          0,    0,    0,    0,    0,   -1,    0,    0,    0,    0
      };

   // R_matrix column. 
      uchar ielr_parser::Rc [5] = 
      {
          0,    0,    0,    0,    1
      };

/*--- Nondeterministic Parsing Arrays. ---------------------------------------*/

   // Nondeterministic Start. 
      uchar ielr_parser::nd_start [11] = 
      {
          0,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2
      };

   // Nondeterministic Terminal Symbol. 
      uchar ielr_parser::nd_term [2] = 
      {
          1,    1
      };

   // Nondeterministic Action.
      char ielr_parser::nd_action [2] = 
      {
         13,   -3
      };

/*--- Production Variables. --------------------------------------------------*/

   // Production length - 1 
      char ielr_parser::PL[7] = 
      {
          1,    3,    3,    0,    1,    0,    1
      };

   // Reverse the order of nodes (for a production/rule).
      uchar ielr_parser::reverse[7] = 
      {
          0,    0,    0,    0,    0,    0,    0
      };

/*--- Token Action Variables -------------------------------------------------*/

	// Token Action number. 
      char ielr_parser::tact_numb[5] = 
      {
         -1,   -1,   -1,   -1,   -1
      };

   // Token Action Function Pointers.	
      int (*ielr_parser::tact_func[1]) (int&) = 
      {
			0
      };

		// First argument index for token actions.
      char ielr_parser::tact_arg[1] = 
      {
         0
      };

/*--- Parser Action Variables ------------------------------------------------*/

   // Parser Action Number
      char ielr_parser::pact_numb[7] = 
      {
         -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

   // Parser Action Function Pointers	
      int (*ielr_parser::pact_func[1]) (int) = 
      {
			0
      };

	// Parser Action Argument Index and first argument for make_node.
      char ielr_parser::pact_arg[1] = 
      {
          0
      };

/*--- Make-Node Variables ----------------------------------------------------*/

   // Make-Node Numbers (for a production).
      char ielr_parser::node_numb[7] = 
      {
         -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

   // Node Names.
      char* ielr_parser::node_name[1] = 
      {
         ""
      };

/*--- Node-Action Variables --------------------------------------------------*/

   // Node-Action Numbers. 
      char ielr_parser::nact_numb[7] = 
      {
         -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

	// Node-Action Function Pointers.
      int (*ielr_parser::nact_func[1]) (int n) = 
      {
			0
      };   

   // Node Action Argument Index
      char ielr_parser::nact_arg[1] = 
      {
         0
      };

/*--- Argument Numbers. ------------------------------------------------------*/

   // Parse action argument numbers 
      uchar ielr_parser::arg_numb[1] = 
      {
          0
      };

   // Text for string arguments. 
      char* ielr_parser::arg_text[1] = 
      {
         ""
      };


/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    LRSTAR Parser.

		#include "string.h"

		#define STKSIZE    1000 // Parser stack size.    
		#ifndef LOOKAHEADS
		#define LOOKAHEADS 3		// Number of lookaheads for LR(*) parsing.
		#endif

		#ifndef UINT_MAX
	  	#define UINT_MAX 0xffffffff 					// for 32-bit CPUs.			
	// #define UINT_MAX 0xffffffffffffffff 		// for 64-bit CPUs.			
		#endif

	// Parser stuff ...
		PStack*  ielr_parser::PS;                  
		PStack*  ielr_parser::PS_end;                  
      PStack   ielr_parser::P_stack[STKSIZE];   
		int      ielr_parser::n_errors;
		int      ielr_parser::max_errs;
		int      ielr_parser::status;
		char*		ielr_parser::inputname;
		FILE*		ielr_parser::outputdesc;

	// Restore stack stuff ...
      RStack*	ielr_parser::RS; 
      RStack	ielr_parser::R_stack[STKSIZE]; 
  		PStack*  ielr_parser::PStop;
  		int      ielr_parser::topstate;

	// Symbol table stuff ...
      Symbol*  Symtab::symbol;
		int      Symtab::cell;
		int      Symtab::sti;
		int      Symtab::length;
		int      Symtab::n_symbols;
		int      Symtab::n_keywords;
		uint     Symtab::hashdiv;
		int*		Symtab::hashvec;
		int		Symtab::max_cells;
		int		Symtab::max_symbols;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    ielr_parser -  initialization																  

int   ielr_parser::init (char* Inputname, FILE* Outputdesc, int max_symb, int max_node)
{
		inputname  = Inputname;										// Move name into parser object.
		outputdesc = Outputdesc;									// Move desc into parser object.

		if (!init_symtab (max_symb)) return (0);           // Initialize the symbol table.
		token.start = "";                                  // Make a blank symbol.
		token.end   = token.start + 1;
		add_symbol (0, token.start, token.end);				// Add it to the symbol table.

      n_errors = 0;							                  // Set number of errors.    
      max_errs = 10;							                  // Set max number of errors.
		return (1); // Return OK.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    ielr_parser -  termination

void  ielr_parser::term ()
{
		print_symtab (term_symb);			                  // Print the symbol table contents.
		term_symtab ();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		Minimal LR Parser

int   ielr_parser::parse (char* input_start)                
{
      int p;                                          	// Production (rule) number.  
      int t;                                          	// Terminal symbol number. 
      int x = 0;                                      	// State number.  

      PStack *P;														// Expecting option stack.
      int    *SS, *SS_end;											  
      int    S_stack[STKSIZE];
      int    max_nla, nla, action;
      SS_end = S_stack + STKSIZE;
		lexer_init (input_start);									// Initialize lexer.
      PS_end = P_stack + STKSIZE;			            	// Set parse-stack end pointer.   
      PS     = P_stack;							            	// Set parse-stack pointer.   

Read:	t = get_token ();												// Get incoming token.
		prt_line ();
		token.sti = -t;												// Symbol-table index = -t.
      if (tact_numb[t] >= 0)					            	// If token action ...         
      {
         token.sti = (*tact_func [tact_numb[t]])(t);  	// Call token-action function.
      }
Shft: if (Bm [Br[x] + Bc[t]] & Bmask[t])	            	// Check B-matrix for shift action. 
      {
			if (++PS >= PS_end) goto Over;						// Check for stack overflow.
         PS->state = x;                               	// Put current state on stack.  
         x = Tm [Tr[x] + Tc[t]];                      	// Get next state from terminal transition matrix.
         while (x <= 0)                               	// While shift-reduce actions. 
         {
SRed:			p = -x;													// Reduce stack by production p.	
            PS -= PL[p];											// Reduce stack ptr by production length. 
            x = Nm [Nr[PS->state] + Nc[p]];					// Get next state from nonterminal transition.
         }
         goto Read;								               // Go to read next token.
      }
		if ((p = Rr[x]) > 0 || (p = Rm [Rc[t] - p]) > 0)   // Get reduction?
      {
Red:		PS -= PL[p];												// Reduce parse stack ptr by rule length - 1. 
         if (PL[p] < 0)							               // Null production?
         {	
				if (PS >= PS_end) goto Over;						// Check for overflow.
            PS->state = x;						               // Stack current state, replacing old state.
         }
         while (1) 
         {
            x = Nm [Nr[PS->state] + Nc[p]];	            // Get next state from nonterminal transition.
            if (x > 0) goto Shft;                        // Continue parsing.
            p = -x;								               // Set production number.
            PS -= PL[p];                                 // Reduce parse stack ptr by rule length - 1. 
         }
		}
      max_nla = 0;
		for (int i = nd_start[x]; i < nd_start[x+1]; i++)
		{
         if (nd_term[i] == t) 
			{
            for (SS = S_stack, P = P_stack; P < PS;) *++SS = (++P)->state;
            nla = nd_parse (S_stack, SS, SS_end, x, t, nd_action[i]);
            if (nla > max_nla)
            {
               max_nla = nla;
               action = nd_action[i];
            }
         }
         else if (nd_term[i] > t) break;						// nd_term is sorted, so we are done.
		}
      if (max_nla > 0)
      {
         if (action > 0)                                 // Shift and Goto?
         {
      	   if (++PS >= PS_end) goto Over;					// Check for overflow.
            PS->state = x;                               // Put current state on stack.   
            if (action > ACCEPT_STATE)                   // Shift and reduce?
            {
               x = ACCEPT_STATE - action;						// Convert to production #
               goto SRed;                                // Shift-Reduce.
            }
            x = action;                                  // Get next state.
            goto Read;												// Get next token.
         }
         else															// Reduce!
         {
            p = -action;                                 // Get production.
            goto Red;                                    // Reduce.
         }
      }
      if (x == ACCEPT_STATE)					               // If Goal production.  
      {
         PS -= PL[0];                                    // Reduce parse stack ptr by rule length - 1. 
         if (linenumb > 0) linenumb = --linenumb;			// Reduce line number by one.
			return linenumb;						               // Return number of lines parsed.
      }

		prt_error (term_symb[t]);				               // Print syntax error message. 
		return -linenumb;							               // Return negative number of lines for failure. 

Over: printf  ("\nParser stack overflow.\n\n");
		return -linenumb;							               // Return negative number of lines for failure. 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		nd_parse - nondeterministic parse

int   ielr_parser::nd_parse (int* P_stack, int* PS, int* PS_end, int x, int t, int action)
{
      int   p, lookaheads;
      char* TS = token.start;
      char* TE = token.end;
      int   LN = linenumb;

      int   *P;
      int   max_nla, nla;
      int   *SS, *SS_end;
      int   S_stack[STKSIZE];
      SS_end  = S_stack + STKSIZE;
      lookaheads = 0;
		goto Act;

Read:	t = get_token ();												// Get first token. 
      if (tact_numb[t] >= 0)					               // Need this if-statement for typedef names.         
      {
         (*tact_func [tact_numb[t]])(t);						// Call token-action function, maybe change t.
      }
Shft: if (Bm [Br[x] + Bc[t]] & Bmask[t])	               // Check B-matrix for shift action. 
      {
      	if (++PS >= PS_end) goto Over;
         if (++lookaheads == LOOKAHEADS) goto Ret;

         *PS = x;                                        // Put current state on stack.   
         x = Tm [Tr[x] + Tc[t]];                         // Get next state from terminal transition matrix.
         while (x < 0)                                   // While shift-reduce actions. 
         {
SRed:       PS -= PL[-x];                                // Reduce stack ptr by production length. 
            x = Nm [Nr[*PS] + Nc[-x]];	                  // Get next state from nonterminal transition matrix.
         }
         goto Read;								               // Go to read next token.
      }
		if ((p = Rr[x]) > 0 || (p = Rm [Rc[t] - p]) > 0)   // Get reduction?
      {
Red:		PS -= PL[p];												// Reduce parse stack ptr by rule length - 1. 
         if (PL[p] < 0)							               // Null production?
         {	
				if (PS >= PS_end) goto Over;						// Check for stack overflow.
            *PS = x;						                     // Stack current state, replacing old state.
         }
         while (1) 
         {
   		   x = Nm [Nr[*PS] + Nc[p]];	                  // Get next state from nonterminal transition.
            if (x > 0) goto Shft;			               // If a state, continue parsing.
            p = -x;								               // Make the production number positive.
            PS -= PL[p];                                 // Reduce parse stack ptr by rule length - 1. 
         }
      }
      max_nla = 0;
		for (int i = nd_start[x]; i < nd_start[x+1]; i++)
		{
         if (nd_term[i] == t) 
         {
            for (SS = S_stack, P = P_stack; P < PS;) *++SS = *++P;
            nla = nd_parse (S_stack, SS, SS_end, x, t, nd_action[i]);
            if (nla > max_nla)
            {
               max_nla = nla;
               action = nd_action[i];
            }
         }
         else if (nd_term[i] > t) break;						// nd_term is sorted, so we are done.
		}
      if (max_nla > 0)
		{
Act:		if (action > 0)                                 // Shift and Goto?
			{
      		if (++PS >= PS_end) goto Over;
				if (++lookaheads == LOOKAHEADS) goto Ret;
				*PS = x;                                     // Put current state on stack.   
				if (action > ACCEPT_STATE)                   // Shift and reduce?
				{
					x = ACCEPT_STATE - action;						// Convert to production #
					goto SRed;                                // Shift-Reduce.
				}
				x = action;                                  // Get next state.
				goto Read;												// Get next token.
			}
			else															// Reduce!
			{
				p = -action;                                 // Get production.
				goto Red;												// Reduce.
			}
		}
      if (x == ACCEPT_STATE)					               // If Goal production.  
      {
         lookaheads = LOOKAHEADS;
      }

Ret:  token.start = TS; 
      token.end   = TE;
      linenumb    = LN;
      return lookaheads;                                 // Syntax error, return zero lookaheads.

Over: printf  ("\nParser stack overflow.\n\n");
		return 0; // Return error.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    prt_error	

void  ielr_parser::prt_error (char *symb)
{       
      int  i, col, ln1, ln2;
      char string[256], *ls1, *ls2, *le1, *le2, *p, c;

	// Get first line number ...
      ln1 = linenumb;
		for (p = token.end-1; p > token.start; p--)
		{
			if (*p == '\n' || *p == 0) ln1--;
		}

	// Get first line start ...
		for (ls1 = token.start; *ls1 != '\n' && *ls1 != 0; ls1--); 
		ls1++;

	// Get first line end ...
		for (le1 = token.start; *le1 != '\n' && *le1 != 0; le1++);

	// Get last line number ...
      ln2 = linenumb;

	// Get last line start ...
		for (ls2 = token.end-1; *ls2 != '\n' && *ls2 != 0; ls2--); 
		ls2++;

	// Get last line end ...
		for (le2 = token.end; *le2 != '\n' && *le2 != 0; le2++);
		*le1 = 0;
		*le2 = 0;

		if (*token.start == '\n' || *token.start == 0) ln1--;

		printf  (            "\n%s(%d) : Error  %s\n", inputname, ln1, ls1);
		fprintf (outputdesc, "\n%s(%d) : Error  %s\n", inputname, ln1, ls1);
      *le1 = '\n'; // In case token is this <eol>

      col = 1;
      for (p = ls1; p < token.start; p++)   
      {
         if (*p == '\t') *p = ' ';
         col++;
      }
      for (i = 0; i < col; i++) string[i] = '-';
      string [col] = 0;
		printf  (            "%s(%d) : Error %s^ ", inputname, ln1, string);
		fprintf (outputdesc, "%s(%d) : Error %s^ ", inputname, ln1, string);

      if (*token.start <= 32) 
      {
         int x = *token.start;
         if (x < 0) x += 256;
         printf  (            "at \\%d %s\n\n", x, symb);
         fprintf (outputdesc, "at \\%d %s\n\n", x, symb);
      }
      else
      {
         if (token.end == token.start) token.end++;
         if (token.end > le1) 
         {
				if (*token.start == '\n') *token.start = 0;
            if (*token.end   == EOF_CHAR) linenumb--;
            c = *le1; 
            *le1 = 0;
            printf  (            "starts here\n");
            fprintf (outputdesc, "starts here\n");
				printf  (            "\n%s(%d) : Error  %s\n", inputname, ln2, ls2);
				fprintf (outputdesc, "\n%s(%d) : Error  %s\n", inputname, ln2, ls2);
				col = 1;
				for (p = ls2; p < token.end; p++)   
				{
					if (*p == '\t') *p = ' ';
					col++;
				}
				for (i = 0; i < col; i++) string[i] = '-';
				string [col] = 0;
				printf  (            "%s(%d) : Error %s^ ", inputname, ln2, string);
				fprintf (outputdesc, "%s(%d) : Error %s^ ", inputname, ln2, string);
				printf  (            "ends here.\n\n");
				fprintf (outputdesc, "ends here.\n\n");
            *le1 = c;
         }
         else
         {
            c = *token.end; 
            *token.end = 0;
				if (*token.start == '\n') *token.start = 0;
            printf  (            "at %s %s\n\n", token.start, symb);
            fprintf (outputdesc, "at %s %s\n\n", token.start, symb);
            *token.end = c;
         }
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		expecting // Print expecting list. 

void  ielr_parser::expecting (int state)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		collect: Collect terminals that cause a transition or reduction.			                     

void	ielr_parser::collect (int x) 
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    prt_prod                                                                                     

void	ielr_parser::prt_prod (int p)
{
		printf  (            "         reduce    %6d %s <- ", p, head_symb [head_numb[p]]);
		fprintf (outputdesc, "         reduce    %6d %s <- ", p, head_symb [head_numb[p]]);
		int i;
		int first = f_tail[p];
		int next_first = f_tail[p+1];
		for (i = first; i < next_first; i++)
		{
			char* symb;
			int   s = tail[i];
			if (s >= 0) symb = term_symb[ s];
			else        symb = head_symb[-s];
			printf  (            "%s ", symb);
			fprintf (outputdesc, "%s ", symb);
		}
		printf  (            "\n");
		fprintf (outputdesc, "\n");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    init_symtab

int   ielr_parser::init_symtab (int max_symb) 
{
      int i; 
		if (max_symb <= 0) 
		{	
			printf  (            "Maximum number of symbols cannot be zero or negative.\n");
			fprintf (outputdesc, "Maximum number of symbols cannot be zero or negative.\n");
			return (0);
		}
		max_symbols   = max_symb;
		max_cells     = 2*max_symbols;
		symbol        = new Symbol[max_symbols];
      hashvec       = new int[max_cells];
      hashdiv       = UINT_MAX / max_cells + 1;
      n_symbols	  = 0;
      n_keywords	  = 0;
      if (symbol == NULL || hashvec == NULL)
      {
			printf  (            "Not enough memory available for Symbol Table.\n");
			fprintf (outputdesc, "Not enough memory available for Symbol Table.\n");
         return (0); // Return error.
      }
      for (i = 0; i < max_cells; i++) 
		{
			hashvec[i] = -1;
		}
		return (1); // Return OK.
}
													        
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    term_symtab

void  ielr_parser::term_symtab () 
{
      delete [] symbol;
      delete [] hashvec;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    add_symb - add symbol to table.     											                        

int	ielr_parser::add_symbol (int t, char* token_start, char* token_end) 
{
		sti = get_symbol (token_start, token_end);
		if (sti < 0) 
		{
			sti = n_symbols;
			if (n_symbols >= max_symbols)				// Reached maximum number? 
			{
				printf  (            "Number of symbols exceeds %d.\n", max_symbols);
				fprintf (outputdesc, "Number of symbols exceeds %d.\n", max_symbols);
				return (0); // Return error.
			}
			hashvec[cell] = n_symbols;					// Put symbol number into hash vector.     
			symbol[n_symbols].name = token_start;	// Define pointer to symbol name.
			symbol[n_symbols].length = length;		//	Define symbol name length.
			symbol[n_symbols].term = t;				// Define terminal number (<identifier>, <string>, <number>, ...)
			symbol[n_symbols].type = 0;				// Define type as undefined (zero).
			symbol[n_symbols].cell = cell;			// Define hash vector cell number for this symbol.
			n_symbols++;									// Increment number of symbols.
		}
      return (sti);										// Return symbol-table index.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    get_symbol - get symbol number from table.									                        

int   ielr_parser::get_symbol (char* token_start, char* token_end) 
{
      char* p = token_start;					 		// Point at start.
      length  = token_end - token_start;  		// Set length. 
      uint hash = length;         	   			// Set hash to length. 
      int i = 0;						   				// Set shift value to 0.
      do									      			// Assume length != 0
      {
         hash += *p << i;
         i += 4;		                  			
         i %= 32;
      }
      while (++p < token_end);
      cell = hash % max_cells; 						// Get first cell.
		i = hashvec [cell];				   			// Get symbol index.
      if (i >= 0) 
		{
			p = token_start;						   	// Point at token start.
			do
			{
				if (symbol[i].length == length)		// If lengths are equal ...
				{
					char* q = symbol[i].name;			// Point at symbol name.
					int j = 0; 
					do 
					{
						if (p[j] != q[j]) goto Cont;	// If characters not equal ...		
					}
					while (++j < length);				// while end not reached. 
					return (i);								// Found it.
				}
	Cont:    cell = (hash *= 65549)/hashdiv;		// Get new cell number.
				i = hashvec [cell];						// Get symbol index.
			}
			while (i >= 0);      						// While not empty slot.
		}
      return (i);											// Return symbol number.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    print - print symbol table contents.     										                        

void  ielr_parser::print_symtab (char* term_symb[])
{
		if (n_symbols > 1)
		{
			fprintf (outputdesc, "Symbol Table ...\n\n");
			fprintf (outputdesc, "  sti  leng  type  term  \n");

			for (int i = 1; i < n_symbols; i++)
			{
				fprintf (outputdesc, "%5d %5d %5d %5d   %-30s  %s\n",
					i,
					symbol[i].length,
					symbol[i].type,
					symbol[i].term, 
					term_symb[symbol[i].term],
					symbol_name(i)); 
			}   
			fprintf (outputdesc, "\n");
		}
		else
		{
			fprintf (outputdesc, "Symbol Table is empty!\n\n");
		}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    symname - get symbol name. 

char* ielr_parser::symbol_name (int i)
{
      char* p;
      int L;
      static char name[100];
		if (i == 0) 
		{
			name[0] = 0;
		}
		else
		{
			p = symbol[i].name;
			L = symbol[i].length;
			if (L >= 100) 
			{
				L = 95;
				for (i = 0; i < L; i++) name[i] = p[i];
				name[i++] = ' ';
				name[i++] = '.';
				name[i++] = '.';
				name[i++] = '.';
				name[i] = 0;
			}
			else
			{
				for (i = 0; i < L; i++) name[i] = p[i];
				name[i] = 0;
			}
		}
      return name;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 

void	ielr_parser::prt_line () // Print current line being parsed.
{
      char* ls = token.start;
      char* le = token.end;
      while (*ls != '\n' && *ls != 0) ls--;
      if (*ls == 0) // Already printed this one?
		{
         return;
		}
      *ls = 0;
      ls++;
      while (*le != '\n') le++;
      *le = 0;
		if (*ls != 26) // EOF?
		{
			printf  (            "%6d  %s\n", linenumb, ls);
			fprintf (outputdesc, "%6d  %s\n", linenumb, ls);
		}
		else
		{
	      printf  (            "\n");
		   fprintf (outputdesc, "\n");
		}
      *le = '\n';
}

//                                                                                                 // 
/////////////////////////////////////////////////////////////////////////////////////////////////////

