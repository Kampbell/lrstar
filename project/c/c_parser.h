
#ifndef c_parser_h
#define c_parser_h

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    PARSER.H

/*    Generated by: LRSTAR 6.3.006
      Grammar:      c.grm
      Skeleton:     ..\..\skl\parser.h.skl
      Output:       c_parser.h
*/               
		#include "stdio.h"
		#include "c_lexer.h"

		#define uint unsigned int

		#ifndef UINT_MAX
	  	#define UINT_MAX 0xffffffff 					// for 32-bit CPUs.			
	// #define UINT_MAX 0xffffffffffffffff 		// for 64-bit CPUs.			
		#endif
		#define EOF_CHAR  26 // End Of File character.  

   // Defined constants for the node names (uppercase) ...
		enum node_name
      {
         GOAL_                = 0,
         EXTDEF_              = 1,
         TYPEDEF_DECL_        = 2,
         EXTDECL_             = 3,
         DECL_                = 4,
         FUNCDEF_             = 5,
         FUNCDECL_            = 6,
         FUNCBODY_            = 7,
         TYPE_                = 8,
         CLASS_               = 9,
         DECLARATOR_          = 10,
         DECLARATORINIT_      = 11,
         STRUCT_              = 12,
         UNION_               = 13,
         STRUCTDECL_          = 14,
         STRUCTDECLARATOR_    = 15,
         ENUMSPEC_            = 16,
         ENUMIDENT_           = 17,
         ENUMEQUALS_          = 18,
         DIRECTDECL_          = 19,
         IDENT_               = 20,
         ARRAYDECL_           = 21,
         POINTER_             = 22,
         ARGDECL_             = 23,
         ABSARGDECL_          = 24,
         ABSARG_              = 25,
         TYPESPEC_            = 26,
         ABSDECLARATOR_       = 27,
         CONSTEXP_            = 28,
         ABSARRAY_            = 29,
         ABSFUNC_             = 30,
         ASSIGN_              = 31,
         INIT_                = 32,
         EMPTY_               = 33,
         EXP_                 = 34,
         GOTO_                = 35,
         CONTINUE_            = 36,
         BREAK_               = 37,
         RETURN_              = 38,
         LABELEDSTMT_         = 39,
         BLOCK_               = 40,
         IF_                  = 41,
         IFELSE_              = 42,
         SWITCH_              = 43,
         WHILE_               = 44,
         DO_                  = 45,
         FOR_                 = 46,
         CASE_                = 47,
         DEFAULT_             = 48,
         EXP1_                = 49,
         EXP2_                = 50,
         EXP3_                = 51,
         LABEL_               = 52,
         CONDEXP_             = 53,
         ASSIGNMENT_          = 54,
         COMMA_               = 55,
         EQUALS_              = 56,
         MULEQ_               = 57,
         DIVEQ_               = 58,
         MODEQ_               = 59,
         ADDEQ_               = 60,
         SUBEQ_               = 61,
         SHLEQ_               = 62,
         SHREQ_               = 63,
         ANDEQ_               = 64,
         XOREQ_               = 65,
         OREQ_                = 66,
         QUESTION_            = 67,
         OR_                  = 68,
         AND_                 = 69,
         BITOR_               = 70,
         BITXOR_              = 71,
         BITAND_              = 72,
         EQ_                  = 73,
         NE_                  = 74,
         LT_                  = 75,
         GT_                  = 76,
         LE_                  = 77,
         GE_                  = 78,
         SHL_                 = 79,
         SHR_                 = 80,
         ADD_                 = 81,
         SUB_                 = 82,
         MUL_                 = 83,
         DIV_                 = 84,
         MOD_                 = 85,
         CAST_                = 86,
         PREINC_              = 87,
         PREDEC_              = 88,
         COMPLEMENT_          = 89,
         ADDRESSOF_           = 90,
         CONTENTSOF_          = 91,
         POSITIVE_            = 92,
         NEGATIVE_            = 93,
         NOT_                 = 94,
         SIZEOF_              = 95,
         ARRAY_               = 96,
         MEMBER_              = 97,
         FUNCCALL_            = 98,
         PTRTO_               = 99,
         POSTINC_             = 100,
         POSTDEC_             = 101,
         SUBSCRIPT_           = 102,
         ARGUMENTS_           = 103,
         STRING_              = 104,
         CONST_               = 105,
         IDENTIFIER_          = 106,
         TYPEDEFIDENTIFIER_   = 107
      };

		class Symbol             
		{
		public:
			char*  name;	 // Pointer to symbol name.														4		
			int    length;	 // Length  of symbol name.														4
			int    level;	 // Level number for scope.                                        	4
			int    term;	 // Terminal number (e.g. <identifier>, <string>, {typedef}, ...)		4
         uint   type;	 // Type (e.g. integer, float, double, char, ...)							4
			int    cell;	 // Hash vector cell number for deleting this symbol.						4  24 bytes
		};

		class Symtab 
		{
		public:
			static Symbol*  symbol;			// Symbols.
			static int      n_symbols;		// Number of symbols.
			static int      n_keywords;	// Number of keywords in symbol table.
			static int      length;			// Current length of symbol name.
			static int      cell;			// Current hash cell number.
			static int      sti;				// Current symbol-table index.
			static uint     hashdiv;		// Hash divisor. 
			static int*     hashvec;		// Hash vector.
			static int      max_symbols;	// Maximum number of symbols.
			static int      max_cells;    // Maximum number of cells in the hash vector. 
		};

		class Node                
		{
		public:
			int    id;		 // Node id number    									4	 	
			int    prod;	 // Production number            					4	 	
			int    sti;     // Symbol-table index (perm or temp var).		4	 
			int    prev;	 // Previous node.			   						4  
			int    next;	 // Next node.												4  
			int    line;    // Line number.                                4   
			int    child;   // Child node.                                	4   
			int    parent;  // Parent node.                             	4  32 bytes per node
		}; 
  
      class Stack
      {
         public:
         int    id;      // Node id.                      4	 	
         int    counter; // Counter of node accesses.     4	 8 bytes
      };

		class AST 
		{
			public:	
			static char     indent[256];	// Indentation for printing current node.
         static int*     counter;		// Node counter array.
         static int      stacki;			// AST stack index.
         static Stack*   stack;			// AST stack array.
			static Node*    node;			// AST node array.
			static int      root;			// Root node number.
			static int      n_nodes;		// Number of nodes.
			static int      max_nodes;		// Maximum number of nodes.
		};

	// AST Action Mode. 
      #define TOP_DOWN   0	 // Top down status.  
   	#define PASS_OVER  1  // Pass over status.
   	#define BOTTOM_UP  2  // Bottom up status.  
   
      class PStack // Parser stack.
      {
         public:
         int    state;	 // Parser state.                 4	 4	
         int    sti;     // Symbol table index.           4	 8	
         int    line;    // Input line number.            4	12	
         int    node;    // Node number.                  4	16	
         int    last;    // Last in list number.          4	20	bytes per cell.
			int    sym;     // Symbol stacked, terminal (positive) or nonterminal (negative). 
      };

      class RStack // Restore Stack.
      {
         public:
         PStack* ptr;	 // Parse stack pointer.			4	4	
         int     state;  // State.								4	8	bytes.
      };

      class c_parser : public c_lexer, public Symtab, public AST
		{
		public:

			static int    	init(char*, FILE*, int, int);	// Parser initialization.
			static void   	term();								// Parser termination.

			static int    	parse       (char* input_start);	
			static void   	parse_term  ();	
			static int    	add_symbol  (int, char*, char*);
			static int    	get_symbol  (char*, char*); 
			static int  	emitstr	   (int n, char* str);
			static char*  	symbol_name (int);

			static int     status;					// Status for parser actions and AST actions.
			static char*   inputname;				// Input file name.
			static FILE*   outputdesc;				// Output file desc.
         static PStack* PS;           			// Parse Stack pointer.       
         static PStack* PS_end;         		// Parse Stack end.       
         static int*    SS;           			// State Stack pointer.       
         static int*    SS_end;         		// State Stack end.       

			static char    tact_arg[];		// Token-action argument index (for first arg).
			static char    pact_arg[];		// Parse-action argument index (for first arg).
			static char    nact_arg[];		// Node-action  argument index (for first arg).
			static uchar   arg_numb[];		// Argument numbers. 	
			static char*   arg_text[];		// Argument text (if a string argument or node arg).
			static char*   term_symb[];  // Terminal symbols of the grammar.
			static char*   head_symb[];  // Head (nonterminal) symbols of the grammar.
			static uchar   head_numb[];  // Head symbol number for a production (rule).

		private:

			static char    PL[];			// Production (rule) length less one (zero based).
			static int     n_errors;				// Number of errors.
			static int     max_errs;				// Maximum allowable errors.
			static int     n_terms;					// Number of terminal symbols in grammar.
			static int     n_heads;					// Number of head symbols in grammar.
			static int     n_prods;					// Number of productions (rules) in grammar.
			static int     n_states;				// Number of states in parser state machine.
			static int     eof_symb;				// <eof> symbol number.
			static int     eol_symb;				// <eol> symbol number.
			static int     err_used;				// <error> used in grammar?
                                       		                                   
         static RStack* RS;           			// Reduction Stack pointer.
			static int     n_nodenames;			// Number of node names in grammar.
			static int     n_nodeactns;			// Number of node processors (AST actions).
			static char*   node_name[];			// Node names array.

			static char*   T_list;					// Terminal symbol list (0 or 1).
			static int*    P_list;					// Production list.
         static RStack  R_stack[];				// Reduction stack.
         static PStack  P_stack[];				// Parser stack.
         static int     S_stack[];				// State stack.
			static PStack* PStop;				   // Top pointer for parser stack.
			static int     topstate;				// Top state (before reductions start).

			static char    nact_numb[];  // Node action numbers.
			static char    tact_numb[];  // Token action number. 
			static char    pact_numb[];  // Production action number (for a parser action).
			static char    node_numb[];  // Node number index for a production (rule).

			static uchar   Bm[];			// Boolean matrix (0 or 1).
			static uchar   Br[];			// Boolean matrix row (base).
			static uchar   Bc[];			// Boolean matrix column (displacement).
			static uchar   Bmask[];		// Boolean matrix mask.

			static short   Tm[];			// Terminal transition matrix (gives next state or reduction).
			static ushort  Tr[];			// Terminal transition matrix row (base).
			static uchar   Tc[];			// Terminal transition matrix column (displacement).

			static short   Nm[];			// Nonterminal transition matrix (gives next state or reduction).
			static ushort  Nr[];			// Nonterminal transition matrix row (base).
			static uchar   Nc[];			// Nonterminal transition matrix column (displacement).

			static uchar   Rm[];			// Reduction matrix (gives reduction).
			static short   Rr[];			// Reduction matrix row (base).
			static uchar   Rc[];			// Reduction matrix column (displacement).

			static uchar   reverse[];		// Reverse order of nodes for this production (rule)?
			static ushort  f_tail[];		// First tail symbol for a production.
			static char    tail[];			// Tail symbols for productions.

			static uchar   nd_start[];
			static uchar   nd_term[]; 
			static uchar   nd_action[]; 

		// Parser functions
  		  	static int		(*tact_func[]) (int&);	// Parser action function pointers.
  		  	static int	   (*pact_func[]) (int);		// Parser action function pointers.
			static int	   (*nact_func[]) (int);		// Node action function pointers.

  		  	static char*	tact_name[];					// Parser action name.
  		  	static char*	pact_name[];					// Parser action name.
  		  	static char*	nact_name[];					// Node action names.

			static int		nd_parse			(int*, int*, int*, int x, int t, int a);
			static int		reduce			(int p);
			static int		linkup			(int p);
			static void		rebuild			();                           
			static void		prt_help			();
			static int	   err_rec			(int, int);
			static int	   lookahead		(int t, int x);
			static void		get_list			(int);
			static void		prt_error		(char*);
			static void		prt_prod			(int); 
			static void		prt_stack		(); 
			static void		expecting		(int x); 
			static void		collect			(int x);
			static void		reduce			(int p, int x);
			static void		prt_list			(int t);

		// Symtab functions
			static int		init_symtab		(int);		// Initialize the symbol table.
			static void		term_symtab		();			// Initialize the symbol table.
			static void		print_symtab	(char**);
         static void		prt_line			();

		// AST functions
			static int		init_ast			(int);
			static void		term_ast			();
			static void		print_ast		();
			static void		print_ast		(int n);
			static void		print_node		(char *indent, int n);
         static void		traverse			();
         static void		traverse			(int n);
			static void		traverse			(char *indent, int n);
		};

#endif

