
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//    LRSTAR Parser Tables.

/*    Generated by: LRSTAR 6.3.006
      Grammar:      c.grm																									    
      Skeleton:     ..\..\skl\parser.cpp.skl
      Output:       c_parser.cpp
*/               
		#include "string.h"
  		#include "c_parser.h"
  		#include "c_actions.h"   

		#define ACCEPT_STATE	   220 // Final state.

/*--- Constants. -------------------------------------------------------------*/
                                                                                          
      int c_parser::n_terms      =    90; // No. of terminals.                               
      int c_parser::n_heads      =    77; // No. of non-terminals.     
      int c_parser::n_prods      =   229; // No. of productions.       
      int c_parser::n_states     =   221; // No. of states.
      int c_parser::eol_symb     =     0; // EOL symbol number            
      int c_parser::eof_symb     =     4; // EOF symbol number            
      int c_parser::err_used     =     0; // <error> used in grammar      
      int c_parser::n_nodenames  =   108; // No. of node names.   
      int c_parser::n_nodeactns  =     0; // No. of node actions.   

/*--- Terminal and Nonterminal Symbols of the Grammar. -----------------------*/

   // Terminal symbols of the grammar. 
      char* c_parser::term_symb[90] = 
      {
         "<error>",
         "<identifier>",
         "<constant>",
         "<string>",
         "<eof>",
         "\'auto\'",
         "\'break\'",
         "\'case\'",
         "\'cdecl\'",
         "\'char\'",
         "\'const\'",
         "\'continue\'",
         "\'default\'",
         "\'do\'",
         "\'double\'",
         "\'else\'",
         "\'enum\'",
         "\'extern\'",
         "\'far\'",
         "\'float\'",
         "\'for\'",
         "\'goto\'",
         "\'huge\'",
         "\'if\'",
         "\'int\'",
         "\'interrupt\'",
         "\'long\'",
         "\'near\'",
         "\'pascal\'",
         "\'register\'",
         "\'return\'",
         "\'short\'",
         "\'signed\'",
         "\'sizeof\'",
         "\'static\'",
         "\'struct\'",
         "\'switch\'",
         "\'typedef\'",
         "\'union\'",
         "\'unsigned\'",
         "\'void\'",
         "\'volatile\'",
         "\'while\'",
         "\'?\'",
         "\'||\'",
         "\'&&\'",
         "\'|\'",
         "\'^\'",
         "\'&\'",
         "\'==\'",
         "\'!=\'",
         "\'<\'",
         "\'>\'",
         "\'<=\'",
         "\'>=\'",
         "\'<<\'",
         "\'>>\'",
         "\'+\'",
         "\'-\'",
         "\'*\'",
         "\'/\'",
         "\'%\'",
         "\',\'",
         "\';\'",
         "{typedef}",
         "\'=\'",
         "\'{\'",
         "\'}\'",
         "\':\'",
         "\'(\'",
         "\')\'",
         "\'[\'",
         "\']\'",
         "\'...\'",
         "\'*=\'",
         "\'/=\'",
         "\'%=\'",
         "\'+=\'",
         "\'-=\'",
         "\'<<=\'",
         "\'>>=\'",
         "\'&=\'",
         "\'^=\'",
         "\'|=\'",
         "\'++\'",
         "\'--\'",
         "\'~\'",
         "\'!\'",
         "\'.\'",
         "\'->\'"
      };                                                 

   // Head symbol for a production 
      uchar c_parser::head_numb[229] = 
      {
          0,    1,    1,    2,    2,    3,    4,    5,    6,    7,    7,    8,    8,    8,    8,    8,    8,    8,    8,    8,
          8,    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,    9,    9,    9,    9,   10,   10,   11,   11,
         11,   12,   12,   12,   13,   14,   14,   14,   15,   15,   15,   16,   16,   17,   17,   18,   18,   18,   18,   18,
         19,   19,   20,   20,   21,   21,   22,   22,   23,   23,   23,   23,   24,   24,   25,   25,   25,   26,   26,   26,
         26,   27,   27,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   29,   30,   31,
         31,   32,   32,   33,   33,   34,   35,   35,   35,   35,   36,   37,   37,   38,   38,   38,   38,   38,   38,   38,
         38,   38,   38,   38,   38,   39,   39,   39,   39,   39,   39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
         39,   39,   39,   39,   39,   40,   40,   41,   41,   41,   41,   41,   41,   41,   41,   41,   41,   41,   42,   42,
         42,   42,   42,   42,   42,   43,   44,   45,   45,   45,   45,   46,   47,   48,   48,   49,   49,   50,   50,   51,
         52,   52,   53,   53,   54,   54,   55,   55,   56,   56,   57,   57,   58,   58,   59,   59,   60,   60,   61,   61,
         62,   62,   63,   63,   64,   64,   65,   65,   66,   66,   67,   67,   68,   68,   69,   70,   70,   71,   71,   72,
         72,   73,   73,   74,   74,   75,   75,   76,   76
      };

/*--- Bit Matrix and Access Vectors. -----------------------------------------*/

   // B_matrix.  
      uchar c_parser::Bm [236] = 
      {
          0,    0,    0,    0,    0,   16,    0,    0,    0,    0,    8,    0,   34,    1,   64,   64,    0,    1,    0,    0,
          0,  110,    9,   98,   90,   16,    0,    0,    0,    4,    0,    0,    0,   64,    1,    2,    0,    0,   64,    0,
          0,    0,    2,    0,    0,    0,    1,    0,    2,    0,    0,    8,    0,    2,    0,   64,   64,    0,    1,   64,
          0,    0,   78,    8,   98,   74,   16,    0,    0,    0,    3,    0,  240,  255,    0,    0,    0,    4,    8,    0,
          0,    0,   64,   49,    0,    0,    0,   32,    0,   78,    8,   98,   90,   16,    0,    0,    0,   64,    0,    2,
          0,    0,    0,    0,   14,    0,   98,   64,   16,   14,    1,   98,   64,   16,   32,    1,    0,    0,    0,   14,
          0,   98,   72,   16,   34,    1,   64,   64,    1,    0,    0,    0,  128,    0,    8,    0,    0,    0,  129,    0,
          1,   64,   64,    1,    2,    0,    0,   64,    1,    2,    0,   64,   64,    1,    0,    0,    0,    0,    2,    0,
          0,    0,   17,    0,    2,    1,   64,   96,    0,    1,    0,   16,    0,  240,  255,   32,    0,  192,  255,    0,
        128,  255,    0,    0,  255,    0,    0,  254,    0,    0,  252,    0,    0,  248,    0,    0,  240,    0,    0,  224,
          0,    0,  192,    0,    0,   64,   64,    1,   32,    1,   64,   64,    1,   34,    1,   64,   64,    4,   32,    1,
         64,   64,    5,    2,    0,   64,   96,    0,  224,  255,    0,  128,    0,    0,    0,    0
      };

   // B_matrix row. 
      uchar c_parser::Br [221] = 
      {
          0,    5,    7,   12,   16,   21,   26,   30,   35,   39,   43,   48,   48,   48,    0,   53,   57,   62,   67,   71,
         74,   79,   84,   12,   21,   89,   78,   39,   39,   62,   94,   99,   94,  104,  104,   94,   94,  104,  104,  104,
        104,  109,  104,  104,  104,  104,  114,  119,  124,  104,   30,   53,    7,   99,    7,   16,    7,   16,   57,  129,
         99,   67,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,
        104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,   99,   99,   26,   67,   89,
        133,  104,   39,  104,   43,   39,  109,  104,  104,  129,  135,  139,  104,  119,  144,  129,  129,   30,  124,   43,
         43,  149,  104,   71,  154,   99,  159,   26,   16,  164,  168,   16,  168,   36,  172,  176,  179,  182,  185,  188,
        191,  191,  194,  194,  194,  194,  197,  197,  200,  200,    0,    0,    0,  129,   43,   43,  154,   94,   39,   43,
        135,  129,  135,  135,  104,   30,  203,   43,   30,  208,  104,  213,  218,  129,  154,  159,   99,  104,  168,   84,
         67,  104,  168,  104,  104,  104,  104,   62,    7,   62,    2,  119,  129,  208,  154,   12,  104,  223,  227,  135,
         39,   43,   28,    0,   39,  104,   62,   41,  231,  129,   43,    2,   84,  104,   62,    0,   84,   62,    0,   62,
          0
      };

   // B_matrix column.
      uchar c_parser::Bc [90] = 
      {
          0,    0,    0,    0,    0,    0,    0,    0,    1,    1,    1,    0,    1,    0,    1,    1,    1,    0,    1,    1,
          0,    0,    1,    0,    1,    1,    1,    1,    1,    0,    0,    1,    1,    0,    0,    1,    0,    0,    1,    1,
          1,    1,    1,    1,    1,    1,    1,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
          2,    2,    3,    3,    1,    3,    3,    3,    3,    3,    3,    4,    4,    4,    4,    4,    4,    4,    4,    4,
          4,    4,    4,    4,    4,    4,    0,    0,    4,    4
      };
  
	// B_matrix column.
      uchar c_parser::Bmask [90] = 
      {
          1,    2,    4,    8,   16,   32,   64,  128,    1,    1,    1,   64,    2,   64,    1,    4,    1,   32,    1,    1,
         64,   64,    1,   64,    1,    1,    1,    1,    1,   32,   64,    1,    1,    4,   32,    1,   64,   16,    1,    1,
          1,    1,    8,   16,   32,   64,  128,    1,    2,    4,    4,    8,    8,    8,    8,   16,   16,   32,   32,   64,
        128,  128,    1,    2,    1,    4,    8,   16,   32,   64,  128,    1,    2,    4,    8,    8,    8,    8,    8,    8,
          8,    8,    8,    8,   16,   16,    4,    4,   32,   32
      };
  
/*--- Terminal Transition Matrix and Access Vectors. -------------------------*/

   // T_matrix. 
      short c_parser::Tm [750] = 
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  127,    0,    0,    0,    0,    0,
          0,    0,    0, -172,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, -171,
          0,    0,   62,  -88,  185,  169,  203,  170, -171,  108,  188,  133,   -3,    0,    0,  125,  -82,    0,  103, -157,
        176,  -85,    0,    0,  131,  -49,    0,  107,  -80,   34,    0,   38,   39,   40,    0,    0,   62,  186,   34,    0,
         38,   39,   40,  112,  189,  191,  205,   37, -171,  113,    0,    0,   41,  214,    0,    0,   37,    0,   42,   43,
         44,   45, -227, -168,    0,    0,    0,   42,   43,   44,   45, -227, -168,    0,    0,    0,    0,    0,   34,    0,
         38,   39,   40,    0,    0,   51,   -5,    0,    0,  128,  -93,    0,  106,  -78,    0,    0,   37,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,   42,   43,   44,   45, -227, -168, -171,  -25,  -12,  -16,  -18,   11,  -22,
        -17,  -24,  -11,  -27,  -13,  -23,  -26,  -15,  -19,   12,   13,  -20,  -14,  -21,    0,    0, -171,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,   14,    0,    0,    0,    0,  -31,    0,    0,    0,  181,   15,   27,   28,
         29,    0,   31,   32,    0,   33,   34,    0,   38,   39,   40,   35,   30,   62,  -83,    0,    0,    5, -108, -171,
         41,  187,   36,    0,   37,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   42,   43,   44,   45, -227,
       -168,   27,   28,   29,    0,   31,   32,    0,   33,   34,    0,   38,   39,   40,   35,   30,   62,  -83,    0,    0,
          5, -109,    0,   41,  204,   36,    0,   37,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   42,   43,
         44,   45, -227, -168,   56,  -25,  -12,  -16,  -18,   11,  -22,  -17,  -24,  -11,  -27,  -13,  -23,  -26,  -15,  -19,
         12,   13,  -20,  -14,  -21,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,  172,  -86,  -31,    0,   57,  -43,  218,  101,  -59,  -25,  -12,  -16,  -18,   11,  -22,  -17,  -24,  -11,  -27,
        -13,  -23,  -26,  -15,  -19,   12,   13,  -20,  -14,  -21,  -34,    0,    0,    0,  -32,    0,    0,  -35,    0,    0,
        -33,    0,    0,   14,    0,    0,  197,  -44,  -31,    0,    0,    0,    0,  166,    0,  122,    0,  -65, -171,  -25,
        -12,  -16,  -18,   11,  -22,  -17,  -24,  -11,  -27,  -13,  -23,  -26,  -15,  -19,   12,   13,  -20,  -14,  -21,  -34,
          0,    0,    0,  -32,    0,    0,  -35,    0,    0,  -33,    0,    0,   14,    0,    0,  176,  -95,  -31,    0,    0,
        -50,    0,  121,    0,  122,   54,  -25,  -12,  -16,  -18,   11,  -22,  -17,  -24,  -11,  -27,  -13,  -23,  -26,  -15,
        -19,   12,   13,  -20,  -14,  -21,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,  171,  -87,  -31,    0,   55,  -40,  215,   93,  -58,   94,  -79,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0, -163, -164,    0,    0,   95,   96, -171,  -25,  -12,  -16,  -18,   11,  -22,  -17,  -24,  -11,
        -27,  -13,  -23,  -26,  -15,  -19,   12,   13,  -20,  -14,  -21,  -34,  213,  212,  206,  -32,    0,    0,  -35,    0,
          0,  -33,    0,    0,   14,    0,    4,   51,   -4,  -31,   47,    5,  -39, -105,   15,  -56,  157,  -57,  -63,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, -228,  220,   52,  -25,  -12,  -16,  -18,
         11,  -22,  -17,  -24,  -11,  -27,  -13,  -23,  -26,  -15,  -19,   12,   13,  -20,  -14,  -21,   65,   66,   67,   69,
         70,   71,   72,   73,   74,   75,   76,   77,   78,   79,   80,   81,   62,  -84,  -31,  177,   53,  -42,  183,   48,
       -170,   49,  -77,   68,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   63,   64,
       -171,  -25,  -12,  -16,  -18,   11,  -22,  -17,  -24,  -11,  -27,  -13,  -23,  -26,  -15,  -19,   12,   13,  -20,  -14,
        -21,  -34,   27,   28,   29,  -32,   31,   32,  -35,   33,   34,  -33,   38,   39,   40,   35,   30,  184,  -83,  -31,
          0,    5, -107,    0,   41, -161,   36,    0,   37,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   42,
         43,   44,   45, -227, -168, -171,  -25,  -12,  -16,  -18,   11,  -22,  -17,  -24,  -11,  -27,  -13,  -23,  -26,  -15,
        -19,   12,   13,  -20,  -14,  -21,  -34,   27,   28,   29,  -32,   31,   32,  -35,   33,   34,  -33,   38,   39,   40,
         35,   30,   62,  -83,  -31,   82,    5, -106,  196,   41,  164,   36, -159,   37,   83,   84,   85,   86,   87,   88,
         89,   90,   91,   92,   42,   43,   44,   45, -227, -168
      };

   // T_matrix row. 
      ushort c_parser::Tr [221] = 
      {
        490,  490,  490,  490,  490,  685,  490,  555,  490,  490,  490,  555,  425,  284,  490,  490,  490,  685,  555,  555,
        685,  425,  490,  490,  620,  176,  490,  425,  284,  685,  284,  490,   14,  685,   88,   23,    5,  685,  685,  685,
        685,  685,   39,   39,  685,  685,  490,   48,  378,  685,  555,  490,   14,   14,   88,  490,   23,  490,  490,  490,
         23,   14,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,
        685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  685,  490,  490,  490,   88,  219,
        490,  685,   23,  685,  685,    5,  685,  685,  685,  685,  555,  329,  685,   48,  378,  425,  284,    1,  378,  425,
        284,  378,  685,  555,  490,   14,   23,  555,  490,  153,  490,  490,  555,  490,  555,  555,  555,  555,  555,  555,
        555,  555,  555,  555,  555,  555,  555,  555,  555,  555,  490,  490,  490,  620,  620,  685,  685,    0,   39,  685,
        176,   14,    5,   39,  685,  329,  329,   48,    1,  329,  685,  490,  329,   88,  555,  378,   14,  685,  425,  685,
        329,  685,  284,  685,  685,  685,  685,  685,    5,  685,   14,   48,   23,  329,  425,  490,  685,  153,  555,  219,
         48,  685,  490,  490,  378,  685,  685,  490,  490,   48,  685,   88,  425,  685,  685,  490,  284,  685,  490,  685,
        490
      };

   // T_matrix column. 
      uchar c_parser::Tc [90] = 
      {
          0,    0,   64,   63,   64,   21,   22,   22,    1,    2,    3,   23,   23,   24,    4,   24,    5,   25,    6,    7,
         36,   26,    8,   27,    9,   10,   11,   12,   13,   28,   29,   14,   15,   30,   31,   16,   35,   36,   17,   18,
         19,   20,   46,   63,   64,   21,   22,   23,   48,   24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,
         35,   36,   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,   48,   49,   50,   51,   52,   53,   54,
         55,   56,   57,   58,   59,   60,   61,   62,   63,   64
      };

/*--- Nonterminal Transition Matrix and Access Vectors. ----------------------*/

   // N_matrix. 
      short c_parser::Nm [1363] = 
      {
          0,    0,    0,    0,    0,    0, -149, -160, -162, -169,   21, -158,  -55,  -28,    0,  102,  -55,    0,    0,    0,
          8,    0,    0,  -61,    8,    0, -201,   97,    0,    7, -195,  179,    0,    7, -187,   26,    0, -150, -145,  -29,
        -30, -169,   21, -158, -155, -145,    0,  -55, -169,   21, -158,  173,  117, -146, -145,  114,    0, -169,   21, -158,
          0,    0,   59,    0,    7,    0,    0,   26,    0,    0,  134, -125, -145,    0,   26, -169,   21, -158,    0,  135,
       -125, -145,    0,   26, -169,   21, -158,  136, -125, -145,    0,    0, -169,   21, -158,    0,    0,  137, -125, -145,
          0,   26, -169,   21, -158,    0,  138, -125, -145,    0,   26, -169,   21, -158,  139, -125, -145,    0,   26, -169,
         21, -158,    0,    0,  140, -125, -145,    0,   26, -169,   21, -158,    0,  141, -125, -145,    0,   26, -169,   21,
       -158,  142, -125, -145,    0,   26, -169,   21, -158,    0,    0,  143, -125, -145,    0,   26, -169,   21, -158,    0,
        144, -125, -145,    0,   26, -169,   21, -158,  145, -125, -145,    0,   26, -169,   21, -158,    0,    0,  146, -125,
       -145,    0,   26, -169,   21, -158,    0,  147, -125, -145,    0,   26, -169,   21, -158,  148, -125, -145,    0,   26,
       -169,   21, -158,    0,    0,  149, -125, -145,    0,   26, -169,   21, -158,    0,  150, -125, -145,    0,   26, -169,
         21, -158,  151, -125, -145,    0,   26, -169,   21, -158,    0,    0,  152, -125, -145,    0,   26, -169,   21, -158,
          0,  198, -125, -145,    0,   26, -169,   21, -158, -112,   19, -125,   20,   26,    0, -169,   21, -158, -114,   19,
       -125,   20,    0,   26, -169,   21, -158, -115,   19, -125,   20,    0,   26, -169,   21, -158, -116,   19, -125,   20,
          0,   26, -169,   21, -158, -117,   19, -125,   20,    0,   26, -169,   21, -158, -118,   19, -125,   20,    0,   26,
       -169,   21, -158, -119,   19, -125,   20,    0,   26, -169,   21, -158, -120,   19, -125,   20,    0,   26, -169,   21,
       -158, -121,   19, -125,   20,    0,   26, -169,   21, -158, -122,   19, -125,   20,    0,   26, -169,   21, -158, -123,
         19, -125,   20,    0,   26, -169,   21, -158, -124,   19, -125,   20,    0,   26, -169,   21, -158,    0,  123, -125,
       -145,    0,   26, -169,   21, -158,    0,  123, -125, -145,    0,   26, -169,   21, -158,    0,    0,  -52,    0,    0,
         26,    0,    0,    0,    0,    0,  -45,    0,    0,   26,    0,    0,    0, -226,   19, -125,   20,    0,   26, -169,
         21, -158,  123, -125, -145,    0,    0, -169,   21, -158,  123, -125, -145,    0,    0, -169,   21, -158,    0,    0,
          0,  -46,    0,    0,    0,   26,    0,    0,    0,  216,    0,    0,    0,   26,    0,    0,  -81,   19, -125,   20,
          0,   26, -169,   21, -158,  123, -125, -145,    0,    0, -169,   21, -158,  -37,    0,    0,    0,    0,    0,    0,
          0,  124,    0,    0, -199,    0,    0,    0,   26,    0,  160, -111,   19, -125,   20,    0,   26, -169,   21, -158,
        162, -111,   19, -125,   20,    0,    0, -169,   21, -158,  163, -111,   19, -125,   20,    0,    0, -169,   21, -158,
        123, -125, -145,   26,    0, -169,   21, -158,    0,    0,    0,    0,    0,   26,    0,    0,  174,    0,    0, -199,
        123, -125, -145,   26,    0, -169,   21, -158,    0,    0,    0,   26,    0,    0,    0,    0,  194,    0,    0, -199,
        199, -111,   19, -125,   20,    0,    0, -169,   21, -158,    0,   26,  -81,   19, -125,   20,    0,    0, -169,   21,
       -158,    0,    0,  155, -111,   19, -125,   20,  156, -207, -169,   21, -158,   26,  159, -111,   19, -125,   20,    0,
          0, -169,   21, -158,   26,  -81,   19, -125,   20,    0,  158, -169,   21, -158,    0,    0,   26,    0,    0,  -28,
          0,  -55, -206,    0,    0,    0,  167,   26,    0,    8,  180,    0, -176,    0,    0, -194,  179,   26,    7,    0,
        201, -111,   19, -125,   20,  -29,  -30, -169,   21, -158,  -28,    0,  -55,    0,    0, -189,    0,    0,    0,    0,
          8,  -10,    0,   -9,    0,    0,    0,  -67,    0,    7,    0,  200,    0,   26,    0,    0,  -29,  -30,  210, -111,
         19, -125,   20,    0,    0, -169,   21, -158, -225,   19, -125,   20,    0,  153, -169,   21, -158,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  209,   26,    0,    0,    0,    0,    0,    0, -166,  154,
         26,  -28,    0,  -55,    0,    0, -188,    0,    0,   23,    0,    8,  -10,    0,   -9,    0,    0, -191,   59,  -28,
          7,  -55,    0,    0, -189,    0,    0,  -29,  -30,    8,  -10,    0,   -9,    0,    0,    0,   97,    0,    7,    0,
          0,    0,    0, -186,    0,  -29,  -30,   98, -156,  -28,    0, -169,   21, -158,    0, -192,    0,    0,    0,  178,
          0,    0, -175, -151, -145,  -28,    0, -169,   21, -158,    0, -193,    0,  129,    0,  -29,  -30,   26, -175,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,  129,    0,  -29,  -30,   26,  -28,    0,  -55,    0,    0, -189,
        -71,  117,    0,    0,  114,  -10,    0,   -9,    0,    0,    0,  -67,    0,    7, -203,    0,    0,  -28,    0,  -55,
        -29,  -30, -188,    0,    0,  195,    0,    8,  -10,    0,   -9,    0,    0,    0,  -66,    0,    7,    0,   18, -111,
         19, -125,   20,  -29,  -30,   22,   21, -158,   18, -111,   19, -125,   20,    0,    0,   22,   21, -158,  -90,    0,
        202,    0,   17,    0,    0,    0,    0,    0,  -90,    0,  -94,   26,   17,    0,    0,   18, -111,   19, -125,   20,
          0,   26,   22,   21, -158,   18, -111,   19, -125,   20,    0,    0,   22,   21, -158,  -90,    0,  -92,    0,   17,
          0,    0,    0,    0,    0,  -90,    0,  -96,   26,   17,    0,    0,   18, -111,   19, -125,   20,    0,   26,   22,
         21, -158,    0, -153, -145,  -28,    0, -169,   21, -158,    0, -192,  -90,    0, -213,  182,   17,    0, -175,    0,
          0,    0,    0,    0,    0,   26,    0,    0,    0,  129,    0,  -29,  -30,   26,  -28, -196,  -55,    0,    0,   60,
       -181,  168,    0,    0, -178,    0,  175, -175,    0,    0,    0,    0,    0,   50,  219,    0,    0,    0,   16,    0,
        -29,  -30, -148,  -28,    0, -169,   21, -158, -189,  -71,  117,    0,    0,  165,  -10,    0,   -9,  110, -111,   19,
       -125,   20,  -28,    0, -169,   21, -158,  109,    0,  -29,  -30,   26,    0,    0,    0, -175,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,  111,    0,  -29,  -30,   26,  110, -111,   19, -125,   20,  -28,    0, -169,   21,
       -158,  161,    0,  104, -111,   19, -125,   20,  -28, -175, -169,   21, -158,    0,  -73,  117,    0,    0,  165,    0,
        111, -176,  -29,  -30,   26,    0,    0,  105,    0,    0,    0,    0,    0,    0,  -29,  -30,   26, -152, -145,  -28,
          0, -169,   21, -158, -188,  -70,  117,  193,    0,  165,  -10,    0,   -9,   18, -111,   19, -125,   20,  -28,    0,
         22,   21, -158, -205, -192,  -29,  -30,   26,  130,    0,    0, -175,    0,  -90,    0, -222,    0,   17,    0,    0,
          0,    0,  129,    0,  -29,  -30,   26,   18, -111,   19, -125,   20,  -28,    0,   22,   21, -158,    0, -192,    0,
          0,    0,  132,    0,    0, -175,    0,  -90,    0,  100,    0,   17,    0,    0,    0,    0,  129,    0,  -29,  -30,
         26,  192,    0, -154, -145,  -28,    0, -169,   21, -158, -188,  -70,  117,  193,    0,  165,  -10,    0,   -9,    0,
          0,  120,    0,    0,    0,    0,    0,    0,    0, -204,    0,  -29,  -30,   26,  115,  116, -202,    0,    0,  -28,
          0,  -55,    0,    0, -188,  -70,  117,  118,    0,  114,  -10,    0,   -9,    0,  119,  120,  -66,    0,    7,    0,
          0,    0,    0, -204,    0,  -29,  -30,   18, -111,   19, -125,   20,  -28,    0,   22,   21, -158,   60, -180,   61,
          0,    0, -178,    0,    0, -176,    0,  -90,    0,  -89,    0,   17,    0,    0,    0,    0,    0,    0,  -29,  -30,
         26,   18, -111,   19, -125,   20,  -28,    0,   22,   21, -158, -188,    0,    0,   23,    0,    0,  -10,    0,   -9,
          0,  -90, -220, -221,    0,   17,    0,    0,    0,    0,    0,   99,  -29,  -30,   26,   18, -111,   19, -125,   20,
        -28, -197,   22,   21, -158, -188,  173,  117,   23,    0,  165,  -10,    0,   -9,    0,  -90, -219, -221,    0,   17,
          0,    0,    0,    0,   24,   25,  -29,  -30,   26,   -2,    2,   -6,  207,  211,  -28, -196,  -55, -179,    1, -183,
         -1,  168,    3,   46,    8,  -10,  126,   -9,   58,   -8, -174,    6,  190,    7,  217, -216,  208,  -98, -186,    9,
        -29,  -30,   10
      };

   // N_matrix row. 
      ushort c_parser::Nr [221] = 
      {
       1329, 1329, 1329, 1329,  949, 1295, 1329, 1329,  949, 1329, 1329, 1329, 1329, 1329, 1329,  696, 1227, 1227, 1329, 1329,
       1329, 1329, 1329,  714, 1261, 1093, 1329, 1329, 1329, 1127, 1329,    8, 1329, 1043,  744, 1329, 1329,  760,  920, 1160,
       1074,  997,  978,    2,   34,   41,  696,  435, 1194,  443, 1329,    5, 1329, 1329, 1329, 1093, 1329, 1127,    8, 1329,
       1329, 1329,  248,   68,   77,   85,   95,  104,  112,  122,  131,  139,  149,  158,  166,  176,  185,  193,  203,  212,
        220,  230,  257,  266,  275,  284,  293,  302,  311,  320,  329,  338,  347,  667,  563,    0,    1, 1329, 1329, 1093,
       1329,  574, 1329,  470, 1329, 1329, 1031,  480,  490, 1329, 1329, 1043,  997,  584,  949, 1329, 1329, 1329,  789, 1329,
       1329,   40,  498, 1329, 1329,  949, 1329, 1329,  744,  594,  760,  920,  760,  949, 1329, 1329, 1329, 1329, 1329, 1329,
       1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329, 1329,
       1329, 1329, 1329, 1329,   50, 1329, 1295, 1329, 1329, 1160,  518,  812, 1074, 1329, 1329, 1329, 1295,  356,  760, 1329,
       1329,  365,  760,  239,  392,  540,  620,  838, 1329,  848, 1329,  551, 1329,  978, 1329,  625,  400,    9, 1329, 1329,
       1329, 1329, 1329, 1329, 1329,  658,  875, 1329, 1329, 1329, 1329, 1329, 1329,  408,  885, 1329, 1329,  912,  949,  912,
       1329
      };

   // N_matrix column. 
      uchar c_parser::Nc [229] = 
      {
         21,   21,   21,   11,   11,   21,    0,    1,    2,   10,   10,   18,   18,   18,   18,   18,   18,   18,   18,   18,
         18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   16,   16,   16,   16,   29,   29,   31,   31,
         31,   32,   32,   32,   11,   21,   21,   21,    5,    5,    5,    6,    6,   22,   22,   24,   24,   24,   24,   24,
         15,   15,    0,    0,    1,    1,    2,    2,   29,   29,   29,   29,   10,   10,   11,   11,   11,   12,   12,   12,
         12,   18,   18,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,    3,    4,   16,
         16,   31,   31,   32,   32,   24,   20,   20,   20,   20,   21,    0,    0,    1,    1,    1,    1,    1,    1,    1,
          1,    1,    1,    1,    1,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
          2,    2,    2,    2,    2,    3,    3,    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,    8,    8,
          8,    8,    8,    8,    8,    5,    6,    9,    9,    9,    9,    7,    8,    9,    9,   29,   29,   10,   10,   11,
         12,   12,   13,   13,   30,   30,   33,   33,   13,   13,   14,   14,   15,   15,   16,   16,   17,   17,   18,   18,
         19,   19,   20,   20,   21,   21,   22,   22,   23,   23,   24,   24,   25,   25,   26,   27,   27,   28,   28,   29,
         29,   30,   30,   31,   31,   32,   32,   33,   33
      };

/*--- Reduction Matrix and Access Vectors. -----------------------------------*/

   // R_matrix. 
      uchar c_parser::Rm [5] = 
      {
          0,    0,    0,  190,   36
      };

   // R_matrix row. 
      short c_parser::Rr [221] = 
      {
        173,  182,    0,  184,    0,    0,   -2,   53,    0,    0,  185,    0,    0,    0,  200,    0,  177,    0,    0,  113,
        145,  147,  169,    0,    0,    0,  167,    0,    0,    0,    0,    0,    0,  210,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    7,    0,   68,  198,   54,    0,   48,    0,   38,    0,   41,    0,   60,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  223,    0,    0,    0,   36,    0,    0,
          0,   99,    0,    0,  211,    0,    0,    0,    0,    0,    0,   72,    0,    0,   74,    0,    0,   75,   69,   62,
         64,    0,  198,  110,    0,    0,    0,   51,    0,    0,    0,    0,    0,  177,    0,  127,  128,  129,  130,  131,
        132,  133,  134,  135,  136,  137,  138,  139,  140,  141,  142,  143,  144,    0,  224,  165,    0,    0,    0,  100,
          0,    0,    0,    0,    0,   74,    0,  208,   76,   68,  198,    0,   68,    0,    0,    0,    0,    0,    0,   47,
          0,    0,    0,    0,    0,    0,  101,    0,    0,    0,    0,  209,    0,   69,    0,    0,    0,    0,  126,    0,
          0,  102,   91,  215,    0,  103,    0,  217,   97,    0,  104,    0,    0,    0,    0,  212,    0,  218,  212,  214,
          0
      };

   // R_matrix column. 
      uchar c_parser::Rc [90] = 
      {
          0,    0,    0,    0,    0,    1,    0,    0,    1,    1,    1,    0,    0,    0,    1,    0,    1,    1,    1,    1,
          0,    0,    1,    0,    1,    1,    1,    1,    1,    1,    0,    1,    1,    0,    1,    1,    0,    0,    1,    1,
          1,    1,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    2,    2,    1,    0,    1,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0
      };

/*--- Nondeterministic Parsing Arrays. ---------------------------------------*/

   // Nondeterministic Start. 
      uchar c_parser::nd_start [222] = 
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0
      };

   // Nondeterministic Terminal Symbol. 
      uchar c_parser::nd_term [1] = 
      {
         0
      };

   // Nondeterministic Action.
      uchar c_parser::nd_action [1] = 
      {
         0
      };

/*--- Production Variables. --------------------------------------------------*/

   // Production length - 1 
      char c_parser::PL[229] = 
      {
          1,    0,    0,    3,    2,    2,    1,    2,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    2,    1,    3,
          4,    1,    3,    4,    2,    1,    2,    0,    1,    3,    4,    0,    2,    0,    1,    0,    2,    3,    3,    3,
          1,    2,    0,    2,    0,    2,    0,    1,   -1,    0,    0,    1,    0,    1,    0,    0,    1,    2,    2,    3,
          3,    0,    3,    0,    1,    2,    1,    1,    2,    1,    0,    4,    6,    7,    4,    6,    8,    0,    0,   -1,
          0,   -1,    0,   -1,    0,    1,    1,    2,    2,    3,    0,    0,    2,    0,    2,    2,    2,    2,    2,    2,
          2,    2,    2,    2,    2,    0,    4,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
          2,    2,    2,    2,    2,    0,    3,    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,    3,    0,    3,
          2,    3,    2,    1,    1,    0,    0,    0,    0,    0,    2,    0,    0,   -1,    1,    0,    1,   -1,    0,    1,
          0,    2,   -1,    1,   -1,    0,    0,    2,    0,    1,   -1,    1,    0,    1,    0,    2,    0,    2,   -1,    0,
         -1,    1,    0,    2,    0,    2,    0,    2,   -1,    0,   -1,    0,   -1,    1,    3,   -1,    1,   -1,    2,    0,
          1,    0,    1,   -1,    0,    0,    2,    0,    1
      };

   // Reverse the order of nodes (for a production/rule).
      uchar c_parser::reverse[229] = 
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0
      };

/*--- Token Action Variables -------------------------------------------------*/

	// Token Action number. 
      char c_parser::tact_numb[90] = 
      {
          0,    1,    1,    1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

   // Token Action Function Pointers.	
      int (*c_parser::tact_func[2]) (int&) = 
      {
			c_token_action::error,
         c_token_action::lookup
      };

	// First argument index for token actions.
      char c_parser::tact_arg[90] = 
      {
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

/*--- Parser Action Variables ------------------------------------------------*/

   // Parser Action Number
      char c_parser::pact_numb[229] = 
      {
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

   // Parser Action Function Pointers	
      int (*c_parser::pact_func[1]) (int) = 
      {
			c_parse_action::typedefidentifier_
      };

	// Parser Action Argument Index and first argument for make_node.
      char c_parser::pact_arg[229] = 
      {
          0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    1,    2,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,    3,    4,   -1,   -1,    5,    6,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

/*--- Make-Node Variables ----------------------------------------------------*/

   // Make-Node Numbers (for a production).
      char c_parser::node_numb[229] = 
      {
          0,    1,    1,    2,    3,    4,    5,    6,    7,    8,    9,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   10,   11,   12,   12,
         12,   13,   13,   13,   14,   15,   15,   15,   16,   16,   16,   17,   18,   19,   19,   20,   10,   21,    6,    6,
         22,   22,   23,   23,   24,   24,   10,   10,   -1,   25,   25,   25,   26,   26,   27,   27,   27,   28,   27,   29,
         30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,   48,   -1,
         49,   -1,   50,   -1,   51,   52,   -1,   -1,   -1,   -1,   53,   54,   55,   -1,   56,   57,   58,   59,   60,   61,
         62,   63,   64,   65,   66,   -1,   67,   68,   69,   70,   71,   72,   73,   74,   75,   76,   77,   78,   79,   80,
         81,   82,   83,   84,   85,   -1,   86,   -1,   87,   88,   89,   90,   91,   92,   93,   94,   95,   95,   -1,   96,
         97,   98,   99,  100,  101,  102,  103,  104,  105,   -1,   34,  106,  107,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

   // Node Names.
      char* c_parser::node_name[108] = 
      {
      "goal_",
      "extdef_",
      "typedef_decl_",
      "extdecl_",
      "decl_",
      "funcdef_",
      "funcdecl_",
      "funcbody_",
      "type_",
      "class_",
      "declarator_",
      "declaratorinit_",
      "struct_",
      "union_",
      "structdecl_",
      "structdeclarator_",
      "enumspec_",
      "enumident_",
      "enumequals_",
      "directdecl_",
      "ident_",
      "arraydecl_",
      "pointer_",
      "argdecl_",
      "absargdecl_",
      "absarg_",
      "typespec_",
      "absdeclarator_",
      "constexp_",
      "absarray_",
      "absfunc_",
      "assign_",
      "init_",
      "empty_",
      "exp_",
      "goto_",
      "continue_",
      "break_",
      "return_",
      "labeledstmt_",
      "block_",
      "if_",
      "ifelse_",
      "switch_",
      "while_",
      "do_",
      "for_",
      "case_",
      "default_",
      "exp1_",
      "exp2_",
      "exp3_",
      "label_",
      "condexp_",
      "assignment_",
      "comma_",
      "equals_",
      "muleq_",
      "diveq_",
      "modeq_",
      "addeq_",
      "subeq_",
      "shleq_",
      "shreq_",
      "andeq_",
      "xoreq_",
      "oreq_",
      "question_",
      "or_",
      "and_",
      "bitor_",
      "bitxor_",
      "bitand_",
      "eq_",
      "ne_",
      "lt_",
      "gt_",
      "le_",
      "ge_",
      "shl_",
      "shr_",
      "add_",
      "sub_",
      "mul_",
      "div_",
      "mod_",
      "cast_",
      "preinc_",
      "predec_",
      "complement_",
      "addressof_",
      "contentsof_",
      "positive_",
      "negative_",
      "not_",
      "sizeof_",
      "array_",
      "member_",
      "funccall_",
      "ptrto_",
      "postinc_",
      "postdec_",
      "subscript_",
      "arguments_",
      "string_",
      "const_",
      "identifier_",
      "typedefidentifier_"
      };

/*--- Node-Action Variables --------------------------------------------------*/

   // Node-Action Numbers. 
      char c_parser::nact_numb[229] = 
      {
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

	// Node-Action Function Pointers.
      int (*c_parser::nact_func[1]) (int n) = 
      {
			0
      };   

   // Node Action Argument Index
      char c_parser::nact_arg[1] = 
      {
         0
      };

/*--- Argument Numbers. ------------------------------------------------------*/

   // Parse action argument numbers 
      uchar c_parser::arg_numb[8] = 
      {
          2,    1,    1,    1,    1,    1,    1,   64
      };

   // Text for string arguments. 
      char* c_parser::arg_text[1] = 
      {
         ""
      };


/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    LRSTAR Parser.

		#include "string.h"

		#define STKSIZE    1000 // Parser stack size.    
		#ifndef LOOKAHEADS
		#define LOOKAHEADS 3		// Number of lookaheads for LR(*) parsing.
		#endif

		#ifndef UINT_MAX
	  	#define UINT_MAX 0xffffffff 					// for 32-bit CPUs.			
	// #define UINT_MAX 0xffffffffffffffff 		// for 64-bit CPUs.			
		#endif

	// Parser stuff ...
		PStack*  c_parser::PS;                  
		PStack*  c_parser::PS_end;                  
      PStack   c_parser::P_stack[STKSIZE];   
		int      c_parser::n_errors;
		int      c_parser::max_errs;
		int      c_parser::status;
		char*		c_parser::inputname;
		FILE*		c_parser::outputdesc;

	// Restore stack stuff ...
      RStack*	c_parser::RS; 
      RStack	c_parser::R_stack[STKSIZE]; 
  		PStack*  c_parser::PStop;
  		int      c_parser::topstate;

	// Symbol table stuff ...
      Symbol*  Symtab::symbol;
		int      Symtab::cell;
		int      Symtab::sti;
		int      Symtab::length;
		int      Symtab::n_symbols;
		int      Symtab::n_keywords;
		uint     Symtab::hashdiv;
		int*		Symtab::hashvec;
		int		Symtab::max_cells;
		int		Symtab::max_symbols;

		// AST stuff ...
		Node*    AST::node;
		int      AST::root;
  		int      AST::n_nodes;
  		int      AST::max_nodes;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    c_parser -  initialization																  

int   c_parser::init (char* Inputname, FILE* Outputdesc, int max_symb, int max_node)
{
		inputname  = Inputname;										// Move name into parser object.
		outputdesc = Outputdesc;									// Move desc into parser object.

		if (!init_symtab (max_symb)) return (0);           // Initialize the symbol table.
		if (!init_ast (max_node)) return (0);              // Initialize the AST. 
		token.start = "";                                  // Make a blank symbol.
		token.end   = token.start + 1;
		add_symbol (0, token.start, token.end);				// Add it to the symbol table.

      n_errors = 0;							                  // Set number of errors.    
      max_errs = 10;							                  // Set max number of errors.
		return (1); // Return OK.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    c_parser -  termination

void  c_parser::term ()
{
		print_symtab (term_symb);			                  // Print the symbol table contents.
		print_ast ();							                  // Print the AST, if ast option indicates.
		traverse	 ();							                  // Traverse the AST, calling the AST actions.
		term_ast  ();
		term_symtab ();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		Minimal LR Parser

int   c_parser::parse (char* input_start)                
{
      int p;                                          	// Production (rule) number.  
      int t;                                          	// Terminal symbol number. 
      int x = 0;                                      	// State number.  

		lexer_init (input_start);									// Initialize lexer.
      PS_end = P_stack + STKSIZE;			            	// Set parse-stack end pointer.   
      PS     = P_stack;							            	// Set parse-stack pointer.   

Read:	t = get_token ();												// Get incoming token.
		token.sti = -t;												// Symbol-table index = -t.
      if (tact_numb[t] >= 0)					            	// If token action ...         
      {
         token.sti = (*tact_func [tact_numb[t]])(t);  	// Call token-action function.
      }
Shft: if (Bm [Br[x] + Bc[t]] & Bmask[t])	            	// Check B-matrix for shift action. 
      {
			if (++PS >= PS_end) goto Over;						// Check for stack overflow.
         PS->state = x;                               	// Put current state on stack.  
         PS->sti   = token.sti;                       	// Put token symbol table index on stack.
         PS->line  = token.linenumb;                  	// Put its line number on stack.
         PS->node  = 0;						               	// Set node on stack to zero.   
         x = Tm [Tr[x] + Tc[t]];                      	// Get next state from terminal transition matrix.
         while (x <= 0)                               	// While shift-reduce actions. 
         {
				p = -x;													// Reduce stack by production p.	
            PS -= PL[p];											// Reduce stack ptr by production length. 
			  	if (!reduce(p)) return -linenumb;				// Call reduce action with rule number.
            x = Nm [Nr[PS->state] + Nc[p]];					// Get next state from nonterminal transition.
         }
         goto Read;								               // Go to read next token.
      }
		if ((p = Rr[x]) > 0 || (p = Rm [Rc[t] - p]) > 0)   // Get reduction?
      {
			PS -= PL[p];												// Reduce parse stack ptr by rule length - 1. 
         if (PL[p] < 0)							               // Null production?
         {	
				if (PS >= PS_end) goto Over;						// Check for overflow.
            PS->node  = 0;						               // Clear node pointer.
            PS->state = x;						               // Stack current state, replacing old state.
         }
         while (1) 
         {
      		if (!reduce(p)) return -linenumb;				// Call reduce action with rule number.
            x = Nm [Nr[PS->state] + Nc[p]];	            // Get next state from nonterminal transition.
            if (x > 0) goto Shft;                        // Continue parsing.
            p = -x;								               // Set production number.
            PS -= PL[p];                                 // Reduce parse stack ptr by rule length - 1. 
         }
		}
      if (x == ACCEPT_STATE)					               // If Goal production.  
      {
         PS -= PL[0];                                    // Reduce parse stack ptr by rule length - 1. 
     	  	if (!reduce(0)) return -linenumb;					// Call reduce action with rule number.
         if (linenumb > 0) linenumb = --linenumb;			// Reduce line number by one.
			root = PS[0].node;                              // Define root node.
			return linenumb;						               // Return number of lines parsed.
      }

		prt_error (term_symb[t]);				               // Print syntax error message. 
		return -linenumb;							               // Return negative number of lines for failure. 

Over: printf  ("\nParser stack overflow.\n\n");
		return -linenumb;							               // Return negative number of lines for failure. 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		reduce

int   c_parser::reduce (int p)
{
		if (pact_numb[p] >= 0)	  									// PARSE ACTION ?  
		{
			return (*pact_func [pact_numb[p]])(p);				// Call parse action with production number.
		}
		int psi;	 														// Parse Stack Index.
		if (node_numb[p] >= 0)   					            // MAKE NODE ?
		{
			if (n_nodes >= max_nodes)						      // If too many nodes?  
			{
				printf  (            "Number of AST nodes exceeds limit of %d.\n", max_nodes);
				fprintf (outputdesc, "Number of AST nodes exceeds limit of %d.\n", max_nodes);
				return (0);										
			}
			node[n_nodes].id     = node_numb[p];			   // Set node id. 
			node[n_nodes].prod   = p;							   // Put production (rule) number in node.
			node[n_nodes].prev   = 0;							   // Set prev to nonexistent.
			node[n_nodes].next   = 0;							   // Set next to nonexistent.
			node[n_nodes].child  = 0;							   // Set child to nonexistent.
			node[n_nodes].parent = 0;							   // Set parent to nonexistent.
			if (pact_arg[p] >= 0)				   		      // If first parse-action argument specified in grammar.
			{
				psi = arg_numb[pact_arg[p]]-1;	   	      // Get parse-stack index.
				node[n_nodes].sti  = PS[psi].sti;		      // Move sti from parse stack to node.
				node[n_nodes].line = PS[psi].line;	         // Move line from parse stack to node.
			} 
			else
			{
				node[n_nodes].sti  = 0;    					   // Set symbol-table index to zero.
				node[n_nodes].line = 0;    					   // Set line number to zero.
			}
			psi = linkup(p);									      // Linkup the nodes in this rule. 
			if (psi >= 0)										      // Any nodes found in this rule?
			{
				node[n_nodes].child = PS[psi].node;		      // Define child. 
				node[PS[psi].node].parent = n_nodes;         // Define parent.
				node[n_nodes].line = 0;								// Reset line number. 
			}
			PS[0].node = n_nodes;									// Define node in the parse stack.
			PS[0].last = n_nodes++;									// Define node in the parse stack.
		}  
		else	                                             // Check for nodes not linked?
		{
			psi = linkup (p);                               // Get parse-stack index.  
			if (psi > 0)                                    // If we have a node here ...
			{
				PS[0].node = PS[psi].node;		               // Move node value to 1st position.
				PS[0].last = PS[psi].last;		               // Move last value also.
			}
		}  
		return 1; // OK. 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		linkup

int   c_parser::linkup (int p)      
{
      int next = -1;
      int i;
      if (reverse[p] == 0)                               // IF NOT TO REVERSE THE ORDER. 
      {
         for (i = PL[p]; i >= 0; i--)				         // For each tail pointer. 
         {
            if (PS[i].node > 0)                          // If tail points to node.	  
            {
               if (next >= 0)                            // If one waiting.        
               {
                  node[PS[i].last].next = PS[next].node; // Define next node.
                  node[PS[next].node].prev = PS[i].last; // Define previous node.
                  PS[i].last = PS[next].last;            // Change last to next last.
               }
               next = i;									      // Next = Curr.  
				}
			}  
		}
      else                                               // REVERSE THE ORDER.
      {
         for (i = 0; i <= PL[p]; i++)				         // For each tail pointer. 
         {
            if (PS[i].node > 0)                          // If tail points to node.
            {
               if (next >= 0)                            // If one waiting.        
               {
                  node[PS[i].last].next = PS[next].node; // Define next node.
                  node[PS[next].node].prev = PS[i].last; // Define previous node.
                  PS[i].last = PS[next].last;            // Change last to next last.
               }
               next = i;									      // Next = Curr.  
				}  
			}  
		}
   // if (next >= 0) print_ast(PS[next].node);				// For debugging.
      return (next); 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    prt_error	

void  c_parser::prt_error (char *symb)
{       
      int  i, col, ln1, ln2;
      char string[256], *ls1, *ls2, *le1, *le2, *p, c;

	// Get first line number ...
      ln1 = linenumb;
		for (p = token.end-1; p > token.start; p--)
		{
			if (*p == '\n' || *p == 0) ln1--;
		}

	// Get first line start ...
		for (ls1 = token.start; *ls1 != '\n' && *ls1 != 0; ls1--); 
		ls1++;

	// Get first line end ...
		for (le1 = token.start; *le1 != '\n' && *le1 != 0; le1++);

	// Get last line number ...
      ln2 = linenumb;

	// Get last line start ...
		for (ls2 = token.end-1; *ls2 != '\n' && *ls2 != 0; ls2--); 
		ls2++;

	// Get last line end ...
		for (le2 = token.end; *le2 != '\n' && *le2 != 0; le2++);
		*le1 = 0;
		*le2 = 0;

		if (*token.start == '\n' || *token.start == 0) ln1--;

		printf  (            "\n%s(%d) : Error  %s\n", inputname, ln1, ls1);
		fprintf (outputdesc, "\n%s(%d) : Error  %s\n", inputname, ln1, ls1);
      *le1 = '\n'; // In case token is this <eol>

      col = 1;
      for (p = ls1; p < token.start; p++)   
      {
         if (*p == '\t') *p = ' ';
         col++;
      }
      for (i = 0; i < col; i++) string[i] = '-';
      string [col] = 0;
		printf  (            "%s(%d) : Error %s^ ", inputname, ln1, string);
		fprintf (outputdesc, "%s(%d) : Error %s^ ", inputname, ln1, string);

      if (*token.start <= 32) 
      {
         int x = *token.start;
         if (x < 0) x += 256;
         printf  (            "at \\%d %s\n\n", x, symb);
         fprintf (outputdesc, "at \\%d %s\n\n", x, symb);
      }
      else
      {
         if (token.end == token.start) token.end++;
         if (token.end > le1) 
         {
				if (*token.start == '\n') *token.start = 0;
            if (*token.end   == EOF_CHAR) linenumb--;
            c = *le1; 
            *le1 = 0;
            printf  (            "starts here\n");
            fprintf (outputdesc, "starts here\n");
				printf  (            "\n%s(%d) : Error  %s\n", inputname, ln2, ls2);
				fprintf (outputdesc, "\n%s(%d) : Error  %s\n", inputname, ln2, ls2);
				col = 1;
				for (p = ls2; p < token.end; p++)   
				{
					if (*p == '\t') *p = ' ';
					col++;
				}
				for (i = 0; i < col; i++) string[i] = '-';
				string [col] = 0;
				printf  (            "%s(%d) : Error %s^ ", inputname, ln2, string);
				fprintf (outputdesc, "%s(%d) : Error %s^ ", inputname, ln2, string);
				printf  (            "ends here.\n\n");
				fprintf (outputdesc, "ends here.\n\n");
            *le1 = c;
         }
         else
         {
            c = *token.end; 
            *token.end = 0;
				if (*token.start == '\n') *token.start = 0;
            printf  (            "at %s %s\n\n", token.start, symb);
            fprintf (outputdesc, "at %s %s\n\n", token.start, symb);
            *token.end = c;
         }
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		expecting // Print expecting list. 

void  c_parser::expecting (int state)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		collect: Collect terminals that cause a transition or reduction.			                     

void	c_parser::collect (int x) 
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    prt_prod                                                                                     

void	c_parser::prt_prod (int p)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    init_symtab

int   c_parser::init_symtab (int max_symb) 
{
      int i; 
		if (max_symb <= 0) 
		{	
			printf  (            "Maximum number of symbols cannot be zero or negative.\n");
			fprintf (outputdesc, "Maximum number of symbols cannot be zero or negative.\n");
			return (0);
		}
		max_symbols   = max_symb;
		max_cells     = 2*max_symbols;
		symbol        = new Symbol[max_symbols];
      hashvec       = new int[max_cells];
      hashdiv       = UINT_MAX / max_cells + 1;
      n_symbols	  = 0;
      n_keywords	  = 0;
      if (symbol == NULL || hashvec == NULL)
      {
			printf  (            "Not enough memory available for Symbol Table.\n");
			fprintf (outputdesc, "Not enough memory available for Symbol Table.\n");
         return (0); // Return error.
      }
      for (i = 0; i < max_cells; i++) 
		{
			hashvec[i] = -1;
		}
		return (1); // Return OK.
}
													        
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    term_symtab

void  c_parser::term_symtab () 
{
      delete [] symbol;
      delete [] hashvec;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    add_symb - add symbol to table.     											                        

int	c_parser::add_symbol (int t, char* token_start, char* token_end) 
{
		sti = get_symbol (token_start, token_end);
		if (sti < 0) 
		{
			sti = n_symbols;
			if (n_symbols >= max_symbols)				// Reached maximum number? 
			{
				printf  (            "Number of symbols exceeds %d.\n", max_symbols);
				fprintf (outputdesc, "Number of symbols exceeds %d.\n", max_symbols);
				return (0); // Return error.
			}
			hashvec[cell] = n_symbols;					// Put symbol number into hash vector.     
			symbol[n_symbols].name = token_start;	// Define pointer to symbol name.
			symbol[n_symbols].length = length;		//	Define symbol name length.
			symbol[n_symbols].term = t;				// Define terminal number (<identifier>, <string>, <number>, ...)
			symbol[n_symbols].type = 0;				// Define type as undefined (zero).
			symbol[n_symbols].cell = cell;			// Define hash vector cell number for this symbol.
			n_symbols++;									// Increment number of symbols.
		}
      return (sti);										// Return symbol-table index.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    get_symbol - get symbol number from table.									                        

int   c_parser::get_symbol (char* token_start, char* token_end) 
{
      char* p = token_start;					 		// Point at start.
      length  = token_end - token_start;  		// Set length. 
      uint hash = length;         	   			// Set hash to length. 
      int i = 0;						   				// Set shift value to 0.
      do									      			// Assume length != 0
      {
         hash += *p << i;
         i += 4;		                  			
         i %= 32;
      }
      while (++p < token_end);
      cell = hash % max_cells; 						// Get first cell.
		i = hashvec [cell];				   			// Get symbol index.
      if (i >= 0) 
		{
			p = token_start;						   	// Point at token start.
			do
			{
				if (symbol[i].length == length)		// If lengths are equal ...
				{
					char* q = symbol[i].name;			// Point at symbol name.
					int j = 0; 
					do 
					{
						if (p[j] != q[j]) goto Cont;	// If characters not equal ...		
					}
					while (++j < length);				// while end not reached. 
					return (i);								// Found it.
				}
	Cont:    cell = (hash *= 65549)/hashdiv;		// Get new cell number.
				i = hashvec [cell];						// Get symbol index.
			}
			while (i >= 0);      						// While not empty slot.
		}
      return (i);											// Return symbol number.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    print - print symbol table contents.     										                        

void  c_parser::print_symtab (char* term_symb[])
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    symname - get symbol name. 

char* c_parser::symbol_name (int i)
{
      char* p;
      int L;
      static char name[100];
		if (i == 0) 
		{
			name[0] = 0;
		}
		else
		{
			p = symbol[i].name;
			L = symbol[i].length;
			if (L >= 100) 
			{
				L = 95;
				for (i = 0; i < L; i++) name[i] = p[i];
				name[i++] = ' ';
				name[i++] = '.';
				name[i++] = '.';
				name[i++] = '.';
				name[i] = 0;
			}
			else
			{
				for (i = 0; i < L; i++) name[i] = p[i];
				name[i] = 0;
			}
		}
      return name;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//																										                     // 
//    ABSTRACT-SYNTAX-TREE FUNCTIONS														                     

      static uchar numeric[256] = /* numeric[x] gives 1..10 for digits 0..9 */
      {
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      1,  2,  3,  4,  5,  6,  7,  8,  9, 10,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 
      };

      Stack* AST::stack;
      int    AST::stacki;

		char draw_plus [] = "+ ";                     
		char draw_vbar [] = "| ";
		char draw_last [] = "+ ";
		char draw_space[] = "  ";

      int*  AST::counter;
      char  AST::indent[256];

      static int space_before = 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    init_ast                                                                                     

int   c_parser::init_ast (int Max_nodes)
{
		max_nodes = Max_nodes;
		if (max_nodes <= 0) 
		{	
			printf  (            "Maximum number of AST nodes cannot be %d.\n", max_nodes);
			fprintf (outputdesc, "Maximum number of AST nodes cannot be %d.\n", max_nodes);
         return (0); // Return error.
		}
		node = new Node[max_nodes]; 
      if (node == NULL)
      {
			printf  (            "Not enough memory available for %d AST nodes.\n", max_nodes);
			fprintf (outputdesc, "Not enough memory available for %d AST nodes.\n", max_nodes);
         return (0); // Return error.
      }
		root           =  0;	// In case of internal error.
      node[0].id     = -1; // Undefined.
      node[0].prod   =  0;          
      node[0].sti    =  0;          
      node[0].line   =  0;								
      node[0].next   =  0;          
      node[0].prev   =  0;							   
      node[0].child  =  0;          
      node[0].parent =  0;							   
      n_nodes        =  1;  
		return (1); // Return OK.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    term_ast                                                                                     

void  c_parser::term_ast ()
{
		delete [] node;
      delete [] stack;
      delete [] counter;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    print_ast ()                                                                                 

void  c_parser::print_ast ()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    print_ast (n)                                                                                

void  c_parser::print_ast (int n) // Print subtree.
{
		if (n < n_nodes && n > 0)
		{
	      char indent [512];
			strcpy (indent, draw_space);
			fprintf (outputdesc, "Abstract Syntax Tree ...\n\n");
			fprintf (outputdesc, "  node  prev  next parent child  line   sti \n");

			traverse (indent, n); // Start AST traversal.    
			fprintf (outputdesc, "\n");
		}
		else 
      {
         fprintf (outputdesc, "Internal error, node %d is not in AST.\n\n", n);
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse                                                                                     

void  c_parser::traverse (char *indent, int n)
{
      while (node[n].next > 0)                
      {
         strcat (indent, draw_plus); 
         print_node (indent, n);                
         indent [strlen(indent)-2] = 0;
         if (node[n].child > 0)                
         {
            strcat (indent, draw_vbar);
            traverse (indent, node[n].child);  
            indent [strlen(indent)-2] = 0;
         }
         n = node[n].next;                    
      }

      strcat (indent, draw_last); 
      print_node (indent, n);                   
      indent [strlen(indent)-2] = 0;
      if (node[n].child > 0)                   
      {
         strcat (indent, draw_space); 
         traverse (indent, node[n].child);     
         indent [strlen(indent)-2] = 0;
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    print_node                                                                                   

void  c_parser::print_node (char *indent, int n)  /* Print this node function. */
{
}

static char spaces[100];

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    traverse                                                                                     

void  c_parser::traverse ()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse (n)                                                                                 

void  c_parser::traverse (int n)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    emitstr
  
int   c_parser::emitstr (int n, char* str) 
{
		return (0);
}

//                                                                                                 // 
/////////////////////////////////////////////////////////////////////////////////////////////////////

