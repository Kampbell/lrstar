
#ifdef LRSTAR

@("char", "uchar", "short", "ushort", "int", "uint", "char*")
@//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    @grm_name;Parser.

/*    Generated by: @program; @version;
      Grammar:      @grm_file;
      Skeleton:     @skl_file;
      Output:       @out_file;
*/
      #include "ComGlobal.h"
  		#include "@grm_name;Parser.h"
  		#include "PGActions.h"

		#define STKSIZE        1000 // Parser stack size.
		#define ACCEPT_STATE	@accp_sta.6d; // Final state.
      #define LOOKAHEADS        2

/*--- Constants. -------------------------------------------------------------*/

      int		@grm_name;Parser::n_terms      = @numb_term.5d;; // No. of terminals.
      int		@grm_name;Parser::n_heads      = @numb_head.5d;; // No. of non-terminals.
      int		@grm_name;Parser::n_prods      = @numb_prod.5d;; // No. of productions.
      int		@grm_name;Parser::n_states     = @numb_sta. 5d;; // No. of states.
      int		@grm_name;Parser::eol_symb     = @eol_numb. 5d;; // EOL symbol number
      int		@grm_name;Parser::eof_symb     = @eof_numb. 5d;; // EOF symbol number
      int		@grm_name;Parser::err_used     = @err_used. 5d;; // <error> used in grammar
		int		@grm_name;Parser::N_args;
		int*		@grm_name;Parser::F_narg;
		int*		@grm_name;Parser::Arg_numb;
		int    	@grm_name;Parser::N_strings;
		int    	@grm_name;Parser::N_tails;
		int    	@grm_name;Parser::N_terms;
		int*   	@grm_name;Parser::Node_numb;
		int*   	@grm_name;Parser::Nact_numb;
		char** 	@grm_name;Parser::Node_start;
		char** 	@grm_name;Parser::Nact_start;
		int    	@grm_name;Parser::N_heads;
		int    	@grm_name;Parser::N_generated;
		int    	@grm_name;Parser::N_nodes;
		int    	@grm_name;Parser::N_tacts;  // token actions.
		int    	@grm_name;Parser::N_pacts;  // parsing actions (total).
		int    	@grm_name;Parser::N_nacts;
		int    	@grm_name;Parser::N_ints;
		int    	@grm_name;Parser::N_prods;
	   char**	@grm_name;Parser::Str_start;
		int*		@grm_name;Parser::f_eri;
		int*		@grm_name;Parser::F_targ;
		int*		@grm_name;Parser::F_parg;
		int*		@grm_name;Parser::F_prod;
	   int*		@grm_name;Parser::eri_prod;
		int*		@grm_name;Parser::eri_dot;
		int		@grm_name;Parser::n_eris;
	   char**	@grm_name;Parser::Tact_start;
		int*		@grm_name;Parser::Tact_numb;
	   int*		@grm_name;Parser::Reverse;
		int		@grm_name;Parser::opt_states;
		int*     @grm_name;Parser::Oper_prec;
		char*    @grm_name;Parser::Prec;
		char**   @grm_name;Parser::Pact_start;
		int*     @grm_name;Parser::Pact_numb;
	   int*     @grm_name;Parser::Defcon_value;
		char**   @grm_name;Parser::Defcon_name;
		int      @grm_name;Parser::eol_term;
		int      @grm_name;Parser::eof_term;
		int      @grm_name;Parser::error_sym_used;
		int      @grm_name;Parser::make_ast;
	   int      @grm_name;Parser::keyword_sym;
		int      @grm_name;Parser::n_constants;

/*--- Terminal and Nonterminal Symbols of the Grammar. -----------------------*/

   // Terminal symbols of the grammar.
      @term_symb.t; @grm_name;Parser::term_symb[@term_symb.d;] =
      {
         @term_symb.1|"%s"|,|,\n         |;
      };

@optn_debug.ge.2;...
   // Head symbols of the grammar.
      @head_symb.t; @grm_name;Parser::head_symb[@head_symb.d;] =
      {
         @head_symb.1|"%s"|,|,\n         |;
      };

   // Head symbol for a production
      @prod_head.t; @grm_name;Parser::head_numb[@prod_head.d;] =
      {
      @prod_head.20|%5d|,|,\n      |;
      };

   // Index to first tail symbol for a production
      @prod_tail.t; @grm_name;Parser::f_tail[@prod_tail.d;] =
      {
      @prod_tail.20|%5d|,|,\n      |;
      };

   // Tail symbol numbers (T: >= 0, NT: < 0)
      @tail_numb.t; @grm_name;Parser::tail[@tail_numb.d;] =
      {
      @tail_numb.20|%5d|,|,\n      |;
      };

@@
/*--- Bit Matrix and Access Vectors. -----------------------------------------*/

   // B_matrix.
      @bmat_numb.t; @grm_name;Parser::Bm [@bmat_numb.d;] =
      {
      @bmat_numb.20|%5d|,|,\n      |;
      };

   // B_matrix row.
      @bmat_row.t; @grm_name;Parser::Br [@bmat_row.d;] =
      {
      @bmat_row.20|%5d|,|,\n      |;
      };

   // B_matrix column.
      @bmat_col.t; @grm_name;Parser::Bc [@bmat_col.d;] =
      {
      @bmat_col.20|%5d|,|,\n      |;
      };

   // B_matrix mask.
      @bmat_mask.t; @grm_name;Parser::Bmask [@bmat_mask.d;] =
      {
      @bmat_mask.20|%5d|,|,\n      |;
      };

/*--- Terminal Transition Matrix and Access Vectors. ------------------------*/

   // T_matrix.
      @tmat_numb.t; @grm_name;Parser::Tm [@tmat_numb.d;] =
      {
      @tmat_numb.20|%5d|,|,\n      |;
      };

   // T_matrix row.
      @tmat_row.t; @grm_name;Parser::Tr [@tmat_row.d;] =
      {
      @tmat_row.20|%5d|,|,\n      |;
      };

   // T_matrix column.
      @tmat_col.t; @grm_name;Parser::Tc [@tmat_col.d;] =
      {
      @tmat_col.20|%5d|,|,\n      |;
      };

/*--- Nonterminal Transition Matrix and Access Vectors. ---------------------*/

   // N_matrix.
      @nmat_numb.t; @grm_name;Parser::Nm [@nmat_numb.d;] =
      {
      @nmat_numb.20|%5d|,|,\n      |;
      };

   // N_matrix row.
      @nmat_row.t; @grm_name;Parser::Nr [@nmat_row.d;] =
      {
      @nmat_row.20|%5d|,|,\n      |;
      };

   // N_matrix column.
      @nmat_col.t; @grm_name;Parser::Nc [@nmat_col.d;] =
      {
      @nmat_col.20|%5d|,|,\n      |;
      };

/*--- Reduction Matrix and Access Vectors. ----------------------------------*/

   // R_matrix.
      @rmat_numb.t; @grm_name;Parser::Rm [@rmat_numb.d;] =
      {
      @rmat_numb.20|%5d|,|,\n      |;
      };

   // R_matrix row.
      @rmat_row.t; @grm_name;Parser::Rr [@rmat_row.d;] =
      {
      @rmat_row.20|%5d|,|,\n      |;
      };

   // R_matrix column.
      @rmat_col.t; @grm_name;Parser::Rc [@rmat_col.d;] =
      {
      @rmat_col.20|%5d|,|,\n      |;
      };

@nd_action?;...
/*--- Nondeterministic Parsing Arrays. --------------------------------------*/

   // Nondeterministic Start.
      @nd_start.t; @grm_name;Parser::nd_start [@nd_start.d;] =
      {
      @nd_start.20|%5d|,|,\n      |;
      };

   // Nondeterministic Terminal Symbol.
      @nd_term.t; @grm_name;Parser::nd_term [@nd_term.d;] =
      {
      @nd_term.20|%5d|,|,\n      |;
      };

   // Nondeterministic Action.
      @nd_action.t; @grm_name;Parser::nd_action [@nd_action.d;] =
      {
      @nd_action.20|%5d|,|,\n      |;
      };

@@
@numb_tact?;...
/*--- Token Variables --------------------------------------------------------*/

	// Token Action number.
      @tact_numb.t; @grm_name;Parser::tact_numb[@tact_numb.d;] =
      {
      @tact_numb.20|%5d|,|,\n      |;
      };

   // Token Action Function Pointers.
      int (*@grm_name;Parser::tact_func[@tact_func.d;]) (int) =
      {
			@tact_func.1|PGTokenAction::%s|,|,\n         |;
      };

@optn_debug.ge.2;...
   // Token Action Names.
      char* @grm_name;Parser::tact_name[@tact_func.d;] =
      {
         @tact_func.1|"%s"|,|,\n         |;
		};

@@
   // First argument index for token actions.
      @tact_arg.t; @grm_name;Parser::tact_arg[@tact_arg.d;] =
      {
      @tact_arg.20|%5d|,|,\n      |;
      };

@@ 
/*--- Production Information. -----------------------------------------------*/

   // Production length - 1
      @prod_leng.t; @grm_name;Parser::PL[@prod_leng.d;] =
      {
      @prod_leng.20|%5d|,|,\n      |;
      };

   // Reverse the order of nodes (for a production/rule).
      @prod_revs.t; @grm_name;Parser::reverse[@prod_revs.d;] =
      {
      @prod_revs.20|%5d|,|,\n      |;
      };

   // First argument index for parse actions and make node.
      @pact_arg.t; @grm_name;Parser::pact_arg[@pact_arg.d;] =
      {
      @pact_arg.20|%5d|,|,\n      |;
      };

@numb_pact?;...
   // Action for a production
      @pact_numb.t; @grm_name;Parser::pact_numb[@pact_numb.d;] =
      {
      @pact_numb.20|%5d|,|,\n      |;
      };

   // Parsing Action Function Pointers.
      int (*@grm_name;Parser::pact_func[@pact_func.d;]) (int) =
      {
			@pact_func.1|PGParseAction::%s|,|,\n         |;
      };

@optn_debug.ge.2;...
   // Parsing Action Names.
      char* @grm_name;Parser::pact_name[@pact_func.d;] =
      {
         @pact_func.1|"%s"|,|,\n         |;
		};

@@
@@ 
@numb_tact.ne.0.or.@numb_pact.ne.0.or.@numb_nact.ne.0;...
/*--- @grm_name;Parser Argument Variables. --------------------------------------------*/

   // Parse action argument numbers
      @arg_numb.t; @grm_name;Parser::arg_numb[@arg_numb.d;] =
      {
      @arg_numb.20|%5d|,|,\n      |;
      };

@arg_text?;...
   // Text for string arguments (including node arguments).
      @arg_text.t; @grm_name;Parser::arg_text[@arg_text.d;] =
      {
         @arg_text.1|"%s"|,|,\n         |;
      };

@@
@@
@make_ast?;...
/*--- Node Variables --------------------------------------------------------*/

   // Node numbers (for a production).
      @node_numb.t; @grm_name;Parser::node_numb[@node_numb.d;] =
      {
      @node_numb.20|%5d|,|,\n      |;
      };

@optn_debug?;...
	// Node names.
      @node_name.t; @grm_name;Parser::node_name[@node_name.d;] =
      {
         @node_name.1|"%s"|,|,\n         |;
      };

@@
@numb_nact?;...
   // Node action numbers.
      int AST::nact_numb[@nact_numb.d;] =
      {
      @nact_numb.20|%5d|,|,\n      |;
      };

	// Node processor function pointers.
      int (*AST::nact_func[@nact_func.d;]) (Node* np) =
      {
			@nact_func.1|PGNodeAction::%s|,|,\n         |;
      };

@optn_debug.ge.2;...
   // Node Action Names.
      char* @grm_name;Parser::nact_name[@nact_func.d;] =
      {
         @nact_func.1|"%s"|,|,\n         |;
		};

@@
   // First argument index for node actions.
      @nact_arg.t; @grm_name;Parser::nact_arg[@nact_arg.d;] =
      {
      @nact_arg.20|%5d|,|,\n      |;
      };

@@ 
@@ 
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    LRSTAR Parser.

	// Parser stuff ...
		PStack*  @grm_name;Parser::PS;
		PStack*  @grm_name;Parser::PS_end;
      PStack   @grm_name;Parser::P_stack[STKSIZE];
		int      @grm_name;Parser::max_errs;
		int		@grm_name;Parser::prev_token;
		int		@grm_name;Parser::goal_symbol;
		int		@grm_name;Parser::start_symbol;
		int		@grm_name;Parser::codeblock = 0;

@restore?;...
	// Restore stack stuff ...
      RStack*	@grm_name;Parser::RS;
      RStack	@grm_name;Parser::R_stack[STKSIZE];
  		PStack*  @grm_name;Parser::PStop;
  		int      @grm_name;Parser::topstate;

@@
@optn_exp?;...
	// Syntax analysis stuff ...
		char*    @grm_name;Parser::T_list;
		int*     @grm_name;Parser::P_list;

@@
	// Symbol table stuff ...
      Symbol*  Symtab::symbol;
		int      Symtab::sti;
		short    Symtab::length;
		int      Symtab::n_symbols;
		uint     Symtab::hashdiv;
		int*		Symtab::hashvec;
		int      Symtab::cell;
		int		Symtab::max_cells;
		int      Symtab::max_symbols;

@make_ast?;...
	// AST stuff ...
		Node*    AST::node;
		Node*    AST::root;
		Node*    AST::currnode;
      int*     AST::counter;
      char     AST::indent[256];
      Stack*   AST::stack;
      short    AST::stacki;
      char**   AST::term_symb;
      int      AST::n_nodenames = @numb_node.5d;;	// Number of node names.
      int      AST::n_nodeactions = @numb_nact.5d;;	// Number of node actions.
      int      AST::n_nodes;
		short    AST::status;
		short    AST::pass;

@@
@optn_debug?;...
		char* filter (char* text);

@@
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    initialize -  initialize

void  @grm_name;Parser::initialize (int max_symb)
{
      int  sti;
      char *p, sym[256];
      int  t, len, terminal;

		init_symtab (max_symb);                            // Initialize the symbol table.
@make_ast?;...
		init_ast ();                                       // Initialize the AST.
@@
		p = "";
		sti = add_symbol (0, p, p+1, 0, 0);              	// Add blank symbol as number 0.
      symbol[sti].value = -1;

	// See if lexer can read the 'literal' terminal symbols.
		n_errors = 0;
		for (t = 1; t < n_terms; t++)		                  // For all terminals except <error> (0).
		{
			if (*term_symb[t] == '\'')                      // Literal symbol?
			{
   			len = -1;
				for (p = term_symb[t]+1; *p != 0; p++)       // For all characters in terminal symbol.
				{
					if (++len > 255)                          // If length greater than 255 ...
					{
						n_errors++;
						printf ("Terminal symbol is longer than 255 characters:\n%s\n\n", term_symb[t]);
						Terminate(0);
					}
					sym[len] = *p;                            // Move character to sym.
				}
				sym[len]  = 26;					               // Replace last ' with end-of-file character.
				token.end = sym;				                  // Starting point for next @grm_name;Lexer read.
				terminal  = get_token();		               // Try to read symbol, get it's terminal number.
				sym[len]  = '\'';				                  // Replace end-of-file with '.
				if ((token.end-token.start) != len)          // Did not read the whole symbol?
				{
					n_errors++;
					printf ("Lexer was not able to recognized %s\n", term_symb[t]);
				}
				else if (terminal != t)			               // Terminal number not t?, must be a keyword!
				{
					if (terminal == 0)		                  // Got an error on this symbol?
					{
						n_errors++;
						printf ("Lexer returns zero for %s (check reduce-reduce conflicts).\n", term_symb[t]);
					}
					add_symbol (t, term_symb[t]+1, term_symb[t]+1+len, 0, 0); // Put terminal into symbol table.
				}
			}
		}
		if (n_errors) Terminate(0);

	// Initialize some stuff.
      n_errors   = 0;
      n_warnings = 0;
      max_errs   = 10;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		terminate

void  @grm_name;Parser::terminate ()
{
@make_ast?;...
		term_ast  ();
@@
		term_symtab ();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		parse

int   @grm_name;Parser::parse (char* input_start)
{
      int    p;                                          // Production (rule) number.
      int    t = 0;                                      // Terminal symbol number.
      int    x = 0;                                      // State number.

@nd_action?;...
      PStack *P;
      int    *SS, *SS_end;
      int    S_stack[STKSIZE];
      int    max_nla, nla, action;
      SS_end = S_stack + STKSIZE;

@@
      PS     = P_stack;							               // Set parse-stack pointer.
      PS_end = P_stack + STKSIZE;			               // Set parse-stack end pointer.
		init_lexer (input_start);				               // Initialize @grm_name;Lexer.
		goal_symbol = 0;												// Not seen yet.
@optn_debug.ge.2;...
      prt_log ("\n");
@@
/*		prev_token = t;												// Define previous token.
    	t = get_token ();							               // Get first token.
@restore?;...
      RS = R_stack;                                      // Set restore-stack pointer.
		PStop = PS;								                  // Save parse-stack pointer.
		topstate = x;								               // Save current state.
@@
		if (t == 0) goto Err;										// Bad token!
		goto Cont;
*/
Read:	prev_token = t;												// Define previous token.
		t = get_token ();							               // Get incoming token.
@restore?;...
      RS = R_stack;                                      // Set restore-stack pointer.
		PStop = PS;								                  // Save parse-stack pointer.
		topstate = x;								               // Save current state.
@@
Cont:
@err_used?;...
		short error_mode = 0;					               // Error mode for parsing <error> symbols.
@@
@optn_debug.ge.2;...
      prt_line ();
  	  	char ch = *token.end;
		*token.end = 0;
      prt_log ("      %s %s", token.start, term_symb[t]);
  		*token.end = ch;
@@
		token.sti = -t;							               // Point at terminal symbol.
@numb_tact?;...									               // Token actions?
      if (tact_numb[t] >= 0)					               // If token action ...
      {
@optn_debug.ge.2;...
	  		prt_log (" => %s()", tact_name [tact_numb[t]]);
@@
         t = (*tact_func [tact_numb[t]])(t);             // Call token-action function.
@optn_debug.ge.2;...
  			prt_log (" %s", term_symb[t]);
@@
      }
@optn_debug.ge.2;...
  		prt_log ("\n\n");
@@
@@
@numb_tact!;...									               // Token actions?
      if (t == 0 && token.start == token.end) token.end++;
@@

Shft: if (Bm [Br[x] + Bc[t]] & Bmask[t])	               // Check B-matrix for shift action.
      {
@optn_debug.ge.2;...
	  		prt_log ("         shift\n");
@@
			if (++PS >= PS_end) goto Overflow;
         PS->state = x;                                  // Put current state on stack.
         PS->sti   = token.sti;                          // Put token symbol table index on stack.
         PS->start = token.start;                        // Put token.start into parse stack.
         PS->end   = token.end;                          // Put token.end   into parse stack.
         PS->line  = token.line;                         // Put its line number on stack.
         PS->node  = NULL;			   	                  // Set node on stack to null.
@optn_debug.ge.2;...
         PS->sym   = t;							               // Put terminal number on stack.
			prt_stack ();                                   // Print the parse stack.
@@
         x = Tm [Tr[x] + Tc[t]];                         // Get next state from terminal transition matrix.
         while (x <= 0)                                  // While shift-reduce actions.
         {
@nd_action?;...
NTT:        // Nonterminal transition ...
@@
            PS -= PL[-x];                                // Reduce stack ptr by production length.
@optn_debug.ge.2;...
		  		prt_prod (-x);                               // Print this production (rule).
@@
			  	if (reduce_action(-x) != 0) return -line_numb;  // Call reduce action with rule number.
@optn_debug.ge.2;...
				PS->sym = -head_numb[-x];		               // Put nonterminal number on stack.
				prt_stack ();                                // Print the parse stack.
@@
            x = Nm [Nr[PS->state] + Nc[-x]];             // Get next state from nonterminal transition.
         }
@optn_debug.ge.2;...
	  		prt_log ("         goto    %8d\n\n", x);
@@
         goto Read;								               // Go to read next token.
      }

		if ((p = Rr[x]) > 0 || (p = Rm [Rc[t] - p]) > 0)   // Get reduction?
      {
@nd_action?;...
Nulred:  // Null reduction ...
@@
         if (PL[p] < 0)							               // Null production?
         {
				if (++PS >= PS_end) goto Overflow;
@restore?;...
				RS++;									               // Increment the restore stack pointer.
				RS->ptr   = PS;					               // Save parse-stack pointer.
     		   RS->state = PS->state;			               // Save old state before replacing it.
@@
            PS->state = x;						               // Stack current state, replacing old state.
            PS->node  = NULL;					               // Clear node pointer.
            PS->sti   = 0;					                  // Clear sti.
				goto Red2;
         }
         while (1)
         {
            PS -= PL[p];                                 // Reduce parse stack ptr by rule length - 1.
@optn_debug.ge.2;...
				prt_prod (p);                                // Print this production (rule).
@@
Red2:		// Reduce action ...
			  	if (reduce_action(p) != 0) return -line_numb; // Call reduce action with rule number.
@optn_debug.ge.2;...
				PS->sym = -head_numb[p];		               // Put nonterminal number on stack.
				prt_stack ();                                // Print the parse stack.
@@
            x = Nm [Nr[PS->state] + Nc[p]];	            // Get next state from nonterminal transition.
@optn_debug.lt.2;...
            if (x > 0) goto Shft;                        // Continue parsing.
@@
@optn_debug.ge.2;...
            if (x > 0)
            {
      	  		prt_log ("         goto    %8d\n", x);
               goto Shft;                                // Continue parsing.
            }
@@
            p = -x;								               // Set production number.
         }
      }

		if (codeblock) 
		{ 
			t = 0; 
			goto Shft; 
		}

@nd_action?;...
      max_nla = 0;
		for (int i = nd_start[x]; i < nd_start[x+1]; i++)
		{
         if (nd_term[i] == t)
         {
            for (SS = S_stack, P = P_stack; P < PS;) *++SS = (++P)->state;
            nla = nd_parse (S_stack, SS, SS_end, x, t, nd_action[i]);
            if (nla > max_nla)
            {
               max_nla = nla;
               action = nd_action[i];
            }
         }
      // else if (nd_term[i] > t) break; // nd_term is sorted, so we are done.
		}
      if (max_nla > 0)
      {
         if (action > 0)                                    // Shift and Goto?
         {
      	   if (++PS >= PS_end) goto Overflow;
            PS->state = x;                                  // Put current state on stack.
            if (action > ACCEPT_STATE)                      // Shift and reduce?
            {
               x = ACCEPT_STATE - action;
               goto NTT;                                    // Reduce.
            }
            x = action;                                     // Get next state.
            goto Read;
         }
         else
         {
            p = -action;                                    // Get production.
            goto Nulred;                                       // Reduce.
         }
      }

@@
      if (x == ACCEPT_STATE)					               // If Goal production.
      {
         PS -= PL[p];                                    // Reduce parse stack ptr by rule length - 1.
@optn_debug.ge.2;...
	      prt_prod (p);                                   // Print this production (rule).
@@
			if (reduce_action(p) != 0) return -line_numb;   // Call reduce action with rule number.
			line_numb--;			      	                  // Reduce line number by one.
         if (n_errors) return -line_numb;
			root = PS[0].node;                              // Define root node.
@optn_debug.ge.2;...
	  		prt_log ("         done    %8d lines read.\n\n", line_numb);
@@

@optn_debug?;...
		   print_ast (term_symb);
@@
         pass = FIRST_PASS;
  		   traverse ();
         if (n_errors) return -line_numb;

@optn_debug?;...
		   print_ast (term_symb);
@@
         pass = SECOND_PASS;
		   traverse ();
         if (n_errors) return -line_numb;

@optn_debug?;...
		   print_ast (term_symb);
@@
         pass = THIRD_PASS;
		   traverse ();
         if (n_errors) return -line_numb;
@optn_debug?;...

         prt_log ("\n");
		   print_ast (term_symb);
		   print_symtab (term_symb);
@@
			return line_numb;
      }

@err_used?;...
		short T;										               // Saved terminal number.
  		if (error_mode == 0) 					               // If not in error mode, try to parse <error> symbol.
		{
			error_mode = 1;						               // Turn on error mode.
     		for (PS = PStop; RS > R_stack; RS--) RS->ptr->state = RS->state;
			x = topstate;							               // Set state to last state before reductions.
			T = t;									               // Save current token's terminal number.
			t = 0;									               // Set terminal number to <error>.
			goto Shft;								               // Go for it, see what happens.
		}
		t = T;										               // Reset t to the original terminal number.
@@
Err:	syntax_error (term_symb[t]);			               // Print syntax error message.
@optn_exp?;...
		expecting ();								               // Print syntax help (list of tokens expected).
@@
		return -line_numb;						               // Return negative number of lines for failure.

Overflow:                                                // Parser stack overflow.
		prt_log ("\nInternal error, Parser stack overflow.\n\n");
		return -line_numb;
}

@nd_action?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		nd_parse - nondeterministic parse

int   @grm_name;Parser::nd_parse (int* P_stack, int* PS, int* PS_end, int x, int t, int action)
{
      int   p, lookaheads;
      char* TS = token.start;
      char* TE = token.end;
      int   LN = line_numb;

      int   *P;
      int   max_nla, nla;
      int   *SS, *SS_end;
      int   S_stack[STKSIZE];
      SS_end  = S_stack + STKSIZE;

      lookaheads = 0;
Act:  if (action > 0)                                    // Shift and Goto?
      {
      	if (++PS >= PS_end) goto Overflow;
         if (++lookaheads == LOOKAHEADS) goto Ret;
         *PS = x;                                        // Put current state on stack.
         if (action > ACCEPT_STATE)                      // Shift and reduce?
         {
            x = ACCEPT_STATE - action;
            goto NTT;                                    // Reduce.
         }
         x = action;                                     // Get next state.
         goto Read;
      }
      else
      {
         p = -action;                                    // Get production.
         goto Nulred;                                    // Reduce.
      }

Read:	prev_token = t;												// Define previous token.
		t = get_token ();							               // Get first token.

Shft: if (Bm [Br[x] + Bc[t]] & Bmask[t])	               // Check B-matrix for shift action.
      {
      	if (++PS >= PS_end) goto Overflow;
         if (++lookaheads == LOOKAHEADS) goto Ret;

         *PS = x;                                        // Put current state on stack.
         x = Tm [Tr[x] + Tc[t]];                         // Get next state from terminal transition matrix.
         while (x < 0)                                   // While shift-reduce actions.
         {
NTT:        PS -= PL[-x];                                // Reduce stack ptr by production length.
            x = Nm [Nr[*PS] + Nc[-x]];	                  // Get next state from nonterminal transition matrix.
         }
         goto Read;								               // Go to read next token.
      }

    	if ((p = Rr[x]) > 0 || (p = Rm [Rc[t] - p]) > 0)   // Get reduction?
      {
Nulred:  // Null reduction ...
         if (PL[p] < 0)							               // Null production?
         {
				if (++PS >= PS_end) goto Overflow;
            *PS = x;						                     // Stack current state, replacing old state.
				goto Red;
         }
         while (1)
         {
            PS -= PL[p];                                 // Reduce parse stack ptr by rule length - 1.
Red:		// Reduce action ...
            x = Nm [Nr[*PS] + Nc[p]];	                  // Get next state from nonterminal transition.
            if (x > 0) goto Shft;			               // If a state, continue parsing.
            p = -x;								               // Make the production number positive.
         }
      }

      max_nla = 0;
		for (int i = nd_start[x]; i < nd_start[x+1]; i++)
		{
         if (nd_term[i] == t)
         {
            for (SS = S_stack, P = P_stack; P < PS;) *++SS = *++P;
            nla = nd_parse (S_stack, SS, SS_end, x, t, nd_action[i]);
            if (nla > max_nla)
            {
               max_nla = nla;
               action = nd_action[i];
            }
         }
      // else if (nd_term[i] > t) break; // nd_term is sorted, so we are done.
		}
      if (max_nla > 0) goto Act;

      if (x == ACCEPT_STATE)					               // If Goal production.
      {
         lookaheads = LOOKAHEADS;
      }

Ret:  token.start = TS;
      token.end   = TE;
      line_numb    = LN;
      return lookaheads;                                 // Syntax error, return zero lookaheads.

Overflow:
		printf  (                 "\nInternal error, parser stack overflow.\n\n");
		exit (0);
}

@@
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		reduce_action

int   @grm_name;Parser::reduce_action (int p)
{
		if (pact_numb[p] >= 0)	  							// PARSE ACTION ?
		{
			int rc;												// Return code.
@optn_debug.ge.2;...
	  		prt_log ("         call action      %s()\n", pact_name [pact_numb[p]]);
@@
			rc = (*pact_func [pact_numb[p]])(p);		// Call parse action with production number.
			if (rc < 0)											// Bypass make node operation?
			{
				goto Linkup;
			}
		}
      int psi;											      // Parse Stack Index.
      currnode = NULL;
      if (node_numb[p] >= 0)   					      // MAKE NODE ?
      {
@optn_debug.ge.2;...
			prt_log ("         make node        %s(", node_name[node_numb[p]]);
@@
         currnode = (Node*)ALLOC(node, 1);
         currnode->id     = node_numb[p];				// Set node id.
         currnode->numb   = n_nodes++;				   // Set node number.
         currnode->prod   = p;							// Put production (rule) number in node.
         currnode->next   = NULL;						// Set next to nonexistent.
         currnode->prev   = NULL;						// Set prev to nonexistent.
         currnode->child  = NULL;		            // Define no child.
         currnode->parent = NULL;		            // Define no parent.
         if (pact_arg[p] >= 0)				   		// If node argument defined,...
         {
            psi = arg_numb[pact_arg[p]]-1;	   	// Get parse-stack index.
            currnode->sti   = PS[psi].sti;		   // Move sti from parse stack to node.
            currnode->start = PS[psi].start;	      // Move start from parse stack to node.
            currnode->end   = PS[psi].end;	      // Move end from parse stack to node.
            currnode->line  = PS[psi].line;	      // Move line from parse stack to node.
@optn_debug.ge.2;...
				char* sym;
				int   sti = PS[psi].sti;
				if (sti > 0) sym = symname (sti);
				else			 sym = term_symb [-sti];
				prt_log ("%s,", sym);
@@
         }
         else
         {
            currnode->sti   = 0;    					// Set symbol-table index to zero.
            currnode->start = NULL;	               // Set start to null.
            currnode->end   = NULL;	               // Set end to null.
            currnode->line  = 0;							// Set line number to 0.
         }
@optn_debug.ge.2;...
			prt_log (")\n");
@@
			psi = linkup(p);									// Linkup the nodes in this rule.
			if (psi >= 0)										// Any nodes found in this rule?
         {
				  currnode->child = PS[psi].node;      // Define child.
              PS[psi].node->parent = currnode;     // Define parent.
         }
			PS[0].node = PS[0].last = currnode;		   // Define node in the parse stack.
         n_nodes++;
      }
		else	                                       // Check for nodes not linked?
		{
Linkup:  psi = linkup (p);                         // Get parse-stack index.
			if (psi > 0)                              // If we have a node here ...
			{
				PS[0].node = PS[psi].node;		         // Move node value to 1st position.
				PS[0].last = PS[psi].last;		         // Move last value also.
			}
		}
      return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		linkup

int   @grm_name;Parser::linkup (int p)
{
      int i;
      int next = -1;
      for (i = PL[p]; i >= 0; i--)				         // For each tail pointer.
      {
         if (PS[i].node != NULL)                      // If tail points to node.
         {
            if (next >= 0)                            // If one waiting.
            {
               PS[i].last->next = PS[next].node;      // Attach node to end of list.
               PS[next].node->prev = PS[i].last;      // Define previous node.
               PS[i].last = PS[next].last;            // Change last to next last.

            }
            next = i;									      // Next = Curr.
			}
		}
      return (next);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    syntax_error

void  @grm_name;Parser::syntax_error (char *symb)
{
      int  col, ln1, ln2;
      char string[10000], *ls1, *ls2, *le1, *le2, *p, c;

      n_errors++;

	// Get first line number ...
      ln1 = line_numb;
		for (p = token.end-1; p > token.start; p--)
		{
			if (*p == '\n') ln1--;
		}

	// Get first line start ...
		for (ls1 = token.start; *ls1 != '\n'; ls1--);
		ls1++;

	// Get first line end ...
		for (le1 = token.start; *le1 != '\n'; le1++);

	// Get last line number ...
      ln2 = line_numb;

	// Get last line start ...
		for (ls2 = token.end-1; *ls2 != '\n'; ls2--);
		ls2++;

	// Get last line end ...
		for (le2 = token.end; *le2 != '\n'; le2++);
		*le1 = 0;
		*le2 = 0;

		if (*token.start == '\n') ln1--;
      col = 1;
      for (p = ls1; p < token.start; p++)
      {
         if (*p == '\t') *p = ' ';
         col++;
      }
		prt_log ("%s(%04d) : Error  %s\n", grmfid, ln1, ls1);
      *le1 = '\n'; // In case token is this <eol>

      memset (string, '-', col);
      string [col] = 0;

		prt_log ("%s(%04d) : Error %s^ ", grmfid, ln1, string);

      if (*token.start <= 32)
      {
         short x = *token.start;
         if (x < 0) x += 256;
         prt_log ("at character code %d %s\n\n", x, symb);
      }
      else
      {
         if (token.end == token.start) token.end++;
         if (token.end > le1)
         {
				if (*token.start == '\n') *token.start = 0;
            if (*token.end == EOF_CHAR) line_numb--;
            c = *le1;
            *le1 = 0;
            prt_log ("starts at %s\n", token.start, ln1);
				prt_log ("%s(%04d) : Error ends here.\n\n", grmfid, ln2);
            *le1 = c;
         }
         else
         {
            c = *token.end;
            *token.end = 0;
				if (*token.start == '\n') *token.start = 0;
            prt_log ("at %s %s\n\n", token.start, symb);
            *token.end = c;
         }
      }
}

@optn_exp?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		expecting // Print expecting list.

void  @grm_name;Parser::expecting ()
{
		int t;
		T_list = (char*)malloc (sizeof(*T_list)*n_terms);
		P_list = (int* )malloc (sizeof(*P_list)*n_prods);
		for (t = 0; t < n_terms; t++) T_list[t] = 0;

		prt_log ("Expecting one of the following:\n\n");

 		for (PS = PStop; RS > R_stack; RS--)   // Restore PS, RS and states.
      {
         RS->ptr->state = RS->state;         // Reset state to saved state.
      }

	  	collect (topstate);		               // Collect all terminal symbols expected.

		for (t = 0; t < n_terms; t++)
      {
         if (T_list[t])
         {
       	   prt_log ("\t%-20s\n", term_symb[t]);
         }
      }
		prt_log ("\n");
		free (P_list);
		free (T_list);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		collect: Collect terminals that cause a transition or reduction.

void	@grm_name;Parser::collect (int x)
{
		int t, p, q, i, la, n_red;

   // TRANSITION TO NEXT STATE? ...
     	for (t = 0; t < n_terms; t++)						// For all terminals.
		{
  			if (Bm [Br[x] + Bc[t]] & Bmask[t])			// Accept this terminal?
			{
            T_list[t] = 1;                         // Mark this terminal.
			}
		}
		n_red  = 0;                                  // Reset to zero reductions.
   // REDUCTIONS IN THIS STATE? ...
		if ((p = Rr[x]) > 0)									// Default reduction?
		{
			P_list[n_red++] = p;	                     // Add this production to list.
		}
		else														// Reductions based on lookaheads!
		{
			for (la = 0; la < n_terms; la++)			   // For all lookaheads.
			{
				if ((q = Rm [Rc[la] - p]) > 0)			// Got a reduction on this terminal?
				{
			  		for (i = 0; i < n_red; i++)			// For all reductions in the list.
					{
						if (P_list[i] == q) goto Next;   // Already in this list?
					}
					P_list[n_red++] = q;	               // Add this production to list.
				}
Next:       continue;
			}
@nd_action?;...
		   for (i = nd_start[x]; i < nd_start[x+1]; i++) // For all nondeterministic terminals.
		   {
            p = -nd_action[i];                     // Get action.
            if (p > 0)                             // Is it a production?
            {
			  		for (int j = 0; j < n_red; j++)		// For all reductions in the list.
					{
						if (P_list[j] == p) goto Next2;  // Already in this list?
					}
					P_list[n_red++] = p;	               // Add this production to list.
            }
Next2:      continue;
		   }
@@
		}

   // MAKE REDUCTIONS ...
	  	for (i = 0; i < n_red; i++)
		{
         p = P_list[i];
         if (PL[p] < 0)                            // Null production?
         {
			   PS++;											   // Increment stack pointer.
            PS->state = x;								   // Stack state.
			   goto Cont;
         }
		   do
		   {
			   PS -= PL[p];								   // Reduce parse stack pointer.
Cont:		   p = -Nm [Nr[PS->state] + Nc[p]];		   // Get production or next state.
		   }
		   while (p > 0);
		   collect (-p);									   // Go collect terminals.
		}
}

@@ end optn_exp?
@optn_debug.ge.2;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    prt_token

void  @grm_name;Parser::prt_token (short t)
{
      char c;
		char* terminal;
		c = *token.end;
      *token.end = 0;
      if (*token.start < 32) terminal = "\1";
      else		   			  terminal = token.start;
		prt_log ("\t\tToken:  %s %s\n", terminal, term_symb[t]);
      *token.end = c;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    prt_prod

void	@grm_name;Parser::prt_prod (short p)
{
		prt_log ("         reduce    %6d %s <- ", p, head_symb [head_numb[p]]);
		int i;
		int first = f_tail[p];
		int next_first = f_tail[p+1];
		for (i = first; i < next_first; i++)
		{
			cchar* symb;
			int   s = tail[i];
			if (s >= 0) symb = term_symb[ s];
			else        symb = head_symb[-s];
			prt_log ("%s ", symb);
		}
		prt_log ("\n");
}

@@ end optn_debug.ge.2
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    init_symtab

void  Symtab::init_symtab (int max_symb)
{
      int i;
		max_symbols   = max_symb;
		max_cells     = 2*max_symbols;
		ALLOC (symbol,  max_symbols);
      ALLOC (hashvec, max_cells);
      hashdiv       = ULONG_MAX / max_cells + 1;
      n_symbols	  = 0;
      if (hashvec == NULL)
      {
			printf ("Not enough memory available for Symbol Table.\n\n");
         Terminate(0);
      }
      for (i = 0; i < max_cells; i++) hashvec[i] = -1;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    term_symtab

void  Symtab::term_symtab ()
{
      delete [] symbol;
      delete [] hashvec;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    add_symb - add symbol to table.

int   Symtab::add_symbol (short t, char* token_start, char* token_end, int type, int line)
{
      char*p;
		sti = get_symbol (token_start, token_end, type);
		if (sti < 0)
		{
			sti = n_symbols;
			if (n_symbols >= max_symbols)				   // Reached maximum number?
			{
            MemCrash ("Number of symbols", max_symbols); 
				Terminate(0);
			}
			hashvec[cell] = n_symbols;					   // Put symbol number into hash vector.
         p = ALLOC (p, length+1);                  // Allocate space for text string.
         memcpy (p, token_start, length);	         // Move string to allocated space.
         *(p+length) = 0;                          // Padd with zero byte.
         symbol[n_symbols].name   = p;             // Define pointer to symbol name.
         symbol[n_symbols].start  = token_start;   // Define pointer to symbol start address in source code.
			symbol[n_symbols].line   = line;			   // Define line number in grammar.
			symbol[n_symbols].type   = 0;					// Don't define type.
			symbol[n_symbols].numb   = -1;			   // Define sequence number as -1 (undefined).
			symbol[n_symbols].value  = 0;				   // Define value as zero (undefined).
			symbol[n_symbols].length = length;		   //	Define symbol length.
			n_symbols++;									   // Increment number of symbols.
		}
      return (sti);									      // Return symbol-table index.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    get_symbol - get symbol number from table.

int   Symtab::get_symbol (char* token_start, char* token_end, int type)
{
      char* p = token_start;		    	         // Point at start.
      char* q = token_end;			 	            // Point at end.
      length = (short)(q-p);       				   // Get length.
      ulong hash = length;         	   		   // Set hash to length.
      int i = 0;						   			   // Set shift value to 0.
      do									      		   // Assume length != 0
      {
         hash += *p << i;
         i += 4;
         i %= 32;
      }
      while (++p < q);
      cell = hash % max_cells; 					   // Get first cell.
		i = hashvec [cell];				   		   // Get symbol index.
      if (i >= 0)
		{
         p = token_start;				            // Point at token start.
			do
			{
				if (symbol[i].length == length && symbol[i].type & type)	// Length and type match?
				{
					q = symbol[i].name;				   // Point at symbol name.
					short j = 0;
					do
					{
						if (p[j] != q[j]) goto Cont;	// If characters not equal ...
					}
					while (++j < length);				// while end not reached.
					return (i);								// Found it.
				}
	Cont:    cell = (hash *= 65549) / hashdiv;	// Get new cell number.
				i = hashvec [cell];					   // Get symbol index.
			}
			while (i >= 0);      					   // While not empty slot.
		}
      return (i);										   // Return symbol number.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    print - print symbol table contents.

void  Symtab::print_symtab (char** term_symb)
{
@optn_debug.ge.1;...
      short i;
      if (n_symbols > 1)
      {
		   prt_lst ("Symbol Table ...\n\n");
		   prt_lst ("   sti   leng   type   numb   \n");

	      for (i = 1; i < n_symbols; i++)
	      {
			   prt_lst ("%6d %6d %6d %6d  %s\n",
			      i,
			      symbol[i].length,
			      symbol[i].type,
			      symbol[i].numb,
               symname(i));
	      }
		   prt_lst ("\n");
      }
      else
      {
		   prt_lst ("\nSymbol Table is empty!\n\n");
      }
@@ end optn_debug.ge.1
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    symname - get symbol name.

char* Symtab::symname (int i)
{
      static char name[2000];
      char* p;
      short L;

		if (i == 0)
		{
			name[0] = 0;
			return name;
		}

      p = symbol[i].name;
      L = symbol[i].length;

      if (L >= 2000)
      {
	      for (i = 0; i < 100; i++) name[i] = p[i];
		   name[i] = 0;
			prt_log ("Symbol length of %d is too big (>= 2000).\n", L);
			prt_log ("for '%s'\n.", name);
         Terminate(0);
      }
      for (i = 0; i < L; i++) name[i] = p[i];
      name[i] = 0;
      return name;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//																										                     //
//    ABSTRACT-SYNTAX-TREE FUNCTIONS

/*    static uchar numeric[256] = // numeric[x] gives 1..10 for digits 0..9
      {
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      1,  2,  3,  4,  5,  6,  7,  8,  9, 10,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
      };
*/
		char draw_plus [] = "+ ";
		char draw_vbar [] = "| ";
		char draw_last [] = "+ ";
		char draw_space[] = "  ";

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    init_ast

void  AST::init_ast ()
{
	  	root = (Node*)ALLOC (node, 1);
      root->id     = -1;  // Undefined.
      root->numb   = 0;
      root->prod   = 0;
      root->sti    = 0;
      root->line   = 0;
      root->next   = NULL;
      root->prev   = NULL;
      root->child  = NULL;
      root->parent = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    term_ast

void  AST::term_ast ()
{
		delete [] node;
      delete [] stack;
      delete [] counter;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    print_ast

void  AST::print_ast (char** Term_Symb)
{
      term_symb = Term_Symb;
		if (n_nodes > 1)
			print_ast (root);
		else
			prt_lst ("AST is empty.\n\n");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    print_ast (n)

void  AST::print_ast (Node* np) // Print subtree.
{
@optn_debug.ge.1;...
      char indent [512];
		strcpy (indent, draw_space);
		prt_lst ("Abstract Syntax Tree ...\n\n");
		prt_lst ("  numb   next   prev  child parent    sti   line \n");

		traverse (indent, np); // Start AST traversal.
		prt_lst ("\n");
@@ end optn_debug.ge.1
}

@optn_debug.ge.1;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse

void  AST::traverse (char *indent, Node* np)
{
      while (np->next > 0)
      {
         strcat (indent, draw_plus);
         print_node (indent, np);
         indent [strlen(indent)-2] = 0;
         if (np->child > 0)
         {
            strcat (indent, draw_vbar);
            traverse (indent, np->child);
            indent [strlen(indent)-2] = 0;
         }
         np = np->next;
      }

      strcat (indent, draw_last);
      print_node (indent, np);
      indent [strlen(indent)-2] = 0;
      if (np->child > 0)
      {
         strcat (indent, draw_space);
         traverse (indent, np->child);
         indent [strlen(indent)-2] = 0;
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    print_node

void  AST::print_node (char *indent, Node* np)  /* Print this node function. */
{
      int i, next = 0, prev = 0, child = 0, parent = 0;
      int sti;
      sti = np->sti;
      if (np->next   != NULL) next   = np->next->numb;
      if (np->prev   != NULL) prev   = np->prev->numb;
      if (np->child  != NULL) child  = np->child->numb;
      if (np->parent != NULL) parent = np->parent->numb;
	  	prt_lst ("%6d %6d %6d %6d %6d %6d %6d %s%s",
		  	np->numb,
  		  	next,
  		  	prev,
  		  	child,
  		  	parent,
			sti,
			np->line,
			indent,
			node_name[np->id]);

		if (sti != 0) // zero means no symbol.
		{
			char* q;
			short L;
			char string[100];
			if (sti > 0) // a symbol found in the input file?
			{
				q = symbol[sti].name;
				L = symbol[sti].length;
			}
			else // a terminal symbol of the grammar!
			{
				q = term_symb[-sti];
				L = strlen(q);
			}
			if (L > 99) L = 99;
			for (i = 0; i < L; i++, q++) // Replace '\n' with \1
			{
				if (*q == '\n') string[i] =  1; // one = happy face.
				else            string[i] = *q;
			}
			string[i] = 0;
			prt_lst (" %s", string);
		}
		prt_lst ("\n");
}

@@ end optn_debug.ge.1
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse

void  AST::traverse ()
{
	  	if (n_nodes > 1) // Any nodes in the tree?
		{
         if (n_nodeactions > 0) // Any AST actions in the parser?
			{
				int i;
				stacki = -1;
				ALLOC (stack, STKSIZE);
				ALLOC (counter, n_nodenames);
				for (i = 0; i < n_nodenames; i++)
				{
					counter[i] = 0;
				}
@optn_debug?;...
				prt_log ("Traversing the AST pass %d ...\n", pass);
@@
@optn_debug.ge.2;...
				prt_log ("Traversing AST ...\n\n");
				strcpy (spaces, "   ");
@@
  				traverse (root);	// Start AST traversal.

@optn_debug.ge.2;...
				prt_log ("\nTraversing done.\n\n");
@@
			}
		}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse (n)

void  AST::traverse (Node* np)
{
@numb_nact?;...
      Node* cp;
		int   i, p, na;
		i = np->id;
      p = np->prod;
      counter[i]++;
      stacki++;
      stack[stacki].id = i;
      stack[stacki].counter = counter[i];
	//	na = nact_numb[p];
	  	na = i;

		if (na >= 0)
		{
@optn_debug.ge.2;...
			prt_log ("%s=> %s %s()\n", spaces, node_name[i], nact_name[na]);
@@
			status = TOP_DOWN;
			(*nact_func[na]) (np);
		}

    	cp = np->child;
      while (cp != NULL)
		{
@optn_debug.ge.2;...
			strcat (spaces, "   ");
@@
    	   traverse (cp);
@optn_debug.ge.2;...
			spaces [strlen(spaces)-3] = 0;
@@
			if ((cp = cp->next) != NULL)
			{
				if (na >= 0)
				{
@optn_debug.ge.2;...
					prt_log ("%s : %s %s()\n", spaces, node_name[i], nact_name [na]);
@@
					status = PASS_OVER;
					(*nact_func[na]) (np);
				}
         }
		}

		if (na >= 0)
		{
@optn_debug.ge.2;...
			prt_log ("%s<= %s %s()\n", spaces, node_name[i], nact_name [na]);
@@
			status = BOTTOM_UP;
			(*nact_func[na]) (np);
		}
      stacki--;
@@ end numb_nact?
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    emitstr

short AST::emitstr (Node* np, char* str)
{
      short sti;
      int   i, x;
      char  string[1000];
      char  *symb, *s, *p;

   // Get symbol from node.
      sti  = np->sti;
		if (sti < 0) symb = term_symb[-sti];
      else         symb = symname(sti);

   // Scan string for &-codes ...
      p = str;
      s = string;
      while (1)
      {
         *s = *p;
         if (*s == 0)
         {
				prt_lst (string, symb);
            return (0);
         }
         if (*s == '&') // &-code ?
         {
            if (numeric[*++p]) // number ?
            {
               x = *p - '0';
               while (numeric[*++p]) x = 10*x + *p - '0';
               i = stacki - x;
               if (i < 0) *s++ = '?'; // Error.
               else
               {
                  switch (*p)
                  {
                     case 'c':
							s += sprintf (s, "%d", stack[i].counter); // Get counter.
                     p++;
                     break;

                  // case 'n':
						//	s += sprintf (s, "%s", node_name[stack[i].id]); // Get node name.
                  // p++;
                  // break;

                     default:
							s += sprintf (s, "%d", stack[i].counter); // Get counter.
                     break;
                  }
               }
            }
            else s++;
         }
         else { s++; p++; }
      }
		return (0);
}

@optn_debug?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //

void	@grm_name;Parser::prt_stack () // Print parser stack.
{
@optn_debug.eq.3;... // 3rd level debug (option: 'd=3')
		prt_log ("         parse stack      ");
		for (PStack* ps = P_stack+1; ps <= PS; ps++)
		{
			char* symbol;
			int sym = ps->sym;
			if (sym >= 0) symbol = term_symb [ sym];
			else          symbol = head_symb [-sym];
			prt_log ("%s ", symbol);
		}
		prt_log ("\n");
@@
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //

char* filter (char* text)
{
		static char string[80] =
         "..............................................................................$";
		char *p = string;
		char *q = text;
		while (*q != 0 && *p != '$')
		{
			if (*q >= ' ') *p = *q;
			else           *p = '.';
			p++;
			q++;
		}
		*p = 0;
		return string;
}

@@ end optn_debug?

//    End of LRSTAR Parser.
//																																   //
/////////////////////////////////////////////////////////////////////////////////////////////////////

#endif


