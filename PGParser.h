
#ifdef LRSTAR

#pragma once

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    PGParser.h

/*    Generated by: LRSTAR 6.5.019
      Grammar:      PG.grm
      Skeleton:     PGParser.h.skl
      Output:       PGParser.h
*/               
		#include "PGLexer.h"

		#define TOKEN_ACTIONS
		#define PARSE_ACTIONS
		#define NODE_ACTIONS

   // Defined constants ...
      #undef  ERROR          
      #undef  ALPHA          
      #undef  GOALSYMBOL     
      #undef  HEADSYMBOL     
      #undef  COLON          
      #undef  ARROW1         
      #undef  ARROW2         
      #undef  ARROW3         
      #undef  ARROW4         
      #undef  BAR            
      #undef  SEMICOLON      
      #undef  PARSEACTION    
      #undef  MAKENODE       
      #undef  MAKENODEWA     
      #undef  PAMAKENODE     
      #undef  PAMAKENODEWA   

      #define ERROR               0 // 
      #define ALPHA               1 // 
      #define GOALSYMBOL         11 // 
      #define HEADSYMBOL         12 // 
      #define COLON              13 // 
      #define ARROW1             14 // 
      #define ARROW2             15 // 
      #define ARROW3             16 // 
      #define ARROW4             17 // 
      #define BAR                18 // 
      #define SEMICOLON          19 // 
      #define PARSEACTION        20 // 
      #define MAKENODE           21 // 
      #define MAKENODEWA         22 // 
      #define PAMAKENODE         23 // 
      #define PAMAKENODEWA       24 // 

   // Defined constants for the node names ...
      #define START_              0
      #define GRAMMAR_            1
      #define OPTIONS_            2
      #define DECLARATIONS_       3
      #define CONSTDECL_          4
      #define CONSTANT_           5
      #define VALUE_              6
      #define TOKEN_DECL_         7
      #define TERMINAL_           8
      #define TERMINALRES_        9
      #define OPERPREC_          10
      #define LEFTASSOC_         11
      #define RIGHTASSOC_        12
      #define OPER_              13
      #define RULES_             14
      #define GOALDEF_           15
      #define PROD_              16
      #define TAILS_             17
      #define TAIL_              18
      #define HEADDEF_           19
      #define REPEAT_            20
      #define REPEATSEP_         21
      #define REPEATSEPREV_      22
      #define REVERSE_           23
      #define REPEATREV_         24
      #define SEPEXPR_           25
      #define SEPEXPRREV_        26
      #define OPTGROUP_          27
      #define GROUP_             28
      #define TAILKW_            29
      #define SEP_               30
      #define TOKEN_ACTION_      31
      #define RULE_ACTIONS_      32
      #define PARSE_ACTION_      33
      #define MAKE_NODE_         34
      #define MAKE_NODE_WA_      35
      #define PARSE_ACTION_MAKE_NODE_    36
      #define PARSE_ACTION_MAKE_NODE_WA_    37
      #define TOKEN_ACTION_SPEC_    38
      #define PARSE_ACTION_SPEC_    39
      #define BLANK_PARSE_ACTION_    40
      #define NODE_SPEC_         41
      #define PA_NODE_SPEC_      42
      #define NODE_ACTION_       43
      #define ARGS_              44
      #define ARG_NULL_          45
      #define ARG_ALPHA_         46
      #define ARG_TERMINAL_      47
      #define ARG_STRING_        48
      #define ARG_INTEGER_       49
      #define ARG_EXPR_          50
      #define ARG_EXPR_INTEGER_    51
      #define ARG_EXPR_ALPHA_    52

	// AST Action Mode. 
      #define TOP_DOWN        0  // Top down status.  
   	#define PASS_OVER       1  // Pass over status.
   	#define BOTTOM_UP       2  // Bottom up status.  

	// AST Traversal Passes. 
      #define FIRST_PASS       1  // EBNF normalization.
      #define SECOND_PASS      2  // EBNF expansion.
      #define THIRD_PASS       3  // Count variables.
      #define FOURTH_PASS      4  // Print the grammar.
   
      class PGParser : public PGLexer, public AST
		{
		   public:
		// Functions ...
			static void    initialize   (int);				
			static int     parse        (char* input_start);	
			static void    terminate   ();	
			static void    syntax_error (char*);

		// Variables ...
			static int     n_constants;
		   static int     N_args;
		   static int*    F_narg;
			static int*    Arg_numb;
			static int    	N_strings;
			static int    	N_tails;
			static int    	N_terms;
			static int*   	Node_numb;
			static int*   	Nact_numb;
			static char** 	Node_start;
			static char** 	Nact_start;
			static int    	N_heads;
			static int    	N_generated;
			static int    	N_nodes;
			static int    	N_tacts;  // token actions.
			static int    	N_pacts;  // parsing actions (total).
			static int    	N_nacts;
			static int    	N_ints;
			static int    	N_prods;

	      static char**  Str_start;
			static int*    f_eri;
			static int*    F_targ;
			static int*    F_parg;
			static int*    F_prod;
	      static int*    eri_prod;
		   static int*    eri_dot;
		   static int     n_eris;
	      static char**  Tact_start;
		   static int*    Tact_numb;
	      static int*    Reverse;
			static int     opt_states;
			static int*    Oper_prec;
			static char*   Prec;
			static char**  Pact_start;
			static int*    Pact_numb;
	      static int*    Defcon_value;
		   static char**  Defcon_name;
			static int     eol_term;
			static int     eof_term;
			static int     error_sym_used;
			static int     make_ast;
	      static int     keyword_sym;
	
         static PStack* PS;           	      // Parse Stack pointer.       
         static PStack* PS_end;        	      // Parse Stack end.       
			static int     prev_token;
			static int		goal_symbol;
			static int		start_symbol;
			static int		error_mode;
			static int		codeblock;

			static char     tact_arg[];		      // Token action argument index (for first arg).
			static short    pact_arg[];		      // Production action argument index (for first arg).
			static short    nact_arg[];		      // Node action argument index (for first arg).
			static char     arg_numb[];		      // Parse argument numbers.
			static char*    arg_text[];		      // Argument text (if a string argument or node arg).
			static char*    term_symb[];           // Terminal symbols of the grammar.
			static char     tact_numb[];           // Token action number. 

		   private:
		// Functions ...
			static int     nd_parse      (int*, int*, int*, int x, int t, int a);
			static int     reduce_action (int p);
			static int     linkup			(int p);
			static void    rebuild		   ();                           
			static short   err_rec		   (short, short);
//			static short   lookahead		(short t, short x);
			static void    get_list		(short);
			static void    prt_token		(short); 
			static void    prt_prod		(short); 
			static void    prt_stack		(); 
			static void    expecting		(); 
			static void	   collect		   (int x);
			static void	   reduce			(int p, int x);
			static void    prt_list      (int t);
  		  	static int    (*tact_func[])  (int);	// Parser action function pointers.
  		  	static int    (*pact_func[])  (int);	// Parser action function pointers.

		// Variables ...
  		  	static char*   tact_name[];		      // Parser action name.
  		  	static char*   pact_name[];				// Parser action name.
    
			static int     max_errs;				   // Maximum allowable errors.
			static int     n_terms;				   // Number of terminal symbols in grammar.
			static int     n_heads;				   // Number of head symbols in grammar.
			static int     n_prods;				   // Number of productions (rules) in grammar.
			static int     n_states;				   // Number of states in Parser state machine.
			static int     eof_symb;				   // <eof> symbol number.
			static int     eol_symb;				   // <eol> symbol number.
			static int     err_used;				   // <error> used in grammar?
                                       		                                      
         static RStack* RS;           		   // Reduction Stack pointer.
			static char*   T_list;					   // Terminal symbol list (0 or 1).
			static int*    P_list;					   // Production list.
         static RStack  R_stack[];				   // Reduction stack.
         static PStack  P_stack[];				   // Parser stack.
			static PStack* PStop;				      // Top pointer for Parser stack.
			static int     topstate;				   // Top state (before reductions start).

			static char*    head_symb[];           // Head (nonterminal) symbols of the grammar.
			static uchar    head_numb[];           // Head symbol number for a production (rule).
			static char     PL[];			         // Production (rule) length less one (zero based).
			static char     pact_numb[];           // Production action number (for a Parser action).
			static char     node_numb[];           // Node number index for a production (rule).

			static uchar    Bm[];			         // Bit matrix (0 or 1).
			static uchar    Br[];			         // Bit matrix row (base).
			static uchar    Bc[];			         // Bit matrix column (displacement).
			static uchar    Bmask[];		         // Bit matrix mask.
			static short    Tm[];			         // Terminal transition matrix (gives next state or reduction).
			static uchar    Tr[];			         // Terminal transition matrix row (base).
			static uchar    Tc[];			         // Terminal transition matrix column (displacement).
			static short    Nm[];			         // Nonterminal transition matrix (gives next state or reduction).
			static ushort   Nr[];			         // Nonterminal transition matrix row (base).
			static uchar    Nc[];			         // Nonterminal transition matrix column (displacement).
			static uchar    Rm[];			         // Reduction matrix (gives reduction).
			static short    Rr[];			         // Reduction matrix row (base).
			static uchar    Rc[];			         // Reduction matrix column (displacement).
			static uchar    nd_start[];
			static uchar    nd_term[]; 
			static uchar    nd_action[]; 
			static uchar    reverse[];		         // Reverse order of nodes for this production (rule)?
			static ushort   f_tail[];		         // First Tail symbol for a production.
			static char     tail[];			         // Tail symbols for productions.
		};

#endif
