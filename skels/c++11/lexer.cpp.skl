@("int8_t", "uint8_t", "int16_t", "uint16_t", "int", "uint", "const char*")
@//
// Generated by: @program; @version;
// Grammar:      @grm_file;
// Skeleton:     @skl_file;
// Output:       @out_file;
#include "@grm_name;lexer.h"

namespace @grm_name; {

const int Lexer::tab = 8; // Tab setting for the input file.

@def_cons?;...
char *token_name[] =
{
    @def_cons.1|"%s"|, |,\n    |;
};

@@
@optn_small?;...
// Boolean Matrix and Vectors.

// Boolean matrix.
const @bmat_numb.t; Lexer::Bm[@bmat_numb.d;] =
{
    @bmat_numb.40|%d|, |,\n    |;
};

// B_matrix row.
const @bmat_row.t; Lexer::Br[@bmat_row.d;] =
{
    @bmat_row.20|%d|, |,\n    |;
};

// B_matrix column.
const @bmat_col.t; Lexer::Bc[@bmat_col.d;] =
{
    @bmat_col.20|%d|, |,\n    |;
};

@@
// Terminal Transition Matrix and Vectors.

// Transition matrix.
const @tmat_numb.t; Lexer::Tm[@tmat_numb.d;] =
{
    @tmat_numb.20|%d|, |,\n    |;
};

// T_matrix row.
const @tmat_row.t; Lexer::Tr[@tmat_row.d;] =
{
    @tmat_row.20|%d|, |,\n    |;
};

// T_matrix column.
const @tmat_col.t; Lexer::Tc[@tmat_col.d;] =
{
    @tmat_col.20|%d|, |,\n    |;
};

// Token numbers for each state.
const @term_numb.t; Lexer::terminal[@term_numb.d;] =
{
    @term_numb.20|%d|, |,\n    |;
};

@strings?;...
// String return values.
const @strings.t; Lexer::string[@strings.d;] =
{
    @strings.1|%s|, |,\n    |;
};

@@
// DFASTAR Lexer.
void Lexer::start(
    const char *input
@optn_line?;...
    , int line
@@
@optn_col?;...
    , int column
@@
) {
@optn_col?;...
    this->column = column;
@@
@optn_line?;...
    this->line = line;
@@
    token.end = input;
}

@optn_medium?;...
int Lexer::next() // Medium lexer.
{
    int currState, nextState;
    do {
        currState = 0;
        token.start = token.end;
@optn_line?;...
        token.line = line;
@@
@optn_col?;...
        token.column = column;
@@
        while ((nextState = Tm[Tr[currState] + Tc[(uint8_t)*token.end]]) > 0) {
            currState = nextState;
@optn_line?;...
            if (*token.end == '\n') {
                ++line;
@optn_col?;...
                column = 0;
@@
            }
@@
            ++token.end;
@optn_col?;...
            ++column;
@@
        }
    } while (terminal[currState] < 0); // Ignore whitespace.
    return terminal[currState]; // Return terminal number.
}

@@
@optn_small?;...
int Lexer::next() // Small lexer.
{
    int state;
    do {
        state = 0;
        token.start = token.end;
@optn_line?;...
        token.line = line;
@@
@optn_col?;...
        token.column = column;
@@
        while (Bm[Br[state] + Bc[(uint8_t)*token.end]]) {
            state = Tm[Tr [state] + Tc[(uchar)*token.end]];
@optn_line?;...
            if (*token.end == '\n') {
                ++line;
@optn_col?;...
                column = 0;
@@
            }
@@
            ++token.end;
@optn_col?;...
            ++column;
@@
        }
    } while (terminal[state] < 0); // Ignore whitespace.
    return terminal[state]; // Return terminal number.
}

@@
TokenSequence::TokenSequence(const Token &begin, const Token &end)
{
    setBegin(begin);
    setEnd(end);
}

void TokenSequence::setBegin(const Token &begin)
{
    beginPos = begin.start;
@optn_line?;...
    line = begin.line;
@@
@optn_col?;...
    column = begin.column;
@@
}

void TokenSequence::setEnd(const Token &end)
{
    endPos = end.end;
}

TokenSequence::iterator TokenSequence::begin() const
{
    return iterator(
        beginPos
@optn_line?;...
        , line
@@
@optn_col?;...
        , column
@@
    );
}

TokenSequence::iterator TokenSequence::end() const
{
    return iterator(endPos);
}

TokenSequence::iterator::iterator(
    const char *begin
    , int line
    , int colunm
):
    end(nullptr)
{
    lexer.start(
        begin
@optn_line?;...
        , line
@@
@optn_col?;...
        , colunm
@@
    );
    lexer.next();
}

TokenSequence::iterator::iterator(const char *end): end(end)
{
}

bool TokenSequence::iterator::operator!=(const TokenSequence::iterator &other) const
{
    const char * const thisEnd = end ? end : lexer.currentToken().end;
    const char * const otherEnd = other.end ? other.end : other.lexer.currentToken().end;
    return thisEnd != otherEnd;
}

const Token &TokenSequence::iterator::operator*() const
{
    return lexer.currentToken();
}

TokenSequence::iterator &TokenSequence::iterator::operator++()
{
    lexer.next();
    return *this;
}

} // namespace @grm_name;
