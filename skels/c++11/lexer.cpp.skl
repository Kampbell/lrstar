@("int8_t", "uint8_t", "int16_t", "uint16_t", "int", "uint", "const char*")
@//
// Generated by: @program; @version;
// Grammar:      @grm_file;
// Skeleton:     @skl_file;
// Output:       @out_file;
#include "@grm_name;lexer.h"

namespace @grm_name; {

const int Lexer::tab = 8; // Tab setting for the input file.

@def_cons?;...
char *token_name[] =
{
    @def_cons.1|"%s"|, |,\n    |;
};

@@
@optn_small?;...
// Boolean Matrix and Vectors.

// Boolean matrix.
const @bmat_numb.t; Lexer::Bm[@bmat_numb.d;] =
{
    @bmat_numb.40|%d|, |,\n    |;
};

// B_matrix row.
const @bmat_row.t; Lexer::Br[@bmat_row.d;] =
{
    @bmat_row.20|%d|, |,\n    |;
};

// B_matrix column.
const @bmat_col.t; Lexer::Bc[@bmat_col.d;] =
{
    @bmat_col.20|%d|, |,\n    |;
};

@@
// Terminal Transition Matrix and Vectors.

// Transition matrix.
const @tmat_numb.t; Lexer::Tm[@tmat_numb.d;] =
{
    @tmat_numb.20|%d|, |,\n    |;
};

// T_matrix row.
const @tmat_row.t; Lexer::Tr[@tmat_row.d;] =
{
    @tmat_row.20|%d|, |,\n    |;
};

// T_matrix column.
const @tmat_col.t; Lexer::Tc[@tmat_col.d;] =
{
    @tmat_col.20|%d|, |,\n    |;
};

// Token numbers for each state.
const @term_numb.t; Lexer::terminal[@term_numb.d;] =
{
    @term_numb.20|%d|, |,\n    |;
};

@strings?;...
// String return values.
const @strings.t; Lexer::string[@strings.d;] =
{
    @strings.1|%s|, |,\n    |;
};

@@
// DFASTAR Lexer.
void Lexer::start(const char *input)
{
@optn_col?;...
    column = 1;
@@
@optn_line?;...
    line = 1;
@@
    token.end = input;
}

@optn_medium?;...
int Lexer::next() // Medium lexer.
{
    int currState, nextState;
    do {
        currState = 0;
        token.start = token.end;
@optn_line?;...
        token.line = line;
@@
@optn_col?;...
        token.column = column;
@@
        while ((nextState = Tm[Tr[currState] + Tc[(uint8_t)*token.end]]) > 0) {
            currState = nextState;
@optn_line?;...
            if (*token.end == '\n') {
                ++line;
@optn_col?;...
                column = 0;
@@
            }
@@
            ++token.end;
@optn_col?;...
            ++column;
@@
        }
    } while (terminal[currState] < 0); // Ignore whitespace.
    return terminal[currState]; // Return terminal number.
}

@@
@optn_small?;...
int Lexer::next() // Small lexer.
{
    int state;
    do {
        state = 0;
        token.start = token.end;
@optn_line?;...
        token.line = line;
@@
@optn_col?;...
        token.column = column;
@@
        while (Bm[Br[state] + Bc[(uint8_t)*token.end]]) {
            state = Tm[Tr [state] + Tc[(uchar)*token.end]];
@optn_line?;...
            if (*token.end == '\n') {
                ++line;
@optn_col?;...
                column = 0;
@@
            }
@@
            ++token.end;
@optn_col?;...
            ++column;
@@
        }
    } while (terminal[state] < 0); // Ignore whitespace.
    return terminal[state]; // Return terminal number.
}

@@
} // namespace @grm_name;
