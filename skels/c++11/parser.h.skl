@("int8_t", "uint8_t", "int16_t", "uint16_t", "int", "uint", "const char*")
@//
// Generated by: @program; @version;
// Grammar:      @grm_file;
// Skeleton:     @skl_file;
// Output:       @out_file;
#ifndef @grm_name;_parser_h
#define @grm_name;_parser_h

#include <cstdint>
#include <cstdlib>
#include <exception>
#include <memory>
#include <vector>

#include "@grm_name;lexer.h"

namespace @grm_name; {
@def_cons?;...

// Terminal state num constants
enum Terminal
{
    @def_cons.1|%s = %d||,\n    |;
};
@@

class ParseError: public std::exception {};
@numb_node?;...

// Base AST node class
class Node;
// Node subclassess to be implemented in the user code
@node_name.1|class %s\;||\n|;
@@

// Parser state which is stored in the stack
struct StackFrame
{
    int state;
    int symbol; // Symbol stacked, terminal (positive) or nonterminal (negative).
    int symbolIndex; // TODO: rename to represent that it's term not symbol and document possible values
    const char *start;
    const char *end;
@numb_node?;...
    std::shared_ptr<Node> node;
@@
};
@numb_node?;...

class Visitor
{
public:
    virtual ~Visitor() {}

    virtual void visit(Node *) {}
    virtual void leave(Node *) {}
    @node_name.1|virtual void visit(%s *) {}||\n    |;
    @node_name.1|virtual void leave(%s *) {}||\n    |;

protected:
    Visitor() {}
};

// TODO think how to uppercase grammar name. Dicumented .u format specifier doesn't work.
#define @grm_name;_NODE \
    protected:\
        virtual void accept(@grm_name;::Visitor *visitor) override {visitor->visit(this);}\
        virtual void seeOff(@grm_name;::Visitor *visitor) override {visitor->leave(this);}\
    private:\

class Node
{
public:
    Node(StackFrame *start, int reductionSize);
    virtual ~Node() {}

    void walk(Visitor *visitor);
    static std::shared_ptr<Node> linkup(StackFrame *start, int reductionSize);

protected:
    virtual void accept(Visitor *visitor) = 0;
    virtual void seeOff(Visitor *visitor) = 0;

protected:
    std::shared_ptr<Node> children;
    std::shared_ptr<Node> next;
};
@numb_nact?;...

class NodeActions
{
public:
    virtual ~NodeActions() {}

    @nact_func.1|virtual void on%s(%s *node) = 0\;||\n    |;
};
@@
@@
@numb_tact?;...

// Token actions interface
class TokenActions
{
public:
    virtual ~TokenActions() {}

    @tact_func.1|virtual int %s(int terminalNumb, const Token &token) = 0\;||\n        |;
};
@@
@numb_pact?;...

class ParseActions
{
public:
    virtual ~ParseActions() {}

    @pact_func.1|virtual void %s(int productionNum, const StackFrame *reductionStart, int reductionSize) = 0\;||\n    |;
};
@@

class Parser
{
public:
    // Parser methods
    Parser();
    ~Parser();

@numb_tact?;...
    void setTokenActions(TokenActions *actions) {tokenActions = actions;}
@@
@numb_pact?;...
    void setParseActions(ParseActions *actions) {parseActions = actions;}
@@
@numb_nact?;...
    void setNodeActions(NodeActions *actions) {nodeActions = actions;}
@@
@numb_node?;...
    std::shared_ptr<Node> parse(const char *input) throw(ParseError);
@@
@numb_node!;...
    void parse(const char *input) throw(ParseError);
@@

// Internal methods
private:
    void reduce(int prodRule);

// Class data
private:
    Lexer lexer;
@numb_tact?;...
    TokenActions *tokenActions;
@@
@numb_pact?;...
    ParseActions *parseActions;
@@
@numb_nact?;...
    NodeActions *nodeActions;
@@
    std::vector<StackFrame> stack;
    size_t stackTop;
    static const size_t stackIncrementStep;
    int stateNum;

// Internal grammar constants
private:
    static const int acceptState;

    // Production rule length minus one(zero based).
    static const @prod_leng.t; ProdLen[]; // TODO: name should start from lowercase

    // Boolean matrix parser tables
    static const @bmat_numb.t; Bm[]; // matrix data.
    static const @bmat_row.t; Br[]; // row(base).
    static const @bmat_col.t; Bc[]; // column(displacement).
@optn_bm.eq.2;...
    static const @bmat_mask.t; Bmask[]; // masks.
@@

    // Terminal transition matrix(gives next state or reduction).
    static const @tmat_numb.t; Tm[]; // matrix data.
    static const @tmat_row.t; Tr[]; // row(base).
    static const @tmat_col.t; Tc[]; // column(displacement).

    // Nonterminal transition matrix(gives next state or reduction).
    static const @nmat_numb.t; Nm[]; // matrix data.
    static const @nmat_row.t; Nr[]; // row(base).
    static const @nmat_col.t; Nc[]; // column(displacement).

    // Reduction matrix(gives reduction).
    static const @rmat_numb.t; Rm[]; // matrix data.
    static const @rmat_row.t; Rr[]; // row(base).
    static const @rmat_col.t; Rc[]; // column(displacement).

@numb_tact?;...
    // Get token action number by terminal number
    static const @tact_numb.t; tokenActionNumber[];
@@
@numb_pact?;...
    // Get parser action number by terminal number
    static const @pact_numb.t; parseActionNumber[];
@@
@numb_nact?;...
    // Node action number
    static const @nact_numb.t; nodeActionNumber[];
@@
    // Get grammar nonterminal symbol number by terminal number
    static const @prod_head.t; nonterminalNumber[];
@numb_node?;...
    // Get id of a node to be created by production number
    static const @node_numb.t; nodeNumber[];
@@
};

} // namespace @grm_name;

#endif // @grm_name;_parser_h
