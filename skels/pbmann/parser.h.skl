
#ifndef @grm_name;_parser_h
#define @grm_name;_parser_h

@("char", "uchar", "short", "ushort", "int", "uint", "char*") 
@//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    PARSER.H

/*    Generated by: @program; @version;
      Grammar:      @grm_file;
      Skeleton:     @skl_file;
      Output:       @out_file;
*/               
		#include "stdio.h"
		#include "@grm_name;_lexer.h"

		#define uint unsigned int

		#ifndef UINT_MAX
	  	#define UINT_MAX 0xffffffff 					// for 32-bit CPUs.			
	// #define UINT_MAX 0xffffffffffffffff 		// for 64-bit CPUs.			
		#endif
		#define EOF_CHAR  26 // End Of File character.  

@def_cons?;...
	// Defined constants ... 
		enum def_con
		{
         @def_cons.1|%s = %d||,\n         |;
		};

@@
@numb_node?;...
   // Defined constants for the node names (uppercase) ...
		enum node_name
      {
         @node_name.1|%20u = %d||,\n         |;
      };

@@
		class Symbol             
		{
		public:
			char*  name;	 // Pointer to symbol name.														4		
			int    length;	 // Length  of symbol name.														4
			int    level;	 // Level number for scope.                                        	4
			int    term;	 // Terminal number (e.g. <identifier>, <string>, {typedef}, ...)		4
         uint   type;	 // Type (e.g. integer, float, double, char, ...)							4
			int    cell;	 // Hash vector cell number for deleting this symbol.						4  24 bytes
		};

		class Symtab 
		{
		public:
			static Symbol*  symbol;			// Symbols.
			static int      n_symbols;		// Number of symbols.
			static int      n_keywords;	// Number of keywords in symbol table.
			static int      length;			// Current length of symbol name.
			static int      cell;			// Current hash cell number.
			static int      sti;				// Current symbol-table index.
			static uint     hashdiv;		// Hash divisor. 
			static int*     hashvec;		// Hash vector.
			static int      max_symbols;	// Maximum number of symbols.
			static int      max_cells;    // Maximum number of cells in the hash vector. 
		};

		class Node                
		{
		public:
			int    id;		 // Node id number    									4	 	
			int    prod;	 // Production number            					4	 	
			int    sti;     // Symbol-table index (perm or temp var).		4	 
			int    prev;	 // Previous node.			   						4  
			int    next;	 // Next node.												4  
			int    line;    // Line number.                                4   
			int    child;   // Child node.                                	4   
			int    parent;  // Parent node.                             	4  32 bytes per node
		}; 
  
      class Stack
      {
         public:
         int    id;      // Node id.                      4	 	
         int    counter; // Counter of node accesses.     4	 8 bytes
      };

		class AST 
		{
			public:	
			static char     indent[256];	// Indentation for printing current node.
         static int*     counter;		// Node counter array.
         static int      stacki;			// AST stack index.
         static Stack*   stack;			// AST stack array.
			static Node*    node;			// AST node array.
			static int      root;			// Root node number.
			static int      n_nodes;		// Number of nodes.
			static int      max_nodes;		// Maximum number of nodes.
		};

	// AST Action Mode. 
      #define TOP_DOWN   0	 // Top down status.  
   	#define PASS_OVER  1  // Pass over status.
   	#define BOTTOM_UP  2  // Bottom up status.  
   
      class PStack // Parser stack.
      {
         public:
         int    state;	 // Parser state.                 4	 4	
         int    sti;     // Symbol table index.           4	 8	
         int    line;    // Input line number.            4	12	
         int    node;    // Node number.                  4	16	
         int    last;    // Last in list number.          4	20	bytes per cell.
			int    sym;     // Symbol stacked, terminal (positive) or nonterminal (negative). 
      };

      class RStack // Restore Stack.
      {
         public:
         PStack* ptr;	 // Parse stack pointer.			4	4	
         int     state;  // State.								4	8	bytes.
      };

      class @grm_name;_parser : public @grm_name;_lexer, public Symtab, public AST
		{
		public:

			static int    	init(char*, FILE*, int, int);	// Parser initialization.
			static void   	term();								// Parser termination.

			static int    	parse       (char* input_start);	
			static void   	parse_term  ();	
			static int    	add_symbol  (int, char*, char*);
			static int    	get_symbol  (char*, char*); 
			static int  	emitstr	   (int n, char* str);
			static char*  	symbol_name (int);

			static int     status;					// Status for parser actions and AST actions.
			static char*   inputname;				// Input file name.
			static FILE*   outputdesc;				// Output file desc.
         static PStack* PS;           			// Parse Stack pointer.       
         static PStack* PS_end;         		// Parse Stack end.       
         static int*    SS;           			// State Stack pointer.       
         static int*    SS_end;         		// State Stack end.       

			static @tact_arg.7t; tact_arg[];		// Token-action argument index (for first arg).
			static @pact_arg.7t; pact_arg[];		// Parse-action argument index (for first arg).
			static @nact_arg.7t; nact_arg[];		// Node-action  argument index (for first arg).
			static @arg_numb.7t; arg_numb[];		// Argument numbers. 	
			static @arg_text.7t; arg_text[];		// Argument text (if a string argument or node arg).
			static @term_symb.7t; term_symb[];  // Terminal symbols of the grammar.
			static @head_symb.7t; head_symb[];  // Head (nonterminal) symbols of the grammar.
			static @prod_head.7t; head_numb[];  // Head symbol number for a production (rule).

		private:

			static @prod_leng.7t; PL[];			// Production (rule) length less one (zero based).
			static int     n_errors;				// Number of errors.
			static int     max_errs;				// Maximum allowable errors.
			static int     n_terms;					// Number of terminal symbols in grammar.
			static int     n_heads;					// Number of head symbols in grammar.
			static int     n_prods;					// Number of productions (rules) in grammar.
			static int     n_states;				// Number of states in parser state machine.
			static int     eof_symb;				// <eof> symbol number.
			static int     eol_symb;				// <eol> symbol number.
			static int     err_used;				// <error> used in grammar?
                                       		                                   
         static RStack* RS;           			// Reduction Stack pointer.
			static int     n_nodenames;			// Number of node names in grammar.
			static int     n_nodeactns;			// Number of node processors (AST actions).
			static char*   node_name[];			// Node names array.

			static char*   T_list;					// Terminal symbol list (0 or 1).
			static int*    P_list;					// Production list.
         static RStack  R_stack[];				// Reduction stack.
         static PStack  P_stack[];				// Parser stack.
         static int     S_stack[];				// State stack.
			static PStack* PStop;				   // Top pointer for parser stack.
			static int     topstate;				// Top state (before reductions start).

			static @nact_numb.7t; nact_numb[];  // Node action numbers.
			static @tact_numb.7t; tact_numb[];  // Token action number. 
			static @pact_numb.7t; pact_numb[];  // Production action number (for a parser action).
			static @node_numb.7t; node_numb[];  // Node number index for a production (rule).

			static @bmat_numb.7t; Bm[];			// Boolean matrix (0 or 1).
			static @bmat_row. 7t; Br[];			// Boolean matrix row (base).
			static @bmat_col. 7t; Bc[];			// Boolean matrix column (displacement).
			static @bmat_mask.7t; Bmask[];		// Boolean matrix mask.

			static @tmat_numb.7t; Tm[];			// Terminal transition matrix (gives next state or reduction).
			static @tmat_row. 7t; Tr[];			// Terminal transition matrix row (base).
			static @tmat_col. 7t; Tc[];			// Terminal transition matrix column (displacement).

			static @nmat_numb.7t; Nm[];			// Nonterminal transition matrix (gives next state or reduction).
			static @nmat_row. 7t; Nr[];			// Nonterminal transition matrix row (base).
			static @nmat_col. 7t; Nc[];			// Nonterminal transition matrix column (displacement).

			static @rmat_numb.7t; Rm[];			// Reduction matrix (gives reduction).
			static @rmat_row. 7t; Rr[];			// Reduction matrix row (base).
			static @rmat_col. 7t; Rc[];			// Reduction matrix column (displacement).

			static @prod_revs.7t; reverse[];		// Reverse order of nodes for this production (rule)?
			static @prod_tail.7t; f_tail[];		// First tail symbol for a production.
			static @tail_numb.7t; tail[];			// Tail symbols for productions.

			static @nd_start. 7t; nd_start[];
			static @nd_term.  7t; nd_term[]; 
			static @nd_action.7t; nd_action[]; 

		// Parser functions
  		  	static int		(*tact_func[]) (int&);	// Parser action function pointers.
  		  	static int	   (*pact_func[]) (int);		// Parser action function pointers.
			static int	   (*nact_func[]) (int);		// Node action function pointers.

  		  	static char*	tact_name[];					// Parser action name.
  		  	static char*	pact_name[];					// Parser action name.
  		  	static char*	nact_name[];					// Node action names.

			static int		nd_parse			(int*, int*, int*, int x, int t, int a);
			static int		reduce			(int p);
			static int		linkup			(int p);
			static void		rebuild			();                           
			static void		prt_help			();
			static int	   err_rec			(int, int);
			static int	   lookahead		(int t, int x);
			static void		get_list			(int);
			static void		prt_error		(char*);
			static void		prt_prod			(int); 
			static void		prt_stack		(); 
			static void		expecting		(int x); 
			static void		collect			(int x);
			static void		reduce			(int p, int x);
			static void		prt_list			(int t);

		// Symtab functions
			static int		init_symtab		(int);		// Initialize the symbol table.
			static void		term_symtab		();			// Initialize the symbol table.
			static void		print_symtab	(char**);
         static void		prt_line			();

		// AST functions
			static int		init_ast			(int);
			static void		term_ast			();
			static void		print_ast		();
			static void		print_ast		(int n);
			static void		print_node		(char *indent, int n);
         static void		traverse			();
         static void		traverse			(int n);
			static void		traverse			(char *indent, int n);
		};

#endif

