
@("char", "uchar", "short", "ushort", "int", "uint", "char*") 
@//
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//    LRSTAR Parser Tables.

/*    Generated by: @program; @version;
      Grammar:      @grm_file;																									    
      Skeleton:     @skl_file;
      Output:       @out_file;
*/               
		#include "string.h"
  		#include "@grm_name;_parser.h"
  		#include "@grm_name;_actions.h"   

		#define ACCEPT_STATE	@accp_sta.6d; // Final state.

/*--- Constants. -------------------------------------------------------------*/
                                                                                          
      int @grm_name;_parser::n_terms      = @numb_term.5d;; // No. of terminals.                               
      int @grm_name;_parser::n_heads      = @numb_head.5d;; // No. of non-terminals.     
      int @grm_name;_parser::n_prods      = @numb_prod.5d;; // No. of productions.       
      int @grm_name;_parser::n_states     = @numb_sta. 5d;; // No. of states.
      int @grm_name;_parser::eol_symb     = @eol_numb. 5d;; // EOL symbol number            
      int @grm_name;_parser::eof_symb     = @eof_numb. 5d;; // EOF symbol number            
      int @grm_name;_parser::err_used     = @err_used. 5d;; // <error> used in grammar      
      int @grm_name;_parser::n_nodenames  = @numb_node.5d;; // No. of node names.   
      int @grm_name;_parser::n_nodeactns  = @numb_nact.5d;; // No. of node actions.   

/*--- Terminal and Nonterminal Symbols of the Grammar. -----------------------*/

   // Terminal symbols of the grammar. 
      @term_symb.t; @grm_name;_parser::term_symb[@term_symb.d;] = 
      {
         @term_symb.1|"%s"|,|,\n         |;
      };                                                 

@optn_exp?.or.@optn_debug?;...
   // Head symbols of the grammar. 
      @head_symb.t; @grm_name;_parser::head_symb[@head_symb.d;] = 
      {
         @head_symb.1|"%s"|,|,\n         |;
      };
  
@@
   // Head symbol for a production 
      @prod_head.t; @grm_name;_parser::head_numb[@prod_head.d;] = 
      {
      @prod_head.20|%5d|,|,\n      |;
      };

@optn_debug?;...
   // Index to first tail symbol for a production 
      @prod_tail.t; @grm_name;_parser::f_tail[@prod_tail.d;] = 
      {
      @prod_tail.20|%5d|,|,\n      |;
      };

   // Tail symbol numbers (T: >= 0, NT: < 0)
      @tail_numb.t; @grm_name;_parser::tail[@tail_numb.d;] = 
      {
      @tail_numb.20|%5d|,|,\n      |;
      };

@@
/*--- Bit Matrix and Access Vectors. -----------------------------------------*/

   // B_matrix.  
      @bmat_numb.t; @grm_name;_parser::Bm [@bmat_numb.d;] = 
      {
      @bmat_numb.20|%5d|,|,\n      |;
      };

   // B_matrix row. 
      @bmat_row.t; @grm_name;_parser::Br [@bmat_row.d;] = 
      {
      @bmat_row.20|%5d|,|,\n      |;
      };

   // B_matrix column.
      @bmat_col.t; @grm_name;_parser::Bc [@bmat_col.d;] = 
      {
      @bmat_col.20|%5d|,|,\n      |;
      };
  
@optn_bm.eq.2;...
	// B_matrix column.
      @bmat_mask.t; @grm_name;_parser::Bmask [@bmat_mask.d;] = 
      {
      @bmat_mask.20|%5d|,|,\n      |;
      };
  
@@
/*--- Terminal Transition Matrix and Access Vectors. -------------------------*/

   // T_matrix. 
      @tmat_numb.t; @grm_name;_parser::Tm [@tmat_numb.d;] = 
      {
      @tmat_numb.20|%5d|,|,\n      |;
      };

   // T_matrix row. 
      @tmat_row.t; @grm_name;_parser::Tr [@tmat_row.d;] = 
      {
      @tmat_row.20|%5d|,|,\n      |;
      };

   // T_matrix column. 
      @tmat_col.t; @grm_name;_parser::Tc [@tmat_col.d;] = 
      {
      @tmat_col.20|%5d|,|,\n      |;
      };

/*--- Nonterminal Transition Matrix and Access Vectors. ----------------------*/

   // N_matrix. 
      @nmat_numb.t; @grm_name;_parser::Nm [@nmat_numb.d;] = 
      {
      @nmat_numb.20|%5d|,|,\n      |;
      };

   // N_matrix row. 
      @nmat_row.t; @grm_name;_parser::Nr [@nmat_row.d;] = 
      {
      @nmat_row.20|%5d|,|,\n      |;
      };

   // N_matrix column. 
      @nmat_col.t; @grm_name;_parser::Nc [@nmat_col.d;] = 
      {
      @nmat_col.20|%5d|,|,\n      |;
      };

/*--- Reduction Matrix and Access Vectors. -----------------------------------*/

   // R_matrix. 
      @rmat_numb.t; @grm_name;_parser::Rm [@rmat_numb.d;] = 
      {
      @rmat_numb.20|%5d|,|,\n      |;
      };

   // R_matrix row. 
      @rmat_row.t; @grm_name;_parser::Rr [@rmat_row.d;] = 
      {
      @rmat_row.20|%5d|,|,\n      |;
      };

   // R_matrix column. 
      @rmat_col.t; @grm_name;_parser::Rc [@rmat_col.d;] = 
      {
      @rmat_col.20|%5d|,|,\n      |;
      };

@nd_action?;...
/*--- Nondeterministic Parsing Arrays. ---------------------------------------*/

   // Nondeterministic Start. 
      @nd_start.t; @grm_name;_parser::nd_start [@nd_start.d;] = 
      {
      @nd_start.20|%5d|,|,\n      |;
      };

   // Nondeterministic Terminal Symbol. 
      @nd_term.t; @grm_name;_parser::nd_term [@nd_term.d;] = 
      {
      @nd_term.20|%5d|,|,\n      |;
      };

   // Nondeterministic Action.
      @nd_action.t; @grm_name;_parser::nd_action [@nd_action.d;] = 
      {
      @nd_action.20|%5d|,|,\n      |;
      };

@@
@nd_action!;...
/*--- Nondeterministic Parsing Arrays. ---------------------------------------*/

   // Nondeterministic Start. 
      @nd_start.t; @grm_name;_parser::nd_start [@nd_start.d;] = 
      {
      @nd_start.20|%5d|,|,\n      |;
      };

   // Nondeterministic Terminal Symbol. 
      @nd_term.t; @grm_name;_parser::nd_term [1] = 
      {
         0
      };

   // Nondeterministic Action.
      @nd_action.t; @grm_name;_parser::nd_action [1] = 
      {
         0
      };

@@
/*--- Production Variables. --------------------------------------------------*/

   // Production length - 1 
      @prod_leng.t; @grm_name;_parser::PL[@prod_leng.d;] = 
      {
      @prod_leng.20|%5d|,|,\n      |;
      };

   // Reverse the order of nodes (for a production/rule).
      @prod_revs.t; @grm_name;_parser::reverse[@prod_revs.d;] = 
      {
      @prod_revs.20|%5d|,|,\n      |;
      };

/*--- Token Action Variables -------------------------------------------------*/

	// Token Action number. 
      @tact_numb.t; @grm_name;_parser::tact_numb[@tact_numb.d;] = 
      {
      @tact_numb.20|%5d|,|,\n      |;
      };

@numb_tact?;...
   // Token Action Function Pointers.	
      int (*@grm_name;_parser::tact_func[@tact_func.d;]) (int&) = 
      {
			@tact_func.1|@grm_name;_token_action::%s|,|,\n         |;
      };

	// First argument index for token actions.
      @tact_arg.t; @grm_name;_parser::tact_arg[@tact_arg.d;] = 
      {
      @tact_arg.20|%5d|,|,\n      |;
      };

@@
@numb_tact!;...
   // Token Action Function Pointers.	
      int (*@grm_name;_parser::tact_func[1]) (int&) = 
      {
			0
      };

		// First argument index for token actions.
      @tact_arg.t; @grm_name;_parser::tact_arg[1] = 
      {
         0
      };

@@
@numb_pact?;...
/*--- Parser Action Variables ------------------------------------------------*/

   // Parser Action Number
      @pact_numb.t; @grm_name;_parser::pact_numb[@pact_numb.d;] = 
      {
      @pact_numb.20|%5d|,|,\n      |;
      };

   // Parser Action Function Pointers	
      int (*@grm_name;_parser::pact_func[@pact_func.d;]) (int) = 
      {
			@pact_func.1|@grm_name;_parse_action::%s|,|,\n         |;
      };

@@ 
@numb_pact!;...
/*--- Parser Action Variables ------------------------------------------------*/

   // Parser Action Number
      @pact_numb.t; @grm_name;_parser::pact_numb[@pact_numb.d;] = 
      {
      @pact_numb.20|%5d|,|,\n      |;
      };

   // Parser Action Function Pointers	
      int (*@grm_name;_parser::pact_func[1]) (int) = 
      {
			0
      };

@@ 
@pact_arg?;...
	// Parser Action Argument Index and first argument for make_node.
      @pact_arg.t; @grm_name;_parser::pact_arg[@pact_arg.d;] = 
      {
      @pact_arg.20|%5d|,|,\n      |;
      };

@@
/*--- Make-Node Variables ----------------------------------------------------*/

   // Make-Node Numbers (for a production).
      @node_numb.t; @grm_name;_parser::node_numb[@node_numb.d;] = 
      {
      @node_numb.20|%5d|,|,\n      |;
      };

@node_name?;...
   // Node Names.
      @node_name.t; @grm_name;_parser::node_name[@node_name.d;] = 
      {
      @node_name.1|"%s"||,\n      |;
      };
@@
@node_name!;...
   // Node Names.
      @node_name.t; @grm_name;_parser::node_name[1] = 
      {
         ""
      };
@@

/*--- Node-Action Variables --------------------------------------------------*/

   // Node-Action Numbers. 
      @nact_numb.t; @grm_name;_parser::nact_numb[@nact_numb.d;] = 
      {
      @nact_numb.20|%5d|,|,\n      |;
      };

@numb_nact?;...
	// Node-Action Function Pointers.
      int (*@grm_name;_parser::nact_func[@nact_func.d;]) (int n) = 
      {
			@nact_func.1|@grm_name;_node_action::%s|,|,\n         |;
      };   

   // Node Action Argument Index
      @nact_arg.t; @grm_name;_parser::nact_arg[@nact_arg.d;] = 
      {
      @nact_arg.20|%5d|,|,\n      |;
      };

@@ 
@numb_nact!;...
	// Node-Action Function Pointers.
      int (*@grm_name;_parser::nact_func[1]) (int n) = 
      {
			0
      };   

   // Node Action Argument Index
      @nact_arg.t; @grm_name;_parser::nact_arg[1] = 
      {
         0
      };

@@ 
@arg_numb?;...
/*--- Argument Numbers. ------------------------------------------------------*/

   // Parse action argument numbers 
      @arg_numb.t; @grm_name;_parser::arg_numb[@arg_numb.d;] = 
      {
      @arg_numb.20|%5d|,|,\n      |;
      };

@@
@arg_numb!;...
/*--- Argument Numbers. ------------------------------------------------------*/

   // Parse action argument numbers 
      @arg_numb.t; @grm_name;_parser::arg_numb[1] = 
      {
         0
      };

@@
@arg_text?;...
   // Text for string arguments. 
      char* @grm_name;_parser::arg_text[@arg_text.d;] = 
      {
         @arg_text.1|"%s"|,|,\n         |;
      };

@@
@arg_text!;...
   // Text for string arguments. 
      char* @grm_name;_parser::arg_text[1] = 
      {
         ""
      };

@@

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    LRSTAR Parser.

		#include "string.h"

		#define STKSIZE    1000 // Parser stack size.    
		#ifndef LOOKAHEADS
		#define LOOKAHEADS 3		// Number of lookaheads for LR(*) parsing.
		#endif

		#ifndef UINT_MAX
	  	#define UINT_MAX 0xffffffff 					// for 32-bit CPUs.			
	// #define UINT_MAX 0xffffffffffffffff 		// for 64-bit CPUs.			
		#endif

	// Parser stuff ...
		PStack*  @grm_name;_parser::PS;                  
		PStack*  @grm_name;_parser::PS_end;                  
      PStack   @grm_name;_parser::P_stack[STKSIZE];   
		int      @grm_name;_parser::n_errors;
		int      @grm_name;_parser::max_errs;
		int      @grm_name;_parser::status;
		char*		@grm_name;_parser::inputname;
		FILE*		@grm_name;_parser::outputdesc;

	// Restore stack stuff ...
      RStack*	@grm_name;_parser::RS; 
      RStack	@grm_name;_parser::R_stack[STKSIZE]; 
  		PStack*  @grm_name;_parser::PStop;
  		int      @grm_name;_parser::topstate;

	// Symbol table stuff ...
      Symbol*  Symtab::symbol;
		int      Symtab::cell;
		int      Symtab::sti;
		int      Symtab::length;
		int      Symtab::n_symbols;
		int      Symtab::n_keywords;
		uint     Symtab::hashdiv;
		int*		Symtab::hashvec;
		int		Symtab::max_cells;
		int		Symtab::max_symbols;

@make_ast?;...
		// AST stuff ...
		Node*    AST::node;
		int      AST::root;
  		int      AST::n_nodes;
  		int      AST::max_nodes;

@@
@optn_exp?;...
		char*    @grm_name;_parser::T_list;					// Terminal symbol list (0 or 1).
		int*     @grm_name;_parser::P_list;					// Production list.

@@
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    @grm_name;_parser -  initialization																  

int   @grm_name;_parser::init (char* Inputname, FILE* Outputdesc, int max_symb, int max_node)
{
		inputname  = Inputname;										// Move name into parser object.
		outputdesc = Outputdesc;									// Move desc into parser object.

		if (!init_symtab (max_symb)) return (0);           // Initialize the symbol table.
@make_ast?;...
		if (!init_ast (max_node)) return (0);              // Initialize the AST. 
@@
		token.start = "";                                  // Make a blank symbol.
		token.end   = token.start + 1;
		add_symbol (0, token.start, token.end);				// Add it to the symbol table.

      n_errors = 0;							                  // Set number of errors.    
      max_errs = 10;							                  // Set max number of errors.
		return (1); // Return OK.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    @grm_name;_parser -  termination

void  @grm_name;_parser::term ()
{
		print_symtab (term_symb);			                  // Print the symbol table contents.
@make_ast?;...
		print_ast ();							                  // Print the AST, if ast option indicates.
		traverse	 ();							                  // Traverse the AST, calling the AST actions.
		term_ast  ();
@@
		term_symtab ();
}

@optn_clr?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		Canonical LR Parser

int   @grm_name;_parser::parse (char* input_start)                
{
      int p;															// Production (rule) number.  
      int t;															// Terminal symbol number. 
      int x = 0;														// State number.  

		lexer_init (input_start);				               // Initialize lexer.
      PS_end = P_stack + STKSIZE;			               // Set parse-stack end pointer.   
      PS     = P_stack;							               // Set parse-stack pointer.   

Read:	t = get_token ();												// Get incoming token. 
@optn_debug?;...
		prt_line ();
@@
		token.sti = -t;												// Symbol-table index = -t.
      if (tact_numb[t] >= 0)					               // If token action ...         
      {
         token.sti = (*tact_func [tact_numb[t]])(t);     // Call token-action function.
      }
Shft: if (Bm [Br[x] + Bc[t]])										// Check B-matrix for shift action. 
      {
			if (++PS >= PS_end) goto Over;
         PS->state = x;                                  // Put current state on stack.  
@optn_exp.gt.1;...
         PS->sym   = t;												// Put token number on stack.
@@
@make_ast?;...
			PS->sti   = token.sti;                          // Put token symbol-table-index on stack.
         PS->line  = token.linenumb;                     // Put its line number on stack.
         PS->node  = 0;						                  // Set node on stack to zero.   
@@
         x = Tm [Tr[x] + Tc[t]];                         // Get next state from terminal transition matrix.
         goto Read;								               // Go to read next token.
      }
		if ((p = Rm [Rc[t] + Rr[x]]) > 0)						// Get reduction?
      {
         PS -= PL[p];												// Reduce parse stack ptr by rule length - 1. 
         if (PL[p] < 0)							               // Null production?
         {	
				if (PS >= PS_end) goto Over;
            PS->state = x;						               // Stack current state, replacing old state.
@make_ast?;...
            PS->node  = 0;						               // Clear node pointer.
@@
         }
@optn_exp.gt.1;...
         PS->sym = -head_numb[p];								// Put head symbol number on stack.
@@
@numb_pact?.or.@numb_node?;...
      	if (!reduce(p)) return -linenumb;					// Call reduce action with rule number.
@@
         x = Nm [Nr[PS->state] + Nc[p]];						// Get next state from nonterminal transition.
         goto Shft;													// Continue parsing.
      }
      if (x == ACCEPT_STATE)					               // If Goal production.  
      {
         PS -= PL[0];                                    // Reduce parse stack ptr by rule length - 1. 
@optn_exp.gt.1;...
         PS->sym = 0;												// Put head symbol number on stack.
@@
@numb_pact?.or.@numb_node?;...
     	  	if (!reduce(0)) return -linenumb;					// Call reduce action with rule number.
@@
         if (linenumb > 0) --linenumb;							// Reduce line number by one.
@make_ast?;...
			root = PS[0].node;                              // Define root node.
@@
			return linenumb;						               // Return number of lines parsed.
      }

		prt_error (term_symb[t]);				               // Print syntax error message. 
@optn_exp.gt.1;...
		prt_stack ();
@@
@optn_exp?;...
		expecting (x);													// Print expecting list.
@@
		return -linenumb;							               // Return negative number of lines for failure. 

Over: printf  ("\nParser stack overflow.\n\n");
		return -linenumb;							               // Return negative number of lines for failure. 
}

@@
@optn_lr?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		Minimal LR Parser

int   @grm_name;_parser::parse (char* input_start)                
{
      int p;                                          	// Production (rule) number.  
      int t;                                          	// Terminal symbol number. 
      int x = 0;                                      	// State number.  

@optn_nd?;...
      PStack *P;														// Expecting option stack.
      int    *SS, *SS_end;											  
      int    S_stack[STKSIZE];
      int    max_nla, nla, action;
      SS_end = S_stack + STKSIZE;
@@
		lexer_init (input_start);									// Initialize lexer.
      PS_end = P_stack + STKSIZE;			            	// Set parse-stack end pointer.   
      PS     = P_stack;							            	// Set parse-stack pointer.   

Read:	t = get_token ();												// Get incoming token.
@optn_exp?;...
      RS = R_stack;                                   	// Set restore-stack pointer.
		PStop = PS;								               	// Save parse-stack pointer.
		topstate = x;								            	// Save current state.
@@
@optn_debug?;...
		prt_line ();
@@
		token.sti = -t;												// Symbol-table index = -t.
      if (tact_numb[t] >= 0)					            	// If token action ...         
      {
         token.sti = (*tact_func [tact_numb[t]])(t);  	// Call token-action function.
      }
Shft: if (Bm [Br[x] + Bc[t]] & Bmask[t])	            	// Check B-matrix for shift action. 
      {
			if (++PS >= PS_end) goto Over;						// Check for stack overflow.
         PS->state = x;                               	// Put current state on stack.  
@optn_exp.gt.1;...
         PS->sym   = t;							            	// Put terminal number on stack.
@@
@make_ast?;...
         PS->sti   = token.sti;                       	// Put token symbol table index on stack.
         PS->line  = token.linenumb;                  	// Put its line number on stack.
         PS->node  = 0;						               	// Set node on stack to zero.   
@@
         x = Tm [Tr[x] + Tc[t]];                      	// Get next state from terminal transition matrix.
         while (x <= 0)                               	// While shift-reduce actions. 
         {
@optn_nd?;...
SRed:			p = -x;													// Reduce stack by production p.	
@@
@optn_nd!;...
				p = -x;													// Reduce stack by production p.	
@@
            PS -= PL[p];											// Reduce stack ptr by production length. 
@optn_exp.gt.1;...
	         PS->sym = -head_numb[p];							// Put head symbol number on stack.
@@
@numb_pact?.or.@numb_node?;...
			  	if (!reduce(p)) return -linenumb;				// Call reduce action with rule number.
@@
            x = Nm [Nr[PS->state] + Nc[p]];					// Get next state from nonterminal transition.
         }
         goto Read;								               // Go to read next token.
      }
		if ((p = Rr[x]) > 0 || (p = Rm [Rc[t] - p]) > 0)   // Get reduction?
      {
@optn_nd?;...
Red:		PS -= PL[p];												// Reduce parse stack ptr by rule length - 1. 
@@
@optn_nd!;...
			PS -= PL[p];												// Reduce parse stack ptr by rule length - 1. 
@@
         if (PL[p] < 0)							               // Null production?
         {	
				if (PS >= PS_end) goto Over;						// Check for overflow.
@optn_exp?;...
				(++RS)->ptr = PS;					               // Save parse-stack pointer.
     		   RS->state = PS->state;			               // Save old state before replacing it.
@@
@make_ast?;...
            PS->node  = 0;						               // Clear node pointer.
@@
            PS->state = x;						               // Stack current state, replacing old state.
         }
         while (1) 
         {
@optn_exp.gt.1;...
	         PS->sym = -head_numb[p];							// Put head symbol number on stack.
@@
@numb_pact?.or.@numb_node?;...
      		if (!reduce(p)) return -linenumb;				// Call reduce action with rule number.
@@
            x = Nm [Nr[PS->state] + Nc[p]];	            // Get next state from nonterminal transition.
            if (x > 0) goto Shft;                        // Continue parsing.
            p = -x;								               // Set production number.
            PS -= PL[p];                                 // Reduce parse stack ptr by rule length - 1. 
         }
		}
@optn_nd?;...
      max_nla = 0;
		for (int i = nd_start[x]; i < nd_start[x+1]; i++)
		{
         if (nd_term[i] == t) 
			{
            for (SS = S_stack, P = P_stack; P < PS;) *++SS = (++P)->state;
            nla = nd_parse (S_stack, SS, SS_end, x, t, nd_action[i]);
            if (nla > max_nla)
            {
               max_nla = nla;
               action = nd_action[i];
            }
         }
         else if (nd_term[i] > t) break;						// nd_term is sorted, so we are done.
		}
      if (max_nla > 0)
      {
         if (action > 0)                                 // Shift and Goto?
         {
      	   if (++PS >= PS_end) goto Over;					// Check for overflow.
            PS->state = x;                               // Put current state on stack.   
            if (action > ACCEPT_STATE)                   // Shift and reduce?
            {
               x = ACCEPT_STATE - action;						// Convert to production #
               goto SRed;                                // Shift-Reduce.
            }
            x = action;                                  // Get next state.
            goto Read;												// Get next token.
         }
         else															// Reduce!
         {
            p = -action;                                 // Get production.
            goto Red;                                    // Reduce.
         }
      }
@@
      if (x == ACCEPT_STATE)					               // If Goal production.  
      {
         PS -= PL[0];                                    // Reduce parse stack ptr by rule length - 1. 
@optn_exp.gt.1;...
         PS->sym = 0;												// Put head symbol number on stack.
@@
@numb_pact?.or.@numb_node?;...
     	  	if (!reduce(0)) return -linenumb;					// Call reduce action with rule number.
@@
         if (linenumb > 0) linenumb = --linenumb;			// Reduce line number by one.
@make_ast?;...
			root = PS[0].node;                              // Define root node.
@@
			return linenumb;						               // Return number of lines parsed.
      }

		prt_error (term_symb[t]);				               // Print syntax error message. 
@optn_exp.gt.1;...
		prt_stack ();
@@
@optn_exp?;...
		expecting (topstate);					               // Print syntax help (list of tokens expected). 
@@
		return -linenumb;							               // Return negative number of lines for failure. 

Over: printf  ("\nParser stack overflow.\n\n");
		return -linenumb;							               // Return negative number of lines for failure. 
}

@optn_nd?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		nd_parse - nondeterministic parse

int   @grm_name;_parser::nd_parse (int* P_stack, int* PS, int* PS_end, int x, int t, int action)
{
      int   p, lookaheads;
      char* TS = token.start;
      char* TE = token.end;
      int   LN = linenumb;

      int   *P;
      int   max_nla, nla;
      int   *SS, *SS_end;
      int   S_stack[STKSIZE];
      SS_end  = S_stack + STKSIZE;
      lookaheads = 0;
		goto Act;

Read:	t = get_token ();												// Get first token. 
      if (tact_numb[t] >= 0)					               // Need this if-statement for typedef names.         
      {
         (*tact_func [tact_numb[t]])(t);						// Call token-action function, maybe change t.
      }
Shft: if (Bm [Br[x] + Bc[t]] & Bmask[t])	               // Check B-matrix for shift action. 
      {
      	if (++PS >= PS_end) goto Over;
         if (++lookaheads == LOOKAHEADS) goto Ret;

         *PS = x;                                        // Put current state on stack.   
         x = Tm [Tr[x] + Tc[t]];                         // Get next state from terminal transition matrix.
         while (x < 0)                                   // While shift-reduce actions. 
         {
SRed:       PS -= PL[-x];                                // Reduce stack ptr by production length. 
            x = Nm [Nr[*PS] + Nc[-x]];	                  // Get next state from nonterminal transition matrix.
         }
         goto Read;								               // Go to read next token.
      }
		if ((p = Rr[x]) > 0 || (p = Rm [Rc[t] - p]) > 0)   // Get reduction?
      {
Red:		PS -= PL[p];												// Reduce parse stack ptr by rule length - 1. 
         if (PL[p] < 0)							               // Null production?
         {	
				if (PS >= PS_end) goto Over;						// Check for stack overflow.
            *PS = x;						                     // Stack current state, replacing old state.
         }
         while (1) 
         {
   		   x = Nm [Nr[*PS] + Nc[p]];	                  // Get next state from nonterminal transition.
            if (x > 0) goto Shft;			               // If a state, continue parsing.
            p = -x;								               // Make the production number positive.
            PS -= PL[p];                                 // Reduce parse stack ptr by rule length - 1. 
         }
      }
      max_nla = 0;
		for (int i = nd_start[x]; i < nd_start[x+1]; i++)
		{
         if (nd_term[i] == t) 
         {
            for (SS = S_stack, P = P_stack; P < PS;) *++SS = *++P;
            nla = nd_parse (S_stack, SS, SS_end, x, t, nd_action[i]);
            if (nla > max_nla)
            {
               max_nla = nla;
               action = nd_action[i];
            }
         }
         else if (nd_term[i] > t) break;						// nd_term is sorted, so we are done.
		}
      if (max_nla > 0)
		{
Act:		if (action > 0)                                 // Shift and Goto?
			{
      		if (++PS >= PS_end) goto Over;
				if (++lookaheads == LOOKAHEADS) goto Ret;
				*PS = x;                                     // Put current state on stack.   
				if (action > ACCEPT_STATE)                   // Shift and reduce?
				{
					x = ACCEPT_STATE - action;						// Convert to production #
					goto SRed;                                // Shift-Reduce.
				}
				x = action;                                  // Get next state.
				goto Read;												// Get next token.
			}
			else															// Reduce!
			{
				p = -action;                                 // Get production.
				goto Red;												// Reduce.
			}
		}
      if (x == ACCEPT_STATE)					               // If Goal production.  
      {
         lookaheads = LOOKAHEADS;
      }

Ret:  token.start = TS; 
      token.end   = TE;
      linenumb    = LN;
      return lookaheads;                                 // Syntax error, return zero lookaheads.

Over: printf  ("\nParser stack overflow.\n\n");
		return 0; // Return error.
}

@@
@@
@numb_pact?.or.@make_ast?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		reduce

int   @grm_name;_parser::reduce (int p)
{
@numb_pact?;...
		if (pact_numb[p] >= 0)	  									// PARSE ACTION ?  
		{
			return (*pact_func [pact_numb[p]])(p);				// Call parse action with production number.
		}
@@
@make_ast?;...
		int psi;	 														// Parse Stack Index.
		if (node_numb[p] >= 0)   					            // MAKE NODE ?
		{
			if (n_nodes >= max_nodes)						      // If too many nodes?  
			{
				printf  (            "Number of AST nodes exceeds limit of %d.\n", max_nodes);
				fprintf (outputdesc, "Number of AST nodes exceeds limit of %d.\n", max_nodes);
				return (0);										
			}
			node[n_nodes].id     = node_numb[p];			   // Set node id. 
			node[n_nodes].prod   = p;							   // Put production (rule) number in node.
			node[n_nodes].prev   = 0;							   // Set prev to nonexistent.
			node[n_nodes].next   = 0;							   // Set next to nonexistent.
			node[n_nodes].child  = 0;							   // Set child to nonexistent.
			node[n_nodes].parent = 0;							   // Set parent to nonexistent.
			if (pact_arg[p] >= 0)				   		      // If first parse-action argument specified in grammar.
			{
				psi = arg_numb[pact_arg[p]]-1;	   	      // Get parse-stack index.
				node[n_nodes].sti  = PS[psi].sti;		      // Move sti from parse stack to node.
				node[n_nodes].line = PS[psi].line;	         // Move line from parse stack to node.
			} 
			else
			{
				node[n_nodes].sti  = 0;    					   // Set symbol-table index to zero.
				node[n_nodes].line = 0;    					   // Set line number to zero.
			}
			psi = linkup(p);									      // Linkup the nodes in this rule. 
			if (psi >= 0)										      // Any nodes found in this rule?
			{
				node[n_nodes].child = PS[psi].node;		      // Define child. 
				node[PS[psi].node].parent = n_nodes;         // Define parent.
				node[n_nodes].line = 0;								// Reset line number. 
			}
			PS[0].node = n_nodes;									// Define node in the parse stack.
			PS[0].last = n_nodes++;									// Define node in the parse stack.
		}  
		else	                                             // Check for nodes not linked?
		{
			psi = linkup (p);                               // Get parse-stack index.  
			if (psi > 0)                                    // If we have a node here ...
			{
				PS[0].node = PS[psi].node;		               // Move node value to 1st position.
				PS[0].last = PS[psi].last;		               // Move last value also.
			}
		}  
@@
		return 1; // OK. 
}

@make_ast?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		linkup

int   @grm_name;_parser::linkup (int p)      
{
      int next = -1;
@numb_node?;...
      int i;
      if (reverse[p] == 0)                               // IF NOT TO REVERSE THE ORDER. 
      {
         for (i = PL[p]; i >= 0; i--)				         // For each tail pointer. 
         {
            if (PS[i].node > 0)                          // If tail points to node.	  
            {
               if (next >= 0)                            // If one waiting.        
               {
                  node[PS[i].last].next = PS[next].node; // Define next node.
                  node[PS[next].node].prev = PS[i].last; // Define previous node.
                  PS[i].last = PS[next].last;            // Change last to next last.
               }
               next = i;									      // Next = Curr.  
				}
			}  
		}
      else                                               // REVERSE THE ORDER.
      {
         for (i = 0; i <= PL[p]; i++)				         // For each tail pointer. 
         {
            if (PS[i].node > 0)                          // If tail points to node.
            {
               if (next >= 0)                            // If one waiting.        
               {
                  node[PS[i].last].next = PS[next].node; // Define next node.
                  node[PS[next].node].prev = PS[i].last; // Define previous node.
                  PS[i].last = PS[next].last;            // Change last to next last.
               }
               next = i;									      // Next = Curr.  
				}  
			}  
		}
   // if (next >= 0) print_ast(PS[next].node);				// For debugging.
@@
      return (next); 
}

@@
@@
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    prt_error	

void  @grm_name;_parser::prt_error (char *symb)
{       
      int  i, col, ln1, ln2;
      char string[256], *ls1, *ls2, *le1, *le2, *p, c;

	// Get first line number ...
      ln1 = linenumb;
		for (p = token.end-1; p > token.start; p--)
		{
			if (*p == '\n' || *p == 0) ln1--;
		}

	// Get first line start ...
		for (ls1 = token.start; *ls1 != '\n' && *ls1 != 0; ls1--); 
		ls1++;

	// Get first line end ...
		for (le1 = token.start; *le1 != '\n' && *le1 != 0; le1++);

	// Get last line number ...
      ln2 = linenumb;

	// Get last line start ...
		for (ls2 = token.end-1; *ls2 != '\n' && *ls2 != 0; ls2--); 
		ls2++;

	// Get last line end ...
		for (le2 = token.end; *le2 != '\n' && *le2 != 0; le2++);
		*le1 = 0;
		*le2 = 0;

		if (*token.start == '\n' || *token.start == 0) ln1--;

		printf  (            "\n%s(%d) : Error  %s\n", inputname, ln1, ls1);
		fprintf (outputdesc, "\n%s(%d) : Error  %s\n", inputname, ln1, ls1);
      *le1 = '\n'; // In case token is this <eol>

      col = 1;
      for (p = ls1; p < token.start; p++)   
      {
         if (*p == '\t') *p = ' ';
         col++;
      }
      for (i = 0; i < col; i++) string[i] = '-';
      string [col] = 0;
		printf  (            "%s(%d) : Error %s^ ", inputname, ln1, string);
		fprintf (outputdesc, "%s(%d) : Error %s^ ", inputname, ln1, string);

      if (*token.start <= 32) 
      {
         int x = *token.start;
         if (x < 0) x += 256;
         printf  (            "at \\%d %s\n\n", x, symb);
         fprintf (outputdesc, "at \\%d %s\n\n", x, symb);
      }
      else
      {
         if (token.end == token.start) token.end++;
         if (token.end > le1) 
         {
				if (*token.start == '\n') *token.start = 0;
            if (*token.end   == EOF_CHAR) linenumb--;
            c = *le1; 
            *le1 = 0;
            printf  (            "starts here\n");
            fprintf (outputdesc, "starts here\n");
				printf  (            "\n%s(%d) : Error  %s\n", inputname, ln2, ls2);
				fprintf (outputdesc, "\n%s(%d) : Error  %s\n", inputname, ln2, ls2);
				col = 1;
				for (p = ls2; p < token.end; p++)   
				{
					if (*p == '\t') *p = ' ';
					col++;
				}
				for (i = 0; i < col; i++) string[i] = '-';
				string [col] = 0;
				printf  (            "%s(%d) : Error %s^ ", inputname, ln2, string);
				fprintf (outputdesc, "%s(%d) : Error %s^ ", inputname, ln2, string);
				printf  (            "ends here.\n\n");
				fprintf (outputdesc, "ends here.\n\n");
            *le1 = c;
         }
         else
         {
            c = *token.end; 
            *token.end = 0;
				if (*token.start == '\n') *token.start = 0;
            printf  (            "at %s %s\n\n", token.start, symb);
            fprintf (outputdesc, "at %s %s\n\n", token.start, symb);
            *token.end = c;
         }
      }
}

@optn_exp.gt.1;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 

void	@grm_name;_parser::prt_stack () // Print parser stack.
{
		printf  (            "Parse stack:\n\n");
		fprintf (outputdesc, "Parse stack:\n\n");
		for (PStack* ps = P_stack+1; ps <= PS; ps++)
		{
			char* symbol;
			int sym = ps->sym;
			if (sym >= 0) symbol = term_symb [ sym];
			else          symbol = head_symb [-sym];
			printf  (            "\t%s\n", symbol);
			fprintf (outputdesc, "\t%s\n", symbol);
		}
		printf  (            "\n");
		fprintf (outputdesc, "\n");
}

@@
@optn_clr?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		expecting // Print expecting list. 

void  @grm_name;_parser::expecting (int x)
{
@optn_exp?;...
		int t;
		printf  (            "Expecting one of the following:\n\n");
		fprintf (outputdesc, "Expecting one of the following:\n\n");

   // Transitions to next state ...
     	for (t = 0; t < n_terms; t++)				// For all terminals.
		{
  			if (Bm [Br[x] + Bc[t]])					// Accept this terminal?
			{
       	   printf  (            "\t%-20s\n", term_symb[t]);
	         fprintf (outputdesc, "\t%-20s\n", term_symb[t]);
			}
		}

   // Reductions in this state ...
		for (t = 0; t < n_terms; t++)			   // For all lookaheads.
		{
			if (Rm [Rr[x] + Rc[t]])					// Got a reduction on this terminal?
			{	
       	   printf  (            "\t%-20s\n", term_symb[t]);
	         fprintf (outputdesc, "\t%-20s\n", term_symb[t]);
			}
		}

		printf  (            "\n");				 
		fprintf (outputdesc, "\n");				 
@@
}

@@
@optn_lr?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		expecting // Print expecting list. 

void  @grm_name;_parser::expecting (int state)
{
@optn_exp?;...
		int t;
		T_list = new char[n_terms];
		P_list = new int [n_prods];
		for (t = 0; t < n_terms; t++) T_list[t] = 0;
 		for (PS = PStop; RS > R_stack; RS--)   // Restore PS, RS and states.
      {
         RS->ptr->state = RS->state;         // Reset state to saved state.
      }
		printf  (            "Expecting one of the following:\n\n");
		fprintf (outputdesc, "Expecting one of the following:\n\n");
	  	collect (state);								// Collect all terminal symbols expected. 
		for (t = 0; t < n_terms; t++) 
      {
         if (T_list[t])
         {
       	   printf  (            "\t%-20s\n", term_symb[t]);
	         fprintf (outputdesc, "\t%-20s\n", term_symb[t]);
         }
      }
		printf  (            "\n");				 
		fprintf (outputdesc, "\n");				 
		delete [] P_list;
		delete [] T_list;
@@
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//		collect: Collect terminals that cause a transition or reduction.			                     

void	@grm_name;_parser::collect (int x) 
{
@optn_exp?;...
		int t, p, q, i, la, n_red;

   // Transitions to next state? ...
     	for (t = 0; t < n_terms; t++)						// For all terminals.
		{
  			if (Bm [Br[x] + Bc[t]] & Bmask[t])			// Accept this terminal?
			{
            T_list[t] = 1;                         // Mark this terminal.
			}
		}
		n_red  = 0;                                  // Reset to zero reductions. 
   // Reductions in this state? ...
		if ((p = Rr[x]) > 0)									// Default reduction?
		{
			P_list[n_red++] = p;	                     // Add this production to list.
		}
		else														// Reductions based on lookaheads!    		
		{
			for (la = 0; la < n_terms; la++)			   // For all lookaheads.
			{
				if ((q = Rm [Rc[la] - p]) > 0)			// Got a reduction on this terminal?
				{	
			  		for (i = 0; i < n_red; i++)			// For all reductions in the list.
					{
						if (P_list[i] == q) goto Next;   // Already in this list?
					}
					P_list[n_red++] = q;	               // Add this production to list.
				}
Next:       continue;
			}
@optn_nd?;...
		   for (i = nd_start[x]; i < nd_start[x+1]; i++) // For all nondeterministic terminals.
		   {
            p = -nd_action[i];                     // Get action.
            if (p > 0)                             // Is it a production?
            {
			  		for (int j = 0; j < n_red; j++)		// For all reductions in the list.
					{
						if (P_list[j] == p) goto Next2;  // Already in this list?
					}
					P_list[n_red++] = p;	               // Add this production to list.
            }
Next2:      continue;
		   }
@@
		}
   // MAKE REDUCTIONS ...
	  	for (i = 0; i < n_red; i++)
		{
         p = P_list[i];
         if (PL[p] < 0)                            // Null production?
         {
			   PS++;											   // Increment stack pointer.
            PS->state = x;								   // Stack state.
			   goto Cont;
         }
		   do			  
		   {
			   PS -= PL[p];								   // Reduce parse stack pointer. 
Cont:		   p = -Nm [Nr[PS->state] + Nc[p]];		   // Get production or next state.
		   }
		   while (p > 0);
		   collect (-p);									   // Go collect terminals.	
		}	  
@@
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    prt_prod                                                                                     

void	@grm_name;_parser::prt_prod (int p)
{
@optn_debug?;...
		printf  (            "         reduce    %6d %s <- ", p, head_symb [head_numb[p]]);
		fprintf (outputdesc, "         reduce    %6d %s <- ", p, head_symb [head_numb[p]]);
		int i;
		int first = f_tail[p];
		int next_first = f_tail[p+1];
		for (i = first; i < next_first; i++)
		{
			char* symb;
			int   s = tail[i];
			if (s >= 0) symb = term_symb[ s];
			else        symb = head_symb[-s];
			printf  (            "%s ", symb);
			fprintf (outputdesc, "%s ", symb);
		}
		printf  (            "\n");
		fprintf (outputdesc, "\n");
@@
}

@@
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    init_symtab

int   @grm_name;_parser::init_symtab (int max_symb) 
{
      int i; 
		if (max_symb <= 0) 
		{	
			printf  (            "Maximum number of symbols cannot be zero or negative.\n");
			fprintf (outputdesc, "Maximum number of symbols cannot be zero or negative.\n");
			return (0);
		}
		max_symbols   = max_symb;
		max_cells     = 2*max_symbols;
		symbol        = new Symbol[max_symbols];
      hashvec       = new int[max_cells];
      hashdiv       = UINT_MAX / max_cells + 1;
      n_symbols	  = 0;
      n_keywords	  = 0;
      if (symbol == NULL || hashvec == NULL)
      {
			printf  (            "Not enough memory available for Symbol Table.\n");
			fprintf (outputdesc, "Not enough memory available for Symbol Table.\n");
         return (0); // Return error.
      }
      for (i = 0; i < max_cells; i++) 
		{
			hashvec[i] = -1;
		}
		return (1); // Return OK.
}
													        
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    term_symtab

void  @grm_name;_parser::term_symtab () 
{
      delete [] symbol;
      delete [] hashvec;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    add_symb - add symbol to table.     											                        

int	@grm_name;_parser::add_symbol (int t, char* token_start, char* token_end) 
{
		sti = get_symbol (token_start, token_end);
		if (sti < 0) 
		{
			sti = n_symbols;
			if (n_symbols >= max_symbols)				// Reached maximum number? 
			{
				printf  (            "Number of symbols exceeds %d.\n", max_symbols);
				fprintf (outputdesc, "Number of symbols exceeds %d.\n", max_symbols);
				return (0); // Return error.
			}
			hashvec[cell] = n_symbols;					// Put symbol number into hash vector.     
			symbol[n_symbols].name = token_start;	// Define pointer to symbol name.
			symbol[n_symbols].length = length;		//	Define symbol name length.
			symbol[n_symbols].term = t;				// Define terminal number (<identifier>, <string>, <number>, ...)
			symbol[n_symbols].type = 0;				// Define type as undefined (zero).
			symbol[n_symbols].cell = cell;			// Define hash vector cell number for this symbol.
			n_symbols++;									// Increment number of symbols.
		}
      return (sti);										// Return symbol-table index.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    get_symbol - get symbol number from table.									                        

int   @grm_name;_parser::get_symbol (char* token_start, char* token_end) 
{
      char* p = token_start;					 		// Point at start.
      length  = token_end - token_start;  		// Set length. 
      uint hash = length;         	   			// Set hash to length. 
      int i = 0;						   				// Set shift value to 0.
      do									      			// Assume length != 0
      {
         hash += *p << i;
         i += 4;		                  			
         i %= 32;
      }
      while (++p < token_end);
      cell = hash % max_cells; 						// Get first cell.
		i = hashvec [cell];				   			// Get symbol index.
      if (i >= 0) 
		{
			p = token_start;						   	// Point at token start.
			do
			{
				if (symbol[i].length == length)		// If lengths are equal ...
				{
					char* q = symbol[i].name;			// Point at symbol name.
					int j = 0; 
					do 
					{
						if (p[j] != q[j]) goto Cont;	// If characters not equal ...		
					}
					while (++j < length);				// while end not reached. 
					return (i);								// Found it.
				}
	Cont:    cell = (hash *= 65549)/hashdiv;		// Get new cell number.
				i = hashvec [cell];						// Get symbol index.
			}
			while (i >= 0);      						// While not empty slot.
		}
      return (i);											// Return symbol number.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    print - print symbol table contents.     										                        

void  @grm_name;_parser::print_symtab (char* term_symb[])
{
@optn_debug?;...
		if (n_symbols > 1)
		{
			fprintf (outputdesc, "Symbol Table ...\n\n");
			fprintf (outputdesc, "  sti  leng  type  term  \n");

			for (int i = 1; i < n_symbols; i++)
			{
				fprintf (outputdesc, "%5d %5d %5d %5d   %-30s  %s\n",
					i,
					symbol[i].length,
					symbol[i].type,
					symbol[i].term, 
					term_symb[symbol[i].term],
					symbol_name(i)); 
			}   
			fprintf (outputdesc, "\n");
		}
		else
		{
			fprintf (outputdesc, "Symbol Table is empty!\n\n");
		}
@@
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    symname - get symbol name. 

char* @grm_name;_parser::symbol_name (int i)
{
      char* p;
      int L;
      static char name[100];
		if (i == 0) 
		{
			name[0] = 0;
		}
		else
		{
			p = symbol[i].name;
			L = symbol[i].length;
			if (L >= 100) 
			{
				L = 95;
				for (i = 0; i < L; i++) name[i] = p[i];
				name[i++] = ' ';
				name[i++] = '.';
				name[i++] = '.';
				name[i++] = '.';
				name[i] = 0;
			}
			else
			{
				for (i = 0; i < L; i++) name[i] = p[i];
				name[i] = 0;
			}
		}
      return name;
}

@make_ast?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//																										                     // 
//    ABSTRACT-SYNTAX-TREE FUNCTIONS														                     

      static uchar numeric[256] = /* numeric[x] gives 1..10 for digits 0..9 */
      {
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      1,  2,  3,  4,  5,  6,  7,  8,  9, 10,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 
      };

      Stack* AST::stack;
      int    AST::stacki;

		char draw_plus [] = "+ ";                     
		char draw_vbar [] = "| ";
		char draw_last [] = "+ ";
		char draw_space[] = "  ";

      int*  AST::counter;
      char  AST::indent[256];

      static int space_before = 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    init_ast                                                                                     

int   @grm_name;_parser::init_ast (int Max_nodes)
{
		max_nodes = Max_nodes;
		if (max_nodes <= 0) 
		{	
			printf  (            "Maximum number of AST nodes cannot be %d.\n", max_nodes);
			fprintf (outputdesc, "Maximum number of AST nodes cannot be %d.\n", max_nodes);
         return (0); // Return error.
		}
		node = new Node[max_nodes]; 
      if (node == NULL)
      {
			printf  (            "Not enough memory available for %d AST nodes.\n", max_nodes);
			fprintf (outputdesc, "Not enough memory available for %d AST nodes.\n", max_nodes);
         return (0); // Return error.
      }
		root           =  0;	// In case of internal error.
      node[0].id     = -1; // Undefined.
      node[0].prod   =  0;          
      node[0].sti    =  0;          
      node[0].line   =  0;								
      node[0].next   =  0;          
      node[0].prev   =  0;							   
      node[0].child  =  0;          
      node[0].parent =  0;							   
      n_nodes        =  1;  
		return (1); // Return OK.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    term_ast                                                                                     

void  @grm_name;_parser::term_ast ()
{
		delete [] node;
      delete [] stack;
      delete [] counter;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    print_ast ()                                                                                 

void  @grm_name;_parser::print_ast ()
{
@optn_debug?;...
		if (n_nodes > 1)
			print_ast (root);
		else
			fprintf (outputdesc, "AST is empty.\n\n");
@@
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    print_ast (n)                                                                                

void  @grm_name;_parser::print_ast (int n) // Print subtree.
{
		if (n < n_nodes && n > 0)
		{
	      char indent [512];
			strcpy (indent, draw_space);
			fprintf (outputdesc, "Abstract Syntax Tree ...\n\n");
			fprintf (outputdesc, "  node  prev  next parent child  line   sti \n");

			traverse (indent, n); // Start AST traversal.    
			fprintf (outputdesc, "\n");
		}
		else 
      {
         fprintf (outputdesc, "Internal error, node %d is not in AST.\n\n", n);
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse                                                                                     

void  @grm_name;_parser::traverse (char *indent, int n)
{
      while (node[n].next > 0)                
      {
         strcat (indent, draw_plus); 
         print_node (indent, n);                
         indent [strlen(indent)-2] = 0;
         if (node[n].child > 0)                
         {
            strcat (indent, draw_vbar);
            traverse (indent, node[n].child);  
            indent [strlen(indent)-2] = 0;
         }
         n = node[n].next;                    
      }

      strcat (indent, draw_last); 
      print_node (indent, n);                   
      indent [strlen(indent)-2] = 0;
      if (node[n].child > 0)                   
      {
         strcat (indent, draw_space); 
         traverse (indent, node[n].child);     
         indent [strlen(indent)-2] = 0;
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    print_node                                                                                   

void  @grm_name;_parser::print_node (char *indent, int n)  /* Print this node function. */
{
@optn_debug?;...
      int i;
      int sti;
      sti = node[n].sti;
		fprintf (outputdesc, " %5d %5d %5d %6d %5d %5d %5d %s%s",
			n, 
  			node[n].prev, 
  			node[n].next, 
  			node[n].parent, 
  			node[n].child, 
		  	node[n].line, 
			sti, 
			indent, 
			node_name[node[n].id]);

		if (sti != 0) // zero means no symbol.
		{
			char* q;
			int L;
			char string[100]; 
			if (sti > 0) // a symbol found in the input file?
			{
				q = symbol[sti].name;
				L = symbol[sti].length;
			}
			else // a terminal symbol of the grammar!
			{	
				q = term_symb[-sti];
				L = strlen(q);
			}
			if (L > 99) L = 99;
			for (i = 0; i < L; i++, q++) // Replace '\n' with \1
			{
				if (*q == '\n') string[i] =  1; // one = happy face.
				else            string[i] = *q;
			}
			string[i] = 0;
		//	fprintf (outputdesc, " (%s,%s,%d)", string, term_symb [symbol[sti].term], symbol[sti].type);
			fprintf (outputdesc, " (%s)", string);
		}
		fprintf (outputdesc, "\n");
@@
}

static char spaces[100];

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    traverse                                                                                     

void  @grm_name;_parser::traverse ()
{
@numb_nact?;...
	  	if (n_nodes > 1) // Any nodes in the tree? 
		{
		  	if (n_nodeactns > 0) // Any AST actions?
			{
				int i;
				stacki  = -1;
				stack   = new Stack [STKSIZE];	 
				counter = new int [n_nodenames];
				for (i = 0; i < n_nodenames; i++) 
				{
					counter[i] = 0;
				}
				fprintf (outputdesc, "Output ...\n\n");
  				traverse (root);	// Start AST traversal.
				printf  (            "\n");
				fprintf (outputdesc, "\n");
			}
		}
@@
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse (n)                                                                                 

void  @grm_name;_parser::traverse (int n)
{
@numb_nact?;...
		int   c, i, p, na;
		i = node[n].id;
		p = node[n].prod;
      counter[i]++;
      stacki++;
      stack[stacki].id = i;
      stack[stacki].counter = counter[i]; 
		na = nact_numb[p];
		if (na >= 0) 
		{
			status = TOP_DOWN;
			(*nact_func[na]) (n);	
		}
    	c = node[n].child;                
      while (c > 0)
		{
    	   traverse (c); 
			if (c = node[c].next)          
			{
				if (na >= 0) 
				{
					status = PASS_OVER;
					(*nact_func[na]) (n);	
				}
         }  
		}  
		if (na >= 0) 
		{
			status = BOTTOM_UP;
			(*nact_func[na]) (n);	
		}
      stacki--;
@@
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    emitstr
  
int   @grm_name;_parser::emitstr (int n, char* str) 
{
@numb_nact?;...
      int   sti;
      int   i, x;
      char  string[1000];
      char  *symb, *s, *p;

   // Get symbol from node.
      sti  = node[n].sti;
		if (sti < 0) 
			symb = term_symb[-sti];
      else         
			symb = symbol_name(sti); 

   // Scan string for &-codes ... 
      p = str; 
      s = string;
      while (1) 
      {
         *s = *p;
         if (*s == 0) 
         {
				fprintf (outputdesc, string, symb);
            return (0);
         }
         if (*s == '&') // &-code ?
         {
            if (numeric[*++p]) // number ?
            {
               x = *p - '0';
               while (numeric[*++p]) x = 10*x + *p - '0';
               i = stacki - x;
               if (i < 0) *s++ = '?'; // Error. 
               else
               {
                  switch (*p)
                  {
                     case 'c': 
							s += sprintf (s, "%d", stack[i].counter); // Get counter.
                     p++;
                     break;

                  // case 'n': 
						//	s += sprintf (s, "%s", node_name[stack[i].id]); // Get node name.
                  // p++;
                  // break;

                     default:  
							s += sprintf (s, "%d", stack[i].counter); // Get counter.
                     break;
                  }
               }
            }
            else s++;
         }
         else { s++; p++; }
      }
@@
		return (0);
}

@@
@optn_debug?;...
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 

void	@grm_name;_parser::prt_line () // Print current line being parsed.
{
      char* ls = token.start;
      char* le = token.end;
      while (*ls != '\n' && *ls != 0) ls--;
      if (*ls == 0) // Already printed this one?
		{
         return;
		}
      *ls = 0;
      ls++;
      while (*le != '\n') le++;
      *le = 0;
		if (*ls != 26) // EOF?
		{
			printf  (            "%6d  %s\n", linenumb, ls);
			fprintf (outputdesc, "%6d  %s\n", linenumb, ls);
		}
		else
		{
	      printf  (            "\n");
		   fprintf (outputdesc, "\n");
		}
      *le = '\n';
}

@@
//                                                                                                 // 
/////////////////////////////////////////////////////////////////////////////////////////////////////

