
#ifdef LRSTAR

#pragma once

@("char", "uchar", "short", "ushort", "int", "uint", "char*") 
@//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    @grm_name;Lexer.h

/*    Generated by: @program; @version;
      Grammar:      @grm_file;
      Skeleton:     @skl_file;
      Output:       @out_file;
*/               
		#define  ushort unsigned short
		#define  uchar  unsigned char

		class @grm_name;Lexer 
		{
			public:
         static Token  token;
			static int    tab;
			static int    line_numb;
			static int    col_numb;
			static int    line_pos;
			static char*  line_start;
			static int    line_start_numb;

@optn_small?;...
			static @bmat_numb.8t; Bm[];		// Bit matrix (0 or 1).
			static @bmat_row. 8t; Br[];		// Bit matrix row (base).
			static @bmat_col. 8t; Bc[];		// Bit matrix column (displacement).
@@
			static @tmat_numb.8t; Tm[];		// Terminal transition matrix (gives next state or reduction).
			static @tmat_row. 8t; Tr[];		// Terminal transition matrix row (base).
			static @tmat_col. 8t; Tc[];		// Terminal transition matrix column (displacement).
			static @term_numb.8t; terminal[];// Terminal-symbol number for this node.

			static int    get_token ();
			static int    get_lookahead (int&);
			static void   init_lexer (char*);
			static void   prt_line ();

@def_cons?;...
			static char* token_name[@def_cons.d;];
@@
@def_cons!;...
			static char* token_name[1];
@@
@def_cons?;...
			enum tokens
			{
				@def_cons.1|%s = %d,||\n            |;
			};
@@
		};

#endif
