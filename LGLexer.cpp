
#ifdef DFASTAR

		#include "ComGlobal.h"
		#include "LGLexer.h"

		Token  LGLexer::token;					
		int    LGLexer::line_numb;
		int    LGLexer::col_numb;			
		int    LGLexer::line_pos;
		char*  LGLexer::line_start;
		int	 LGLexer::max_char_set;
		int	 LGLexer::tab;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 // 
//    Terminal Transition Matrix and Vectors.                            

   // Terminal transition matrix. 
      static unsigned char Tm [829] = 
      {
         52,    7,    7,   45,    7,   52,    4,   25,    3,   33,   34,   36,   35,   21,   23,   26,    6,   40,    1,   22,
         52,   37,    5,   24,    2,   39,    5,   38,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    8,    0,    0,    0,    8,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   42,    0,    0,
          0,    0,    0,   27,    9,    9,    9,   27,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
          9,    9,    9,    9,    9,    9,    9,    0,    0,    0,    0,   10,   10,    0,   10,   10,   10,   10,   10,   10,
         10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    5,    0,    0,    0,    0,    0,    5,    0,    0,
          0,    5,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    6,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    7,    7,    0,    7,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   13,    0,    0,
          0,   41,    0,   13,    0,    0,    0,   13,    0,    0,    0,    0,    0,    9,    9,    9,   43,    9,    9,    9,
          9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    0,    0,    0,    0,
         10,   10,   44,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
         10,   10,   10,   10,   11,   11,    0,    0,   11,   11,   11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
         11,   11,   11,   11,   11,   11,   11,   11,   11,   11,   11,   11,   15,   15,   15,    0,   15,   15,   15,   15,
         15,   15,   15,   14,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
         16,   16,   16,    0,   16,   16,   16,   16,   16,   16,   16,   14,   16,   16,   16,   51,   16,   16,   16,   16,
         16,   16,   16,   16,   16,   16,   16,   16,   15,   15,   15,    0,   15,   15,   15,   15,   15,   15,   15,   17,
         15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   15,   18,   18,   18,    0,
         18,   18,   18,   18,   18,   18,   18,   29,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
         18,   18,   18,   18,   19,   19,   19,    0,   19,   19,   19,   19,   19,   19,   19,   17,   19,   19,   19,   51,
         19,   19,   19,   19,   19,   19,   19,   19,   19,   19,   19,   19,   18,   18,   18,    0,   18,   18,   18,   18,
         18,   18,   18,   30,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
         20,   20,   20,    0,   20,   20,   20,   20,   20,   20,   20,   31,   20,   20,   20,   20,   20,   20,   20,   20,
         20,   20,   20,   20,   20,   20,   20,   20,    0,   20,   20,   20,   20,   20,   20,   20,   32,   20,   20,   20,
         20,   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   46,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   47,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,   28,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   48,    0,    0,    0,    0,
          0,    0,    0,   50,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,   12,    0,    0,    0,   11,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,   43,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,   49,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   16,   16,   16,    0,   16,
         16,   16,   16,   16,   16,   16,   29,   16,   16,   16,   51,   16,   16,   16,   16,   16,   16,   16,   16,   16,
         16,   16,   16,    0,   16,   16,   16,   16,   16,   16,   16,   30,   16,   16,   16,   51,   16,   16,   16,   16,
         16,   16,   16,   16,   16,   16,   16,   16,   19,   19,   19,    0,   19,   19,   19,   19,   19,   19,   19,   31,
         19,   19,   19,   51,   19,   19,   19,   19,   19,   19,   19,   19,   19,   19,   19,   19,    0,   19,   19,   19,
         19,   19,   19,   19,   32,   19,   19,   19,   51,   19,   19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
         19,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0
      };

   // T_matrix row. 
      static unsigned short Tr [53] = 
      {
          0,   28,   55,   79,  107,  135,  162,  189,  201,  228,  256,  284,  312,  201,  340,  368,  396,  424,  452,  480,
        505,  533,  554,  575,  590,  616,  633,  653,  667,  695,  720,  748,  773,  801,  801,  801,  801,  801,  801,  801,
        801,  801,  801,  801,  801,  801,  801,  801,  801,  801,  801,  801,  801
      };

   // T_matrix column. 
      static unsigned char Tc [256] = 
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    1,    2,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    3,    0,    0,    0,    0,    0,    4,    5,    6,    5,    5,    7,    5,    8,
          9,   10,   11,   12,    5,   13,   14,   15,   16,   16,   16,   16,   16,   16,   16,   16,   16,   16,    5,   17,
         18,   19,   20,   21,    5,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,
         22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   23,   24,   25,    5,   26,    5,   22,   22,   22,
         22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,   22,
         22,   22,   22,    5,   27,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
          5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
          5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
          5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
          5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
          5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
          5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    0
      };

   // token numbers for each state. 
      static char terminal [53] = 
      {
          0,    0,    0,    0,    0,    1,    6,   -1,    0,    0,    0,   -1,    0,    0,    0,    0,    0,    0,    0,    0,
          0,   17,    0,    0,   20,    0,    0,    0,   15,    0,    0,    0,    0,   10,   11,   12,   13,   14,   16,   21,
         22,    2,    3,    4,    5,    7,    8,    9,   18,   19,   29,   -1,    0
      };

/*--- Defined Constants. ----------------------------------------------------*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           // 
//    init                                                                   //

void  LGLexer::init () // General purpose lexer.
{
		int i;
		line_numb  = 1;
		col_numb   = 0;
		line_pos   = 0;
		line_start = (input_start + 1);
		token.end  = line_start;
  		line_ptr[line_numb] = input_start + 1;
		tab = optn[LG_TAB];
		if (max_char_set == 128)
		{
			for (i = 128; i < 256; i++)
			{
				Tc[i] = Tc[0]; // Make higher characters an error.
			}
		}
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           // 
//    term                                                                   //

void  LGLexer::term () // General purpose lexer.
{
		/* Nothing */
}

/*--- DFA Lexer Engine. -----------------------------------------------------*/

int   LGLexer::get_token ()		// DFA LGLexer Engine.
{
      int state, next;		// State, next state, terminal, keyword.
		do 
		{
			state = 0;									// Start in state zero.
			token.start = token.end;				// Set start of token.
			token.line  = line_numb;				// Set line number of token.
			token.column = col_numb + 1;			// Set column number.
       	while (next = Tm [Tr [state] + Tc [*token.end]])
			{
			   if (*token.end == '\n')				// If end-of-line character.
				{
					col_numb = 0;
					line_pos = 0;
					line_start = token.end + 1;	// Set beginning of next line.
				  	line_ptr [++line_numb] = line_start;
				}	  
			   else if (*token.end == '\t')				// If tab character.
				{
					col_numb += tab - (col_numb % tab);	
				}	  
				else 
				{
					col_numb++;							// Increment column.
				}
				token.end++;							// Increment token pointer.
				state = next;							// Set next state number.
			}
		}
      while (terminal[state] == -1);			// If whitespace, continue.

		line_pos++;
      return terminal[state];					// Return terminal number.
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //

int	LGLexer::get_lookahead()
{
      char* TS   = token.start;
      char* TE   = token.end;
      int   TSTI = token.sti;
		int   TL   = token.line;
      int   TC   = token.column;
      int   LN   = line_numb;
      int   LC   = col_numb;
      int   LP   = line_pos;

      int   la = get_token();    // Get look ahead token.

      token.start  = TS;         // Reset token start.
      token.end    = TE;         // Reset token end.
		token.sti    = TSTI;
      token.line   = TL;         // Reset token column.
      token.column = TC;         // Reset token column.
      line_numb    = LN;         // Reset line number.
      col_numb     = LC;         // Reset line column.
      line_pos     = LP;         // Reset line position.
		return (la);
}

#endif

//                                                                           //
///////////////////////////////////////////////////////////////////////////////
