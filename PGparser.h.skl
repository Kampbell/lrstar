
#ifdef LRSTAR

#pragma once

@("char", "uchar", "short", "ushort", "int", "uint", "char*") 
@//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    @grm_name;Parser.h

/*    Generated by: @program; @version;
      Grammar:      @grm_file;
      Skeleton:     @skl_file;
      Output:       @out_file;
*/               
		#include "@grm_name;Lexer.h"

@numb_tact?;...
		#define TOKEN_ACTIONS
@@
@numb_pact?;...
		#define PARSE_ACTIONS
@@
@numb_nact?;...
		#define NODE_ACTIONS
@@
@def_cons?;...

   // Defined constants ...
      @def_cons.1|#undef  %15s||\n      |;

      @def_cons.1|#define %15s %5d // %T||\n      |;

@@
@numb_node?;...
   // Defined constants for the node names ...
      @node_name.1|#define %15u %5d||\n      |;

@@
	// AST Action Mode. 
      #define TOP_DOWN        0  // Top down status.  
   	#define PASS_OVER       1  // Pass over status.
   	#define BOTTOM_UP       2  // Bottom up status.  

	// AST Traversal Passes. 
      #define FIRST_PASS       1  // EBNF normalization.
      #define SECOND_PASS      2  // EBNF expansion.
      #define THIRD_PASS       3  // Count variables.
      #define FOURTH_PASS      4  // Print the grammar.
   
      class @grm_name;Parser : public @grm_name;Lexer, public AST
		{
		   public:
		// Functions ...
			static void    initialize   (int);				
			static int     parse        (char* input_start);	
			static void    terminate   ();	
			static void    syntax_error (char*);

		// Variables ...
			static int     n_constants;
		   static int     N_args;
		   static int*    F_narg;
			static int*    Arg_numb;
			static int    	N_strings;
			static int    	N_tails;
			static int    	N_terms;
			static int*   	Node_numb;
			static int*   	Nact_numb;
			static char** 	Node_start;
			static char** 	Nact_start;
			static int    	N_heads;
			static int    	N_generated;
			static int    	N_nodes;
			static int    	N_tacts;  // token actions.
			static int    	N_pacts;  // parsing actions (total).
			static int    	N_nacts;
			static int    	N_ints;
			static int    	N_prods;

	      static char**  Str_start;
			static int*    f_eri;
			static int*    F_targ;
			static int*    F_parg;
			static int*    F_prod;
	      static int*    eri_prod;
		   static int*    eri_dot;
		   static int     n_eris;
	      static char**  Tact_start;
		   static int*    Tact_numb;
	      static int*    Reverse;
			static int     opt_states;
			static int*    Oper_prec;
			static char*   Prec;
			static char**  Pact_start;
			static int*    Pact_numb;
	      static int*    Defcon_value;
		   static char**  Defcon_name;
			static int     eol_term;
			static int     eof_term;
			static int     error_sym_used;
			static int     make_ast;
	      static int     keyword_sym;
	
         static PStack* PS;           	      // Parse Stack pointer.       
         static PStack* PS_end;        	      // Parse Stack end.       
			static int     prev_token;
			static int		goal_symbol;
			static int		start_symbol;
			static int		error_mode;
			static int		codeblock;

			static @tact_arg. 8t; tact_arg[];		      // Token action argument index (for first arg).
			static @pact_arg. 8t; pact_arg[];		      // Production action argument index (for first arg).
			static @nact_arg. 8t; nact_arg[];		      // Node action argument index (for first arg).
			static @arg_numb. 8t; arg_numb[];		      // Parse argument numbers.
			static @arg_text. 8t; arg_text[];		      // Argument text (if a string argument or node arg).
			static @term_symb.8t; term_symb[];           // Terminal symbols of the grammar.
			static @tact_numb.8t; tact_numb[];           // Token action number. 

		   private:
		// Functions ...
			static int     nd_parse      (int*, int*, int*, int x, int t, int a);
			static int     reduce_action (int p);
			static int     linkup			(int p);
			static void    rebuild		   ();                           
			static short   err_rec		   (short, short);
//			static short   lookahead		(short t, short x);
			static void    get_list		(short);
			static void    prt_token		(short); 
			static void    prt_prod		(short); 
			static void    prt_stack		(); 
			static void    expecting		(); 
			static void	   collect		   (int x);
			static void	   reduce			(int p, int x);
			static void    prt_list      (int t);
@tact_func?;...
  		  	static int    (*tact_func[])  (int);	// Parser action function pointers.
@@
@pact_func?;...
  		  	static int    (*pact_func[])  (int);	// Parser action function pointers.
@@

		// Variables ...
@tact_func?;...
  		  	static char*   tact_name[];		      // Parser action name.
@@
@pact_func?;...
  		  	static char*   pact_name[];				// Parser action name.
@@
    
			static int     max_errs;				   // Maximum allowable errors.
			static int     n_terms;				   // Number of terminal symbols in grammar.
			static int     n_heads;				   // Number of head symbols in grammar.
			static int     n_prods;				   // Number of productions (rules) in grammar.
			static int     n_states;				   // Number of states in Parser state machine.
			static int     eof_symb;				   // <eof> symbol number.
			static int     eol_symb;				   // <eol> symbol number.
			static int     err_used;				   // <error> used in grammar?
                                       		                                      
         static RStack* RS;           		   // Reduction Stack pointer.
			static char*   T_list;					   // Terminal symbol list (0 or 1).
			static int*    P_list;					   // Production list.
         static RStack  R_stack[];				   // Reduction stack.
         static PStack  P_stack[];				   // Parser stack.
			static PStack* PStop;				      // Top pointer for Parser stack.
			static int     topstate;				   // Top state (before reductions start).

			static @head_symb.8t; head_symb[];           // Head (nonterminal) symbols of the grammar.
			static @prod_head.8t; head_numb[];           // Head symbol number for a production (rule).
			static @prod_leng.8t; PL[];			         // Production (rule) length less one (zero based).
			static @pact_numb.8t; pact_numb[];           // Production action number (for a Parser action).
			static @node_numb.8t; node_numb[];           // Node number index for a production (rule).

			static @bmat_numb.8t; Bm[];			         // Bit matrix (0 or 1).
			static @bmat_row. 8t; Br[];			         // Bit matrix row (base).
			static @bmat_col. 8t; Bc[];			         // Bit matrix column (displacement).
			static @bmat_mask.8t; Bmask[];		         // Bit matrix mask.
			static @tmat_numb.8t; Tm[];			         // Terminal transition matrix (gives next state or reduction).
			static @tmat_row. 8t; Tr[];			         // Terminal transition matrix row (base).
			static @tmat_col. 8t; Tc[];			         // Terminal transition matrix column (displacement).
			static @nmat_numb.8t; Nm[];			         // Nonterminal transition matrix (gives next state or reduction).
			static @nmat_row. 8t; Nr[];			         // Nonterminal transition matrix row (base).
			static @nmat_col. 8t; Nc[];			         // Nonterminal transition matrix column (displacement).
			static @rmat_numb.8t; Rm[];			         // Reduction matrix (gives reduction).
			static @rmat_row. 8t; Rr[];			         // Reduction matrix row (base).
			static @rmat_col. 8t; Rc[];			         // Reduction matrix column (displacement).
			static @nd_start. 8t; nd_start[];
			static @nd_term.  8t; nd_term[]; 
			static @nd_action.8t; nd_action[]; 
			static @prod_revs.8t; reverse[];		         // Reverse order of nodes for this production (rule)?
			static @prod_tail.8t; f_tail[];		         // First Tail symbol for a production.
			static @tail_numb.8t; tail[];			         // Tail symbols for productions.
		};

#endif
