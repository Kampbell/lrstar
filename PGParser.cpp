
#ifdef LRSTAR

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    PGParser.

/*    Generated by: LRSTAR 6.5.019
      Grammar:      PG.grm
      Skeleton:     PGParser.cpp.skl
      Output:       PGParser.cpp
*/
      #include "ComGlobal.h"
		#include "PGGlobal.h"
  		#include "PGParser.h"
  		#include "PGActions.h"

		#define STKSIZE        1000 // Parser stack size.
		#define ACCEPT_STATE	   115 // Final state.
      #define LOOKAHEADS        2

/*--- Constants. -------------------------------------------------------------*/

      int		PGParser::n_terms      =    42; // No. of terminals.
      int		PGParser::n_heads      =    96; // No. of non-terminals.
      int		PGParser::n_prods      =   198; // No. of productions.
      int		PGParser::n_states     =   116; // No. of states.
      int		PGParser::eol_symb     =     0; // EOL symbol number
      int		PGParser::eof_symb     =     7; // EOF symbol number
      int		PGParser::err_used     =     0; // <error> used in grammar
		int		PGParser::N_args;
		int*		PGParser::F_narg;
		int*		PGParser::Arg_numb;
		int    	PGParser::N_strings;
		int    	PGParser::N_tails;
		int    	PGParser::N_terms;
		int*   	PGParser::Node_numb;
		int*   	PGParser::Nact_numb;
		char** 	PGParser::Node_start;
		char** 	PGParser::Nact_start;
		int    	PGParser::N_heads;
		int    	PGParser::N_generated;
		int    	PGParser::N_nodes;
		int    	PGParser::N_tacts;  // token actions.
		int    	PGParser::N_pacts;  // parsing actions (total).
		int    	PGParser::N_nacts;
		int    	PGParser::N_ints;
		int    	PGParser::N_prods;
	   char**	PGParser::Str_start;
		int*		PGParser::f_eri;
		int*		PGParser::F_targ;
		int*		PGParser::F_parg;
		int*		PGParser::F_prod;
	   int*		PGParser::eri_prod;
		int*		PGParser::eri_dot;
		int		PGParser::n_eris;
	   char**	PGParser::Tact_start;
		int*		PGParser::Tact_numb;
	   int*		PGParser::Reverse;
		int		PGParser::opt_states;
		int*     PGParser::Oper_prec;
		char*    PGParser::Prec;
		char**   PGParser::Pact_start;
		int*     PGParser::Pact_numb;
	   int*     PGParser::Defcon_value;
		char**   PGParser::Defcon_name;
		int      PGParser::eol_term;
		int      PGParser::eof_term;
		int      PGParser::error_sym_used;
		int      PGParser::make_ast;
	   int      PGParser::keyword_sym;
		int      PGParser::n_constants;

/*--- Terminal and Nonterminal Symbols of the Grammar. -----------------------*/

   // Terminal symbols of the grammar.
      char* PGParser::term_symb[42] =
      {
         "<error>",
         "<alpha>",
         "<lexical>",
         "<semantic>",
         "<literal>",
         "<string>",
         "<integer>",
         "<eof>",
         "\'<keyword>\'",
         "\'<error>\'",
         "\'<eof>\'",
         "{goal_symbol}",
         "{head_symbol}",
         "\':\'",
         "\'->\'",
         "\'~>\'",
         "\'/->\'",
         "\'/~>\'",
         "\'|\'",
         "\';\'",
         "\'=>\'",
         "\'+>\'",
         "\'*>\'",
         "\'=+>\'",
         "\'=*>\'",
         "\'^\'",
         "\'{\'",
         "\'}\'",
         "\'<<\'",
         "\'>>\'",
         "\'+\'",
         "\'...\'",
         "\'~\'",
         "\'~..\'",
         "\'?\'",
         "\'*\'",
         "\'/\'",
         "\'(\'",
         "\')\'",
         "\'[\'",
         "\']\'",
         "\',\'"
      };

/*--- Bit Matrix and Access Vectors. -----------------------------------------*/

   // B_matrix.
      uchar PGParser::Bm [126] =
      {
          0,    0,    0,    0,   16,    0,    0,    0,   64,    0,    0,    0,   14,    3,    0,    0,   46,    3,    0,    0,
          0,    3,    0,    0,    8,    0,    4,    0,    0,   14,    0,    0,    0,    0,    1,    0,    2,    0,    0,    0,
         48,    0,    0,   14,    0,   32,    0,    0,    0,   32,    0,    8,    0,    0,  142,    1,    0,   32,   62,    3,
          0,   64,    0,  112,    0,    0,    6,    0,    0,  128,   23,    0,    0,    0,    8,    0,    0,    0,   23,    0,
          0,  128,   25,    0,  128,    0,    0,    0,   64,    1,    0,  128,    1,    0,  224,    1,    0,   96,    1,    0,
          6,    0,    0,   32,    0,    0,    0,  128,   34,    0,    0,    0,   62,    3,    0,    0,   96,    0,    0,  128,
          5,   32,    0,    0,   64,    0
      };

   // B_matrix row.
      uchar PGParser::Br [116] =
      {
          4,    8,    0,   12,    2,   16,   19,   12,   12,   22,   22,   25,    2,   29,   32,   19,   22,   32,   36,   12,
         12,    0,   39,   43,   32,   46,   50,   54,   54,    6,   58,   62,   64,   35,   67,   71,   75,   79,   54,   54,
         64,   83,   85,    0,    0,   90,   93,   96,   54,   54,   54,   54,   54,   32,   36,   36,   36,   36,   36,  100,
          5,    0,   54,  104,   32,   83,  108,  112,   32,   54,   83,   32,   32,   54,  115,   32,   64,   54,   64,   64,
         64,   64,   46,   46,   36,    0,   46,    0,  117,   54,    0,   83,   64,   64,  121,   46,   46,   36,    5,   54,
          0,    0,  112,   54,   85,    0,   30,    0,  112,  112,    0,   30,    5,  112,    5,    0
      };

   // B_matrix column.
      uchar PGParser::Bc [42] =
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
          2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    3,    3,    3,    3,    3,    3,    3,    3,    0,
          3,    4
      };

   // B_matrix mask.
      uchar PGParser::Bmask [42] =
      {
          1,    2,    4,    8,    4,   16,   32,   64,  128,    1,    2,    4,    8,   16,   32,   64,   64,   64,  128,    1,
          2,    4,    4,    4,    4,    8,   16,   32,   64,   64,  128,    1,    2,    4,    8,    8,   16,   32,   64,  128,
        128,    1
      };

/*--- Terminal Transition Matrix and Access Vectors. ------------------------*/

   // T_matrix.
      short PGParser::Tm [184] =
      {
       -133, -136, -127, -130, -165, -106, -107,    0, -108,    0,    0,    0,    0,    0, -125,    0,    0,    0,    0,    0,
          0,    0,    0,    0,  -15,    0,    0,    0, -146, -147,   89, -164,  -87,  -88,    0,  -89, -100, -102, -103, -101,
        -94,    0,    0,    0,    0,    0,  -13,    0, -105,    0,    0, -104,    0,    0,    0,    0,    0,    0,    0,    0,
          0,   38, -144,   39,    0,  108,   43, -156, -157, -158, -160,    0,  -58,  -59,  -60,  -55, -177,    0, -159,    0,
        -61, -161,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, -140,   44,  -28,  -29,  -30,  -31,  -39,    0,
        -58,  -59,  -60,   99,  -12,   18,    0,    0,  -61,   29,    0,    0,  -66,  -67,    0,    0,  -93,  -91,   59,  102,
       -143, -162,    0,  113,   16,  -18,  -19,   10,  -23,   48,   49,   50,   51,  -55,   -8,   54,   55,  -21,   52,  -22,
         56,   57,   58,  -83,  -82,  -84,    0,    0,   59,   94,   90,  -10,    0,  109,    9,  -18,  -19,   10,  -23,   27,
         28,  -34,  -47,   66,  -14,   18,   -3,  -17,   13,  -22,  -26,  -27,  -73,  -74,  -75,  -76,  -79,  -80,   59,   30,
       -141,  115,  -96,   67
      };

   // T_matrix row.
      uchar PGParser::Tr [116] =
      {
        154,  154,  154,  154,  154,  124,  154,  154,  154,  154,  124,  154,  154,   94,  124,   94,  154,   14,   14,  154,
        124,  154,  154,   94,   36,  154,  154,   36,   36,  154,   66,  124,  124,   94,  154,  154,  124,   94,   36,   36,
        124,  154,  154,  154,  154,   66,   66,   66,   36,   36,   36,   36,   36,   66,    2,    3,    3,    0,    0,    5,
        124,  154,   36,  154,   66,  154,    4,   66,   66,   36,  124,   66,   66,   36,   94,   66,  124,   36,  124,  124,
        124,  124,  154,  124,    1,  154,  124,  154,   14,   36,  154,   94,  124,  124,   94,   94,   94,    1,   14,   36,
        154,  154,   66,   36,   36,  154,  124,  154,   66,   66,  154,   94,    2,   66,    3,  154
      };

   // T_matrix column.
      uchar PGParser::Tc [42] =
      {
          0,    0,    1,    2,    3,   12,   27,   27,   12,   15,    4,    7,    8,    5,    6,    7,    8,   14,    9,   10,
         11,   12,   16,   17,   18,   13,   14,   15,   16,   17,   18,   19,   20,   21,   22,   23,   24,   25,   26,   27,
         28,   29
      };

/*--- Nonterminal Transition Matrix and Access Vectors. ---------------------*/

   // N_matrix.
      short PGParser::Nm [616] =
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0, -109,    0,    0,    0,    0, -187,    0,   88,  -68,  -90,  -69,  -92,   34,
         35,   36, -183,  -64,    0,   37,  -68,  -90,  -69,  -92,   34,   35,   36,    0,    0,    0,   37,    0,  114, -149,
          0, -148, -152, -153, -154,   41, -186,    0,    0,  -68,  -90,  -69,  -92,   34,   35,   36,   92, -182,  -64,   37,
          0,  -68,  -90,  -69,  -92,   34,   35,   36,   93, -182,  -64,   37,    0,  -68,  -90,  -69,  -92,   34,   35,   36,
          0, -186,    0,   37,  -68,  -90,  -69,  -92,   34,   35,   36,   98,   61,    0,   37,    0,    0,    0,   76, -182,
        -64,    0,  103,  -68,  -90,  -69,  -92,   34,   35,   36,    0,    0,   77,   37,    0,    0,  -50, -112, -113, -114,
       -115, -116,    0,    0,   77,   78, -182,  -64,    0,    0,  -68,  -90,  -69,  -92,   34,   35,   36,   62,    0, -145,
         37,    0,    0,  -51, -112, -113, -114, -115, -116,    0,    0,  -36,    0,    0,   77,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,  110,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  -41,    0,
          0,   77,   81, -182,  -64,    0,    0,  -68,  -90,  -69,  -92,   34,   35,   36,    0,    0,    0,   37,    0,    0,
        -57, -112, -113, -114, -115, -116,   79, -182,  -64,    0,    0,  -68,  -90,  -69,  -92,   34,   35,   36,    0,    0,
          0,   37,    0,  112,  -52, -112, -113, -114, -115, -116,    0,    0,    0,    0,    0,  -46,    0,    0,   77,    0,
          0,    0,    0,    0,    0,    0,    0, -191,    0, -190, -152, -153, -154,   41,    0,    0,    0,    0,    0,  -43,
          0,    0,   77,   80, -182,  -64, -192,    0,  -68,  -90,  -69,  -92,   34,   35,   36,    0,    0,    0,   37,    0,
          0,  -54, -112, -113, -114, -115, -116,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,  111, -149,    0, -148, -152, -153, -154,   41,    0,    0,    0,    0,    0,  -44, -186,    0,   77,
        -68,  -90,  -69,  -92,   34,   35,   36,   63,   61,    0,   37,    0,    0,  -49, -112, -113, -114, -115, -116,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  106,  107,   20, -148, -152,
       -153, -154,   41,    0,    0,    0,    0,    0,  -35,    0,    0, -169,    0,   62,    0,    6, -179,   69,   75, -180,
         73,    0,    0, -186,  -70,  -71,  -68,  -90,  -69,  -92,   34,   35,   36,   60,   61,    0,   37, -167,    0,  -48,
       -112, -113, -114, -115, -116,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,  105,    5, -189, -152, -153, -154,   41,    0,   19, -173,    0,    0,  -45,   40,   74, -168,    0,   62,
          0,    6,    0,   71, -178,   69,   72, -180,   73,    0,   33,  -64,  -85,  -86,  -68,  -90,  -69,  -92,   34,   35,
         36,   14,    0,    0,   37,    0,   24,   64, -112, -113, -114, -115, -116,    0,    0,    0,    0,   97,   84,   83,
         87,   86, -123,   95, -122,   96, -126, -132, -137,    0,  101,  100,    0,    0, -151,    0, -195,    0,    0,    0,
          0,    0,  -42,   70,   74,    0,    0, -171,    0,   15,    0,    0, -197, -172,   21,   22,  -33,   32,  -37,  -38,
       -175,   31,   45,   46,   47,   68, -178,   69,    2, -181,   73,    4,   33,  -64,  -77,  -78,  -68,  -90,  -69,  -92,
         34,   35,   36,    1,    3, -185,   37, -166,   17,   53, -112, -113, -114, -115, -116, -110,   25, -117,   82, -121,
       -118,   83,   85,   86, -120,   95, -119,   96, -124, -129, -135,   11,  101,    5, -188, -152, -153, -154,   41,    7,
          8,   12,   23,   26,  -40,   70,   -1, -168,   91, -170,   42,    6, -194,  104, -196,   65
      };

   // N_matrix row.
      ushort PGParser::Nr [116] =
      {
        533,  533,  533,  533,  533,  451,  533,  383,  317,  533,  533,  533,  451,  533,  533,  451,  533,  533,  533,  317,
        451,  533,  533,  451,  533,  533,  533,  533,  451,  533,  533,  533,  533,  533,  533,  533,  451,  383,  383,  317,
        451,  533,  533,  533,  533,  533,  451,  383,  100,  127,  208,  265,  184,  317,  533,  533,  451,  533,  451,    0,
        533,  533,   12,  533,  100,  451,  451,  383,  127,   58,  383,  208,  265,   70,  533,  184,  383,   23,  317,  100,
        127,  208,  451,  533,  533,  533,  451,  451,  533,   81,  533,  533,  265,  184,  451,  533,  451,  451,  533,   46,
        533,  383,  317,   12,  533,  100,  533,  127,  208,  265,  184,  533,  533,    0,  533,  533
      };

   // N_matrix column.
      uchar PGParser::Nc [198] =
      {
         30,   30,   15,   15,   18,   18,   18,   18,   34,   60,   30,   31,   74,   74,   74,   74,   78,   78,   78,   78,
         78,   78,   78,   78,   58,   58,   76,   76,    0,    0,    0,    0,   73,    1,    2,    3,    3,    4,    5,    6,
          7,    7,    7,    7,    7,    7,    7,    8,    9,   10,   11,   11,   11,   12,   13,   14,   15,   16,   17,   17,
         17,   17,   18,   18,   19,   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
         20,   20,   20,   20,   20,   20,   20,   21,   21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,
         33,   33,   33,   33,   33,   33,   34,   34,   34,   34,   35,   36,   36,   36,   36,   36,   36,   37,   38,   39,
         39,   40,   41,   41,   42,   43,   44,   45,   46,   47,   48,   48,   49,   50,   50,   51,   52,   53,   54,   55,
         55,   55,   56,   56,   56,   57,   57,   57,   58,   58,   59,   60,   61,   61,   61,   62,   62,   62,   62,   62,
         62,   62,   63,   64,   65,   65,   66,   66,   67,   67,   68,   68,   69,   69,   70,   70,   71,   71,   72,   72,
         73,   73,   74,   74,   75,   75,   76,   76,   77,   77,   78,   78,   79,   80,   80,   81,   82,   82
      };

/*--- Reduction Matrix and Access Vectors. ----------------------------------*/

   // R_matrix.
      uchar PGParser::Rm [49] =
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    9,    9,    0,    0,   16,    0,    0,    0,    0,  165,    0,
          0,  155,  155,    0,    0,    0,    0,  164,    0,    0,  162,  162,    0,   94,    0,   94,   94,   94,   95,   94,
          0,    0,    0,    0,    0,    0,    0,  150,  149
      };

   // R_matrix row.
      short PGParser::Rr [116] =
      {
          2,    0,   11,    4,   24,    0,    0,    5,    6,   -8,   20,    0,   25,    0,    0,    0,   16,    0,    0,    7,
          0,  174,    0,    0,    0,  139,   32,    0,    0,    0,    0,    0,  111,    0,   72,    0,   81,   65,    0,    0,
        111,    0,    0,  -14,  -23,  176,  176,  176,   62,   62,   62,   62,   62,  176,    0,  131,  131,  134,  134,    0,
          0,  184,   98,    0,  176,  163,    0,    0,  176,   62,   53,  176,  176,   62,   56,  176,  111,   63,  111,  111,
        111,  111,  139,  142,  138,  128,  142,  128,    0,    0,  -32,   97,  111,  111,    0,  150,  150,  138,    0,    0,
        193,  150,  150,   99,    0,  150,    0,  -40,  150,  150,  150,    0,    0,  150,    0,    0
      };

   // R_matrix column.
      uchar PGParser::Rc [42] =
      {
          0,    1,    1,    1,    1,    0,    2,    3,    3,    1,    1,    0,    3,    0,    3,    3,    3,    3,    4,    5,
          5,    3,    3,    3,    3,    0,    0,    0,    0,    0,    3,    3,    3,    3,    6,    6,    3,    3,    7,    3,
          3,    8
      };

/*--- Token Variables --------------------------------------------------------*/

	// Token Action number.
      char PGParser::tact_numb[42] =
      {
          0,    1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    2,    2,    2,    2,    2,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1
      };

   // Token Action Function Pointers.
      int (*PGParser::tact_func[3]) (int) =
      {
			PGTokenAction::error,
         PGTokenAction::firstsym,
         PGTokenAction::arrow
      };

   // First argument index for token actions.
      char PGParser::tact_arg[42] =
      {
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1
      };

/*--- Production Information. -----------------------------------------------*/

   // Production length - 1
      char PGParser::PL[198] =
      {
          1,    4,   -1,    0,   -1,    0,    0,    1,    2,    0,    0,   -1,    2,    3,    1,    2,    0,    1,    0,    0,
          0,    1,    0,    0,   -1,    0,    3,    3,    0,    0,    0,    0,    1,    1,    0,    3,    3,    1,    0,    0,
          2,    3,    2,    3,    3,    2,    3,    0,    2,    2,    2,    2,    2,    0,    2,    0,    0,    2,    0,    0,
          0,    0,   -1,    0,    0,    0,    1,    1,    0,    0,    1,    1,    0,    1,    1,    1,    1,    1,    1,    1,
          1,    0,    1,    1,    1,    1,    1,    2,    2,    2,    0,    1,    0,    1,    2,    2,    2,    1,    0,    1,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,   -1,    0,    0,    0,    0,    0,    1,    1,    2,
          2,    2,    3,    3,    1,    0,    1,    0,   -1,    1,    0,   -1,    1,    0,   -1,    1,    0,    1,   -1,   -1,
          1,    2,   -1,    1,    3,    2,    4,    6,    0,    0,   -1,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    1,    0,    0,    0,    1,    0,    1,    0,    1,    0,    1,   -1,    1,   -1,    0,    0,    1,
          0,    1,    0,    1,   -1,    1,    0,    1,    0,    2,    0,    0,    1,   -1,    1,    1,    0,    1
      };

   // Reverse the order of nodes (for a production/rule).
      uchar PGParser::reverse[198] =
      {
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0
      };

   // First argument index for parse actions and make node.
      short PGParser::pact_arg[198] =
      {
         -1,   -1,    6,   10,   -1,   -1,   -1,   -1,   -1,   29,   33,   37,   -1,   -1,   -1,   -1,   50,   54,   58,   62,
         66,   70,   74,   78,   -1,   -1,   88,   92,   96,  100,  104,  108,   -1,  115,  119,  120,  124,   -1,   -1,  131,
        135,  139,  143,  147,  151,  155,  159,  163,  164,  168,  172,  176,  180,   -1,  184,  188,   -1,  189,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        289,  293,  297,  301,  305,  309,  313,  317,  321,   -1,  325,   -1,   -1,   -1,   -1,   -1,   -1,  344,  348,  352,
        356,  360,  364,  368,  372,  376,  377,  381,  382,  386,  390,  391,  392,  396,  397,  398,  402,  403,  407,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  438,  442,  446,  450,  454,
        458,  462,  466,   -1,  473,  477,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

   // Action for a production
      char PGParser::pact_numb[198] =
      {
         -1,   -1,    0,    0,   -1,   -1,   -1,   -1,   -1,    1,    2,    3,   -1,   -1,   -1,   -1,    4,    5,    4,    4,
          4,    5,    4,    4,   -1,   -1,   -1,   -1,    6,    6,    6,    6,   -1,   -1,    7,    8,    8,   -1,    9,   10,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   11,    8,    8,    8,    8,    8,   -1,    8,   12,   -1,    8,   -1,   -1,
         -1,   -1,   -1,   -1,    9,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         10,   10,   10,   10,   10,   13,   14,   14,   14,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   15,   16,
         16,   17,   18,   18,   19,   20,   21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   30,   32,   33,
         33,   33,   33,   33,   33,   33,   33,   33,   -1,   -1,   34,   35,   -1,   -1,   -1,   36,   37,   37,   37,   38,
         37,   37,   39,   40,   41,   42,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

   // Parsing Action Function Pointers.
      int (*PGParser::pact_func[43]) (int) =
      {
			PGParseAction::options_,
         PGParseAction::constant_,
         PGParseAction::value_,
         PGParseAction::errordecl_,
         PGParseAction::terminal_,
         PGParseAction::terminalres_,
         PGParseAction::oper_,
         PGParseAction::goalsymbol_,
         PGParseAction::prod_,
         PGParseAction::tailposition_,
         PGParseAction::tail_,
         PGParseAction::headsymbol_,
         PGParseAction::arrow_,
         PGParseAction::tailkw_,
         PGParseAction::sep_,
         PGParseAction::make_node_,
         PGParseAction::make_node_wa_,
         PGParseAction::parse_action_make_node_,
         PGParseAction::parse_action_make_node_wa_,
         PGParseAction::token_action_spec_,
         PGParseAction::token_action_name_,
         PGParseAction::parse_action_spec_,
         PGParseAction::parse_action_name_,
         PGParseAction::blank_parse_action_,
         PGParseAction::node_spec_,
         PGParseAction::node_name_,
         PGParseAction::blank_node_name_,
         PGParseAction::pa_node_spec_,
         PGParseAction::pa_node_name_,
         PGParseAction::pa_blank_node_name_,
         PGParseAction::node_action_,
         PGParseAction::node_action_name_,
         PGParseAction::blank_node_action_name_,
         PGParseAction::args_,
         PGParseAction::arg_null_,
         PGParseAction::arg_first_,
         PGParseAction::arg_alpha_,
         PGParseAction::arg_terminal_,
         PGParseAction::arg_string_,
         PGParseAction::arg_integer_,
         PGParseAction::arg_expr_,
         PGParseAction::arg_expr_integer_,
         PGParseAction::arg_expr_alpha_
      };

/*--- PGParser Argument Variables. --------------------------------------------*/

   // Parse action argument numbers
      char PGParser::arg_numb[481] =
      {
         -1,   -1,   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,    1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    0,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,
         -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    4,   -1,   -1,   -1,    4,   -1,   -1,   -1,    1,   -1,   -1,   -1,
          1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,
          1,   -1,   -1,   -1,    1,   -1,   -1,   -1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,
         -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,
         -1,   -1,   -1,    1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,
          1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,    1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,
         -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,
         -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,
          1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,    1,   -1,   -1,
         -1,    1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,    1,    1,   -1,   -1,   -1,    1,    1,    1,   -1,
         -1,   -1,    1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    1,   -1,
         -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,
         -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,   -1,   -1,   -1,   -1,    1,   -1,   -1,   -1,    1,   -1,   -1,
         -1
      };

   // Text for string arguments (including node arguments).
      char* PGParser::arg_text[1] =
      {
         ""
      };

/*--- Node Variables --------------------------------------------------------*/

   // Node numbers (for a production).
      char PGParser::node_numb[198] =
      {
          0,    1,    2,    2,    3,    3,    3,    3,    4,    5,    6,   -1,    7,    7,    7,    7,    8,    9,    8,    8,
          8,    9,    8,    8,   10,   10,   11,   12,   13,   13,   13,   13,   14,   15,   -1,   16,   16,   17,   -1,   18,
         19,   19,   19,   19,   19,   19,   19,   -1,   16,   16,   16,   16,   16,   -1,   16,   -1,   -1,   16,   -1,   -1,
         -1,   -1,   17,   17,   -1,   -1,   20,   20,   20,   -1,   21,   22,   -1,   20,   20,   23,   24,   21,   22,   20,
         20,   -1,   23,   20,   24,   21,   22,   25,   25,   26,   27,   17,   27,   17,   28,   27,   27,   -1,   17,   17,
         18,   18,   18,   18,   18,   29,   30,   30,   30,   -1,   31,   -1,   32,   32,   32,   32,   32,   33,   34,   35,
         35,   36,   37,   37,   38,   -1,   39,   -1,   40,   41,   -1,   -1,   42,   -1,   -1,   43,   -1,   43,   -1,   44,
         44,   44,   44,   44,   44,   44,   44,   44,   -1,   -1,   45,   -1,   -1,   -1,   -1,   46,   47,   47,   47,   48,
         47,   47,   49,   50,   51,   52,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

   // Node action numbers.
      int AST::nact_numb[198] =
      {
          0,    1,    2,    2,    3,    3,    3,    3,    4,    5,    6,   -1,    7,    7,    7,    7,    8,    9,    8,    8,
          8,    9,    8,    8,   10,   10,   11,   12,   13,   13,   13,   13,   14,   15,   -1,   16,   16,   17,   -1,   18,
         19,   19,   19,   19,   19,   19,   19,   -1,   16,   16,   16,   16,   16,   -1,   16,   -1,   -1,   16,   -1,   -1,
         -1,   -1,   17,   17,   -1,   -1,   20,   20,   20,   -1,   21,   22,   -1,   20,   20,   23,   24,   21,   22,   20,
         20,   -1,   23,   20,   24,   21,   22,   25,   25,   26,   27,   17,   27,   17,   28,   27,   27,   -1,   17,   17,
         18,   18,   18,   18,   18,   29,   30,   30,   30,   -1,   31,   -1,   32,   32,   32,   32,   32,   33,   34,   35,
         35,   36,   37,   37,   38,   -1,   39,   -1,   40,   41,   -1,   -1,   42,   -1,   -1,   43,   -1,   43,   -1,   44,
         44,   44,   44,   44,   44,   44,   44,   44,   -1,   -1,   45,   -1,   -1,   -1,   -1,   46,   47,   47,   47,   48,
         47,   47,   49,   50,   51,   52,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

	// Node processor function pointers.
      int (*AST::nact_func[53]) (Node* np) =
      {
			PGNodeAction::start_,
         PGNodeAction::grammar_,
         PGNodeAction::options_,
         PGNodeAction::declarations_,
         PGNodeAction::constdecl_,
         PGNodeAction::constant_,
         PGNodeAction::value_,
         PGNodeAction::token_decl_,
         PGNodeAction::terminal_,
         PGNodeAction::terminalres_,
         PGNodeAction::operprec_,
         PGNodeAction::leftassoc_,
         PGNodeAction::rightassoc_,
         PGNodeAction::oper_,
         PGNodeAction::rules_,
         PGNodeAction::goaldef_,
         PGNodeAction::prod_,
         PGNodeAction::tails_,
         PGNodeAction::tail_,
         PGNodeAction::headdef_,
         PGNodeAction::repeat_,
         PGNodeAction::repeatsep_,
         PGNodeAction::repeatseprev_,
         PGNodeAction::reverse_,
         PGNodeAction::repeatrev_,
         PGNodeAction::sepexpr_,
         PGNodeAction::sepexprrev_,
         PGNodeAction::optgroup_,
         PGNodeAction::group_,
         PGNodeAction::tailkw_,
         PGNodeAction::sep_,
         PGNodeAction::token_action_,
         PGNodeAction::rule_actions_,
         PGNodeAction::parse_action_,
         PGNodeAction::make_node_,
         PGNodeAction::make_node_wa_,
         PGNodeAction::parse_action_make_node_,
         PGNodeAction::parse_action_make_node_wa_,
         PGNodeAction::token_action_spec_,
         PGNodeAction::parse_action_spec_,
         PGNodeAction::blank_parse_action_,
         PGNodeAction::node_spec_,
         PGNodeAction::pa_node_spec_,
         PGNodeAction::node_action_,
         PGNodeAction::args_,
         PGNodeAction::arg_null_,
         PGNodeAction::arg_alpha_,
         PGNodeAction::arg_terminal_,
         PGNodeAction::arg_string_,
         PGNodeAction::arg_integer_,
         PGNodeAction::arg_expr_,
         PGNodeAction::arg_expr_integer_,
         PGNodeAction::arg_expr_alpha_
      };

   // First argument index for node actions.
      short PGParser::nact_arg[198] =
      {
          0,    3,    7,   11,   14,   17,   20,   23,   26,   30,   34,   -1,   38,   41,   44,   47,   51,   55,   59,   63,
         67,   71,   75,   79,   82,   85,   89,   93,   97,  101,  105,  109,  112,  116,   -1,  121,  125,  128,   -1,  132,
        136,  140,  144,  148,  152,  156,  160,   -1,  165,  169,  173,  177,  181,   -1,  185,   -1,   -1,  190,   -1,   -1,
         -1,   -1,  193,  196,   -1,   -1,  199,  202,  205,   -1,  208,  211,   -1,  214,  217,  220,  223,  226,  229,  232,
        235,   -1,  238,  241,  244,  247,  250,  253,  256,  259,  262,  265,  268,  271,  274,  277,  280,   -1,  283,  286,
        290,  294,  298,  302,  306,  310,  314,  318,  322,   -1,  326,   -1,  329,  332,  335,  338,  341,  345,  349,  353,
        357,  361,  365,  369,  373,   -1,  378,   -1,  383,  387,   -1,   -1,  393,   -1,   -1,  399,   -1,  404,   -1,  408,
        411,  414,  417,  420,  423,  426,  429,  432,   -1,   -1,  435,   -1,   -1,   -1,   -1,  439,  443,  447,  451,  455,
        459,  463,  467,  470,  474,  478,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
         -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
      };

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    LRSTAR Parser.

	// Parser stuff ...
		PStack*  PGParser::PS;
		PStack*  PGParser::PS_end;
      PStack   PGParser::P_stack[STKSIZE];
		int      PGParser::max_errs;
		int		PGParser::prev_token;
		int		PGParser::goal_symbol;
		int		PGParser::start_symbol;
		int		PGParser::codeblock = 0;

	// Restore stack stuff ...
      RStack*	PGParser::RS;
      RStack	PGParser::R_stack[STKSIZE];
  		PStack*  PGParser::PStop;
  		int      PGParser::topstate;

	// Syntax analysis stuff ...
		char*    PGParser::T_list;
		int*     PGParser::P_list;

	// Symbol table stuff ...
      Symbol*  Symtab::symbol;
		int      Symtab::sti;
		short    Symtab::length;
		int      Symtab::n_symbols;
		uint     Symtab::hashdiv;
		int*		Symtab::hashvec;
		int      Symtab::cell;
		int		Symtab::max_cells;
		int      Symtab::max_symbols;

	// AST stuff ...
		Node*    AST::node;
		Node*    AST::root;
		Node*    AST::currnode;
      int*     AST::counter;
      char     AST::indent[256];
      Stack*   AST::stack;
      short    AST::stacki;
      char**   AST::term_symb;
      int      AST::n_nodenames =    53;	// Number of node names.
      int      AST::n_nodeactions =    53;	// Number of node actions.
      int      AST::n_nodes;
		short    AST::status;
		short    AST::pass;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    initialize -  initialize

void  PGParser::initialize (int max_symb)
{
      int  sti;
      char *p, sym[256];
      int  t, len, terminal;

		init_symtab (max_symb);                            // Initialize the symbol table.
		init_ast ();                                       // Initialize the AST.
		p = "";
		sti = add_symbol (0, p, p+1, 0, 0);              	// Add blank symbol as number 0.
      symbol[sti].value = -1;

	// See if lexer can read the 'literal' terminal symbols.
		n_errors = 0;
		for (t = 1; t < n_terms; t++)		                  // For all terminals except <error> (0).
		{
			if (*term_symb[t] == '\'')                      // Literal symbol?
			{
   			len = -1;
				for (p = term_symb[t]+1; *p != 0; p++)       // For all characters in terminal symbol.
				{
					if (++len > 255)                          // If length greater than 255 ...
					{
						n_errors++;
						printf ("Terminal symbol is longer than 255 characters:\n%s\n\n", term_symb[t]);
						PG::Terminate(0);
					}
					sym[len] = *p;                            // Move character to sym.
				}
				sym[len]  = 26;					               // Replace last ' with end-of-file character.
				token.end = sym;				                  // Starting point for next PGLexer read.
				terminal  = get_token();		               // Try to read symbol, get it's terminal number.
				sym[len]  = '\'';				                  // Replace end-of-file with '.
				if ((token.end-token.start) != len)          // Did not read the whole symbol?
				{
					n_errors++;
					printf ("Lexer was not able to recognized %s\n", term_symb[t]);
				}
				else if (terminal != t)			               // Terminal number not t?, must be a keyword!
				{
					if (terminal == 0)		                  // Got an error on this symbol?
					{
						n_errors++;
						printf ("Lexer returns zero for %s (check reduce-reduce conflicts).\n", term_symb[t]);
					}
					add_symbol (t, term_symb[t]+1, term_symb[t]+1+len, 0, 0); // Put terminal into symbol table.
				}
			}
		}
		if (n_errors) PG::Terminate(0);

	// Initialize some stuff.
      n_errors   = 0;
      n_warnings = 0;
      max_errs   = 10;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		terminate

void  PGParser::terminate ()
{
		term_ast  ();
		term_symtab ();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		parse

int   PGParser::parse (char* input_start)
{
      int    p;                                          // Production (rule) number.
      int    t = 0;                                      // Terminal symbol number.
      int    x = 0;                                      // State number.

      PS     = P_stack;							               // Set parse-stack pointer.
      PS_end = P_stack + STKSIZE;			               // Set parse-stack end pointer.
		init_lexer (input_start);				               // Initialize PGLexer.
		goal_symbol = 0;												// Not seen yet.
/*		prev_token = t;												// Define previous token.
    	t = get_token ();							               // Get first token.
      RS = R_stack;                                      // Set restore-stack pointer.
		PStop = PS;								                  // Save parse-stack pointer.
		topstate = x;								               // Save current state.
		if (t == 0) goto Err;										// Bad token!
		goto Cont;
*/
Read:	prev_token = t;												// Define previous token.
		t = get_token ();							               // Get incoming token.
      RS = R_stack;                                      // Set restore-stack pointer.
		PStop = PS;								                  // Save parse-stack pointer.
		topstate = x;								               // Save current state.
Cont:
		token.sti = -t;							               // Point at terminal symbol.
      if (tact_numb[t] >= 0)					               // If token action ...
      {
         t = (*tact_func [tact_numb[t]])(t);             // Call token-action function.
      }

Shft: if (Bm [Br[x] + Bc[t]] & Bmask[t])	               // Check B-matrix for shift action.
      {
			if (++PS >= PS_end) goto Overflow;
         PS->state = x;                                  // Put current state on stack.
         PS->sti   = token.sti;                          // Put token symbol table index on stack.
         PS->start = token.start;                        // Put token.start into parse stack.
         PS->end   = token.end;                          // Put token.end   into parse stack.
         PS->line  = token.line;                         // Put its line number on stack.
         PS->node  = NULL;			   	                  // Set node on stack to null.
         x = Tm [Tr[x] + Tc[t]];                         // Get next state from terminal transition matrix.
         while (x <= 0)                                  // While shift-reduce actions.
         {
            PS -= PL[-x];                                // Reduce stack ptr by production length.
			  	if (reduce_action(-x) != 0) return -line_numb;  // Call reduce action with rule number.
            x = Nm [Nr[PS->state] + Nc[-x]];             // Get next state from nonterminal transition.
         }
         goto Read;								               // Go to read next token.
      }

		if ((p = Rr[x]) > 0 || (p = Rm [Rc[t] - p]) > 0)   // Get reduction?
      {
         if (PL[p] < 0)							               // Null production?
         {
				if (++PS >= PS_end) goto Overflow;
				RS++;									               // Increment the restore stack pointer.
				RS->ptr   = PS;					               // Save parse-stack pointer.
     		   RS->state = PS->state;			               // Save old state before replacing it.
            PS->state = x;						               // Stack current state, replacing old state.
            PS->node  = NULL;					               // Clear node pointer.
            PS->sti   = 0;					                  // Clear sti.
				goto Red2;
         }
         while (1)
         {
            PS -= PL[p];                                 // Reduce parse stack ptr by rule length - 1.
Red2:		// Reduce action ...
			  	if (reduce_action(p) != 0) return -line_numb; // Call reduce action with rule number.
            x = Nm [Nr[PS->state] + Nc[p]];	            // Get next state from nonterminal transition.
            if (x > 0) goto Shft;                        // Continue parsing.
            p = -x;								               // Set production number.
         }
      }

		if (codeblock) 
		{ 
			t = 0; 
			goto Shft; 
		}

      if (x == ACCEPT_STATE)					               // If Goal production.
      {
         PS -= PL[p];                                    // Reduce parse stack ptr by rule length - 1.
			if (reduce_action(p) != 0) return -line_numb;   // Call reduce action with rule number.
			line_numb--;			      	                  // Reduce line number by one.
         if (n_errors) return -line_numb;
			root = PS[0].node;                              // Define root node.

         pass = FIRST_PASS;
  		   traverse ();
         if (n_errors) return -line_numb;

         pass = SECOND_PASS;
		   traverse ();
         if (n_errors) return -line_numb;

         pass = THIRD_PASS;
		   traverse ();
         if (n_errors) return -line_numb;
			return line_numb;
      }

Err:	syntax_error (term_symb[t]);			               // Print syntax error message.
		expecting ();								               // Print syntax help (list of tokens expected).
		return -line_numb;						               // Return negative number of lines for failure.

Overflow:                                                // Parser stack overflow.
		prt_log ("\nInternal error, Parser stack overflow.\n\n");
		return -line_numb;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		reduce_action

int   PGParser::reduce_action (int p)
{
		if (pact_numb[p] >= 0)	  							// PARSE ACTION ?
		{
			int rc;												// Return code.
			rc = (*pact_func [pact_numb[p]])(p);		// Call parse action with production number.
			if (rc < 0)											// Bypass make node operation?
			{
				goto Linkup;
			}
		}
      int psi;											      // Parse Stack Index.
      currnode = NULL;
      if (node_numb[p] >= 0)   					      // MAKE NODE ?
      {
         currnode = (Node*)ALLOC(node, 1);
         currnode->id     = node_numb[p];				// Set node id.
         currnode->numb   = n_nodes++;				   // Set node number.
         currnode->prod   = p;							// Put production (rule) number in node.
         currnode->next   = NULL;						// Set next to nonexistent.
         currnode->prev   = NULL;						// Set prev to nonexistent.
         currnode->child  = NULL;		            // Define no child.
         currnode->parent = NULL;		            // Define no parent.
         if (pact_arg[p] >= 0)				   		// If node argument defined,...
         {
            psi = arg_numb[pact_arg[p]]-1;	   	// Get parse-stack index.
            currnode->sti   = PS[psi].sti;		   // Move sti from parse stack to node.
            currnode->start = PS[psi].start;	      // Move start from parse stack to node.
            currnode->end   = PS[psi].end;	      // Move end from parse stack to node.
            currnode->line  = PS[psi].line;	      // Move line from parse stack to node.
         }
         else
         {
            currnode->sti   = 0;    					// Set symbol-table index to zero.
            currnode->start = NULL;	               // Set start to null.
            currnode->end   = NULL;	               // Set end to null.
            currnode->line  = 0;							// Set line number to 0.
         }
			psi = linkup(p);									// Linkup the nodes in this rule.
			if (psi >= 0)										// Any nodes found in this rule?
         {
				  currnode->child = PS[psi].node;      // Define child.
              PS[psi].node->parent = currnode;     // Define parent.
         }
			PS[0].node = PS[0].last = currnode;		   // Define node in the parse stack.
         n_nodes++;
      }
		else	                                       // Check for nodes not linked?
		{
Linkup:  psi = linkup (p);                         // Get parse-stack index.
			if (psi > 0)                              // If we have a node here ...
			{
				PS[0].node = PS[psi].node;		         // Move node value to 1st position.
				PS[0].last = PS[psi].last;		         // Move last value also.
			}
		}
      return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		linkup

int   PGParser::linkup (int p)
{
      int i;
      int next = -1;
      for (i = PL[p]; i >= 0; i--)				         // For each tail pointer.
      {
         if (PS[i].node != NULL)                      // If tail points to node.
         {
            if (next >= 0)                            // If one waiting.
            {
               PS[i].last->next = PS[next].node;      // Attach node to end of list.
               PS[next].node->prev = PS[i].last;      // Define previous node.
               PS[i].last = PS[next].last;            // Change last to next last.

            }
            next = i;									      // Next = Curr.
			}
		}
      return (next);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    syntax_error

void  PGParser::syntax_error (char *symb)
{
      int  col, ln1, ln2;
      char string[10000], *ls1, *ls2, *le1, *le2, *p, c;

      n_errors++;

	// Get first line number ...
      ln1 = line_numb;
		for (p = token.end-1; p > token.start; p--)
		{
			if (*p == '\n') ln1--;
		}

	// Get first line start ...
		for (ls1 = token.start; *ls1 != '\n'; ls1--);
		ls1++;

	// Get first line end ...
		for (le1 = token.start; *le1 != '\n'; le1++);

	// Get last line number ...
      ln2 = line_numb;

	// Get last line start ...
		for (ls2 = token.end-1; *ls2 != '\n'; ls2--);
		ls2++;

	// Get last line end ...
		for (le2 = token.end; *le2 != '\n'; le2++);
		*le1 = 0;
		*le2 = 0;

		if (*token.start == '\n') ln1--;
      col = 1;
      for (p = ls1; p < token.start; p++)
      {
         if (*p == '\t') *p = ' ';
         col++;
      }
		prt_log ("%s(%04d) : Error  %s\n", grmfid, ln1, ls1);
      *le1 = '\n'; // In case token is this <eol>

      memset (string, '-', col);
      string [col] = 0;

		prt_log ("%s(%04d) : Error %s^ ", grmfid, ln1, string);

      if (*token.start <= 32)
      {
         short x = *token.start;
         if (x < 0) x += 256;
         prt_log ("at character code %d %s\n\n", x, symb);
      }
      else
      {
         if (token.end == token.start) token.end++;
         if (token.end > le1)
         {
				if (*token.start == '\n') *token.start = 0;
            if (*token.end == EOF_CHAR) line_numb--;
            c = *le1;
            *le1 = 0;
            prt_log ("starts at %s\n", token.start, ln1);
				prt_log ("%s(%04d) : Error ends here.\n\n", grmfid, ln2);
            *le1 = c;
         }
         else
         {
            c = *token.end;
            *token.end = 0;
				if (*token.start == '\n') *token.start = 0;
            prt_log ("at %s %s\n\n", token.start, symb);
            *token.end = c;
         }
      }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		expecting // Print expecting list.

void  PGParser::expecting ()
{
		int t;
		T_list = (char*)malloc (sizeof(*T_list)*n_terms);
		P_list = (int* )malloc (sizeof(*P_list)*n_prods);
		for (t = 0; t < n_terms; t++) T_list[t] = 0;

		prt_log ("Expecting one of the following:\n\n");

 		for (PS = PStop; RS > R_stack; RS--)   // Restore PS, RS and states.
      {
         RS->ptr->state = RS->state;         // Reset state to saved state.
      }

	  	collect (topstate);		               // Collect all terminal symbols expected.

		for (t = 0; t < n_terms; t++)
      {
         if (T_list[t])
         {
       	   prt_log ("\t%-20s\n", term_symb[t]);
         }
      }
		prt_log ("\n");
		free (P_list);
		free (T_list);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//		collect: Collect terminals that cause a transition or reduction.

void	PGParser::collect (int x)
{
		int t, p, q, i, la, n_red;

   // TRANSITION TO NEXT STATE? ...
     	for (t = 0; t < n_terms; t++)						// For all terminals.
		{
  			if (Bm [Br[x] + Bc[t]] & Bmask[t])			// Accept this terminal?
			{
            T_list[t] = 1;                         // Mark this terminal.
			}
		}
		n_red  = 0;                                  // Reset to zero reductions.
   // REDUCTIONS IN THIS STATE? ...
		if ((p = Rr[x]) > 0)									// Default reduction?
		{
			P_list[n_red++] = p;	                     // Add this production to list.
		}
		else														// Reductions based on lookaheads!
		{
			for (la = 0; la < n_terms; la++)			   // For all lookaheads.
			{
				if ((q = Rm [Rc[la] - p]) > 0)			// Got a reduction on this terminal?
				{
			  		for (i = 0; i < n_red; i++)			// For all reductions in the list.
					{
						if (P_list[i] == q) goto Next;   // Already in this list?
					}
					P_list[n_red++] = q;	               // Add this production to list.
				}
Next:       continue;
			}
		}

   // MAKE REDUCTIONS ...
	  	for (i = 0; i < n_red; i++)
		{
         p = P_list[i];
         if (PL[p] < 0)                            // Null production?
         {
			   PS++;											   // Increment stack pointer.
            PS->state = x;								   // Stack state.
			   goto Cont;
         }
		   do
		   {
			   PS -= PL[p];								   // Reduce parse stack pointer.
Cont:		   p = -Nm [Nr[PS->state] + Nc[p]];		   // Get production or next state.
		   }
		   while (p > 0);
		   collect (-p);									   // Go collect terminals.
		}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    init_symtab

void  Symtab::init_symtab (int max_symb)
{
      int i;
		max_symbols   = max_symb;
		max_cells     = 2*max_symbols;
		ALLOC (symbol,  max_symbols);
      ALLOC (hashvec, max_cells);
      hashdiv       = UINT_MAX / max_cells + 1;
      n_symbols	  = 0;
      if (hashvec == NULL)
      {
			printf ("Not enough memory available for Symbol Table.\n\n");
         PG::Terminate(0);
      }
      for (i = 0; i < max_cells; i++) hashvec[i] = -1;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    term_symtab

void  Symtab::term_symtab ()
{
      delete [] symbol;
      delete [] hashvec;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    add_symb - add symbol to table.

int   Symtab::add_symbol (short t, char* token_start, const char* token_end, int type, int line)
{
      char*p;
		sti = get_symbol (token_start, token_end, type);
		if (sti < 0)
		{
			sti = n_symbols;
			if (n_symbols >= max_symbols)				   // Reached maximum number?
			{
            MemCrash ("Number of symbols", max_symbols); 
				PG::Terminate(0);
			}
			hashvec[cell] = n_symbols;					   // Put symbol number into hash vector.
         p = ALLOC (p, length+1);                  // Allocate space for text string.
         memcpy (p, token_start, length);	         // Move string to allocated space.
         *(p+length) = 0;                          // Padd with zero byte.
         symbol[n_symbols].name   = p;             // Define pointer to symbol name.
         symbol[n_symbols].start  = token_start;   // Define pointer to symbol start address in source code.
			symbol[n_symbols].line   = line;			   // Define line number in grammar.
			symbol[n_symbols].type   = 0;					// Don't define type.
			symbol[n_symbols].numb   = -1;			   // Define sequence number as -1 (undefined).
			symbol[n_symbols].value  = 0;				   // Define value as zero (undefined).
			symbol[n_symbols].length = length;		   //	Define symbol length.
			n_symbols++;									   // Increment number of symbols.
		}
      return (sti);									      // Return symbol-table index.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    get_symbol - get symbol number from table.

int   Symtab::get_symbol (const char* token_start, const char* token_end, int type)
{
      const char* p = token_start;		    	         // Point at start.
      const char* q = token_end;			 	            // Point at end.
      length = (short)(q-p);       				   // Get length.
      uint hash = length;         	   		   // Set hash to length.
      int i = 0;						   			   // Set shift value to 0.
      do									      		   // Assume length != 0
      {
         hash += *p << i;
         i += 4;
         i %= 32;
      }
      while (++p < q);
      cell = hash % max_cells; 					   // Get first cell.
		i = hashvec [cell];				   		   // Get symbol index.
      if (i >= 0)
		{
         p = token_start;				            // Point at token start.
			do
			{
				if (symbol[i].length == length && symbol[i].type & type)	// Length and type match?
				{
					q = symbol[i].name;				   // Point at symbol name.
					short j = 0;
					do
					{
						if (p[j] != q[j]) goto Cont;	// If characters not equal ...
					}
					while (++j < length);				// while end not reached.
					return (i);								// Found it.
				}
			Cont:
                                cell = (hash *= 65549) / hashdiv;	// Get new cell number.
                                cell %= max_cells;
				i = hashvec [cell];					   // Get symbol index.
			}
			while (i >= 0);      					   // While not empty slot.
		}
      return (i);										   // Return symbol number.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    print - print symbol table contents.

void  Symtab::print_symtab (char** term_symb)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    symname - get symbol name.

char* Symtab::symname (int i)
{
      static char name[2000];
      char* p;
      short L;

		if (i == 0)
		{
			name[0] = 0;
			return name;
		}

      p = symbol[i].name;
      L = symbol[i].length;

      if (L >= 2000)
      {
	      for (i = 0; i < 100; i++) name[i] = p[i];
		   name[i] = 0;
			prt_log ("Symbol length of %d is too big (>= 2000).\n", L);
			prt_log ("for '%s'\n.", name);
         PG::Terminate(0);
      }
      for (i = 0; i < L; i++) name[i] = p[i];
      name[i] = 0;
      return name;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//																										                     //
//    ABSTRACT-SYNTAX-TREE FUNCTIONS

/*    static uchar numeric[256] = // numeric[x] gives 1..10 for digits 0..9
      {
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      1,  2,  3,  4,  5,  6,  7,  8,  9, 10,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
      };
*/
		char draw_plus [] = "+ ";
		char draw_vbar [] = "| ";
		char draw_last [] = "+ ";
		char draw_space[] = "  ";

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    init_ast

void  AST::init_ast ()
{
	  	root = (Node*)ALLOC (node, 1);
      root->id     = -1;  // Undefined.
      root->numb   = 0;
      root->prod   = 0;
      root->sti    = 0;
      root->line   = 0;
      root->next   = NULL;
      root->prev   = NULL;
      root->child  = NULL;
      root->parent = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    term_ast

void  AST::term_ast ()
{
		delete [] node;
      delete [] stack;
      delete [] counter;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    print_ast

void  AST::print_ast (char** Term_Symb)
{
      term_symb = Term_Symb;
		if (n_nodes > 1)
			print_ast (root);
		else
			prt_lst ("AST is empty.\n\n");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    print_ast (n)

void  AST::print_ast (Node* np) // Print subtree.
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse

void  AST::traverse ()
{
	  	if (n_nodes > 1) // Any nodes in the tree?
		{
         if (n_nodeactions > 0) // Any AST actions in the parser?
			{
				int i;
				stacki = -1;
				ALLOC (stack, STKSIZE);
				ALLOC (counter, n_nodenames);
				for (i = 0; i < n_nodenames; i++)
				{
					counter[i] = 0;
				}
  				traverse (root);	// Start AST traversal.

			}
		}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    traverse (n)

void  AST::traverse (Node* np)
{
      Node* cp;
		int   i, p, na;
		i = np->id;
      p = np->prod;
      counter[i]++;
      stacki++;
      stack[stacki].id = i;
      stack[stacki].counter = counter[i];
	//	na = nact_numb[p];
	  	na = i;

		if (na >= 0)
		{
			status = TOP_DOWN;
			(*nact_func[na]) (np);
		}

    	cp = np->child;
      while (cp != NULL)
		{
    	   traverse (cp);
			if ((cp = cp->next) != NULL)
			{
				if (na >= 0)
				{
					status = PASS_OVER;
					(*nact_func[na]) (np);
				}
         }
		}

		if (na >= 0)
		{
			status = BOTTOM_UP;
			(*nact_func[na]) (np);
		}
      stacki--;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                 //
//    emitstr

short AST::emitstr (Node* np, char* str)
{
      short sti;
      int   i, x;
      char  string[1000];
      char  *symb, *s, *p;

   // Get symbol from node.
      sti  = np->sti;
		if (sti < 0) symb = term_symb[-sti];
      else         symb = symname(sti);

   // Scan string for &-codes ...
      p = str;
      s = string;
      while (1)
      {
         *s = *p;
         if (*s == 0)
         {
				prt_lst (string, symb);
            return (0);
         }
         if (*s == '&') // &-code ?
         {
            if (numeric[*++p]) // number ?
            {
               x = *p - '0';
               while (numeric[*++p]) x = 10*x + *p - '0';
               i = stacki - x;
               if (i < 0) *s++ = '?'; // Error.
               else
               {
                  switch (*p)
                  {
                     case 'c':
							s += sprintf (s, "%d", stack[i].counter); // Get counter.
                     p++;
                     break;

                  // case 'n':
						//	s += sprintf (s, "%s", node_name[stack[i].id]); // Get node name.
                  // p++;
                  // break;

                     default:
							s += sprintf (s, "%d", stack[i].counter); // Get counter.
                     break;
                  }
               }
            }
            else s++;
         }
         else { s++; p++; }
      }
		return (0);
}


//    End of LRSTAR Parser.
//																																   //
/////////////////////////////////////////////////////////////////////////////////////////////////////

#endif


